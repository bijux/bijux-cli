{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to Bijux CLI Documentation.</p>"},{"location":"#bijux-cli","title":"Bijux CLI","text":"<p>A modern, predictable, and extensible CLI framework \u2014 with strict runtime contracts, a first-class plugin system, structured output, and built-in diagnostics.</p>"},{"location":"#features-at-a-glance","title":"Features at a Glance","text":"<ul> <li>Plugin-driven architecture \u2013 add/override behavior without touching core.</li> <li>Deterministic global flags \u2013 strict precedence for consistent behavior   (see ADR: Global Flags Precedence).</li> <li>Dependency-Injection kernel \u2013 decoupled services, easy to test.</li> <li>Interactive REPL \u2013 persistent shell for exploration and debugging.</li> <li>Structured output \u2013 JSON/YAML with pretty/compact controls.</li> <li>Diagnostics \u2013 environment checks, DI graph inspection, plugin validation.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Requires Python 3.11+</p> <pre><code># Recommended: isolated CLI install\npipx install bijux-cli\n\n# Or via pip\npip install bijux-cli\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># See commands and global flags\nbijux --help\n\n# Run environment diagnostics\nbijux doctor\n\n# Start the interactive shell\nbijux\nbijux&gt; help\nbijux&gt; exit\n</code></pre>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#structured-output-jsonyaml","title":"Structured Output (JSON/YAML)","text":"<pre><code># Compact JSON for scripting\nbijux status -f json --no-pretty\n\n# Pretty JSON for humans\nbijux status -f json --pretty\n\n# YAML\nbijux status -f yaml\n</code></pre>"},{"location":"#di-developer-introspection","title":"DI &amp; Developer Introspection","text":"<pre><code># Inspect DI registrations\nbijux dev di -f json | jq\n\n# List loaded plugins\nbijux dev list-plugins\n</code></pre>"},{"location":"#plugins","title":"Plugins","text":"<pre><code># Scaffold, install, and validate a plugin\nmkdir -p ./tmp_plugin &amp;&amp; cd ./tmp_plugin\nbijux plugins scaffold my_plugin --template=../plugin_template --force\ncd ..\nbijux plugins install ./tmp_plugin/my_plugin --force\nbijux plugins check my_plugin\nbijux plugins list\n</code></pre>"},{"location":"#global-flags-precedence","title":"Global Flags (Precedence)","text":"<p>Higher priority wins and may short-circuit lower ones.</p> Priority Flag(s) Effect 1 <code>-h</code>, <code>--help</code> Exit 0 immediately; ignore all other flags. 2 <code>-q</code>, <code>--quiet</code> Suppress both stdout and stderr; exit code still reflects the result. 3 <code>-d</code>, <code>--debug</code> Full diagnostics; implies <code>--verbose</code>, forces <code>--pretty</code>. 4 <code>-f, --format &lt;json\\|yaml&gt;</code> Choose structured output; invalid value \u2192 exit code <code>2</code>. 5 <code>--pretty</code>/<code>--no-pretty</code> Control indentation (default: <code>--pretty</code>). 6 <code>-v</code>, <code>--verbose</code> Add runtime metadata; implied by <code>--debug</code>. <p>Reference: ADR-0002 Global Flags Precedence https://bijux.github.io/bijux-cli/ADR/0002-global-flags-precedence/</p>"},{"location":"#built-in-commands","title":"Built-in Commands","text":"Command Purpose Example <code>doctor</code> Environment health check <code>bijux doctor</code> <code>status</code> Show CLI status <code>bijux status -f json</code> <code>repl</code> Interactive shell <code>bijux repl</code> <code>plugins</code> Manage plugins <code>bijux plugins list</code> <code>config</code> Manage key-value settings <code>bijux config set core_timeout=5</code> <code>history</code> REPL history operations <code>bijux history --limit 10</code> <code>audit</code> Security/compliance audit <code>bijux audit --dry-run</code> <code>docs</code> Docs/spec generation utilities <code>bijux docs --out spec.json</code> <code>dev</code> Developer tools (DI, plugins) <code>bijux dev di</code> <code>sleep</code> Pause execution <code>bijux sleep -s 5</code> <code>version</code> Display version info <code>bijux version</code> <p>Plugins are surfaced as top-level commands once installed.</p>"},{"location":"#shell-completion","title":"Shell Completion","text":"<p>Enable tab completion (no sudo required):</p> <pre><code># Install completion (zsh saves to ~/.zfunc)\nbijux --install-completion\n\n# Or print the script if you manage completions manually\nbijux --show-completion\n</code></pre> <p>Restart your shell afterward. For zsh, ensure <code>compinit</code> runs and your <code>fpath</code> includes the completions' directory.</p>"},{"location":"#configuration-paths","title":"Configuration &amp; Paths","text":"<p>Defaults (overridable via env vars):</p> <ul> <li>Config: <code>~/.bijux/.env</code> \u2192 <code>BIJUXCLI_CONFIG</code></li> <li>History: <code>~/.bijux/.history</code> \u2192 <code>BIJUXCLI_HISTORY_FILE</code></li> <li>Plugins: <code>~/.bijux/.plugins</code> \u2192 <code>BIJUXCLI_PLUGINS_DIR</code></li> </ul> <p>Resolution order: CLI flags \u2192 Environment \u2192 Config file \u2192 Defaults</p> <p>Example override:</p> <pre><code>export BIJUXCLI_PLUGINS_DIR=./.plugins\nexport BIJUXCLI_CONFIG=./.env\nexport BIJUXCLI_HISTORY_FILE=./.history\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>User Guide: https://bijux.github.io/bijux-cli/usage/</li> <li>Contributing: https://bijux.github.io/bijux-cli/contributing/</li> <li>Security Policy: https://bijux.github.io/bijux-cli/security/</li> <li>Code of Conduct: https://bijux.github.io/bijux-cli/code_of_conduct/</li> </ul>"},{"location":"#support-security","title":"Support &amp; Security","text":"<ul> <li>Issues: please include <code>--debug</code> output where feasible.</li> <li>Vulnerabilities: report privately via GitHub Security Advisory.   https://github.com/bijux/bijux-cli/security/advisories/new</li> </ul>"},{"location":"#license","title":"License","text":"<p>Released under the MIT License. https://bijux.github.io/bijux-cli/license/</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Bijux CLI are documented here. This project adheres to Semantic Versioning and the Keep a Changelog format.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>(add new entries via Towncrier fragments in <code>changelog.d/</code>)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog/#010-2025-08-12","title":"0.1.0 \u2013 2025-08-12","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li> <p>Core runtime</p> <ul> <li>Implemented Dependency Injection kernel, REPL shell, plugin loader, telemetry hooks, and shell completion (bash/zsh/fish).</li> <li>Added core modules: <code>api</code>, <code>cli</code>, <code>httpapi</code>, <code>core/{constants,context,di,engine,enums,exceptions,paths}</code>.</li> </ul> </li> <li> <p>Contracts layer (<code>contracts/</code>)</p> <ul> <li>Defined protocols for <code>audit</code>, <code>config</code>, <code>context</code>, <code>docs</code>, <code>doctor</code>, <code>emitter</code>, <code>history</code>,   <code>memory</code>, <code>observability</code>, <code>process</code>, <code>registry</code>, <code>retry</code>, <code>serializer</code>, <code>telemetry</code>.</li> <li>Added <code>py.typed</code> markers for downstream type checking.</li> </ul> </li> <li> <p>Services layer</p> <ul> <li>Implemented concrete services for <code>audit</code>, <code>config</code>, <code>docs</code>, <code>doctor</code>, <code>history</code>, <code>memory</code>.</li> <li>Built plugin subsystem: <code>plugins/{entrypoints,groups,hooks,registry}</code>.</li> </ul> </li> <li> <p>Infra layer (<code>infra/</code>)</p> <ul> <li>Implemented <code>emitter</code>, <code>observability</code>, <code>process</code>, <code>retry</code>, <code>serializer</code>, <code>telemetry</code>.</li> </ul> </li> <li> <p>Command suite</p> <ul> <li>Added top-level commands: <code>audit</code>, <code>docs</code>, <code>doctor</code>, <code>help</code>, <code>repl</code>, <code>sleep</code>, <code>status</code>, <code>version</code>.</li> <li>Added <code>config/</code> commands: <code>clear</code>, <code>export</code>, <code>get</code>, <code>list</code>, <code>load</code>, <code>reload</code>, <code>set</code>, <code>unset</code>, <code>service</code>.</li> <li>Added <code>dev/</code> commands: <code>di</code>, <code>list-plugins</code>, <code>service</code>.</li> <li>Added <code>history/</code> commands: <code>clear</code>, <code>service</code>.</li> <li>Added <code>memory/</code> commands: <code>clear</code>, <code>delete</code>, <code>get</code>, <code>list</code>, <code>set</code>, <code>service</code>.</li> <li>Added <code>plugins/</code> commands: <code>check</code>, <code>info</code>, <code>install</code>, <code>list</code>, <code>scaffold</code>, <code>uninstall</code>.</li> </ul> </li> <li> <p>Structured output &amp; flags</p> <ul> <li>Added JSON/YAML output via <code>--format</code>, pretty printing, and deterministic global flag precedence (ADR-0002).</li> </ul> </li> <li> <p>API contract validation &amp; testing</p> <ul> <li>Automated lint/validation of <code>api/*.yaml</code> with Prance, OpenAPI Spec Validator, Redocly, and OpenAPI Generator.</li> <li>Added Schemathesis contract testing against the running server.</li> <li>Pinned OpenAPI Generator CLI version via <code>OPENAPI_GENERATOR_VERSION</code> and automated Node.js toolchain setup in Makefile.</li> </ul> </li> <li> <p>Documentation tooling</p> <ul> <li>Integrated MkDocs (Material), mkdocstrings, literate-nav, and ADR index generation.</li> </ul> </li> <li> <p>Quality &amp; security pipeline</p> <ul> <li>Added formatting/linting: <code>ruff</code> (+format).</li> <li>Added typing: <code>mypy</code>, <code>pyright</code>, <code>pytype</code>.</li> <li>Added docs style/coverage: <code>pydocstyle</code>, <code>interrogate</code>.</li> <li>Added code health: <code>vulture</code>, <code>deptry</code>, <code>radon</code>, <code>codespell</code>, <code>reuse</code>.</li> <li>Added security: <code>bandit</code>, <code>pip-audit</code>.</li> <li>Added mutation testing: <code>mutmut</code>, <code>cosmic-ray</code>.</li> </ul> </li> <li> <p>SBOM</p> <ul> <li>Generated CycloneDX JSON for prod/dev dependencies via <code>make sbom</code> (uses <code>pip-audit</code>).</li> </ul> </li> <li> <p>Citation</p> <ul> <li>Validated <code>CITATION.cff</code> and added export to BibTeX/RIS/EndNote formats via <code>make citation</code>.</li> </ul> </li> <li> <p>Makefile architecture</p> <ul> <li>Modularized the Makefile into <code>makefiles/*.mk</code> for maintainability and clear separation of concerns.</li> <li>Centralized all developer workflows (<code>test</code>, <code>lint</code>, <code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>, <code>build</code>, <code>sbom</code>, <code>citation</code>, <code>changelog</code>, <code>publish</code>) in one consistent interface.</li> <li>Added <code>bootstrap</code> target for idempotent virtualenv setup and Git hook installation from <code>scripts/git-hooks</code> (skips re-installation if already linked).</li> <li>Added <code>all-parallel</code> target to run independent checks (<code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>) concurrently for faster CI/CD.</li> <li>Added <code>make help</code> for self-documenting targets with grouped sections.</li> <li>Provided helper macros (<code>run_tool</code>, <code>read_pyproject_version</code>) to standardize tooling invocation.</li> </ul> </li> <li> <p>pre-commit</p> <ul> <li>Added hygiene hooks: <code>ruff-format</code> + <code>ruff</code>, <code>mdformat</code>, and <code>codespell</code>.</li> <li>Enforced Conventional Commits via commitizen <code>commit-msg</code> hook.</li> </ul> </li> <li> <p>tox orchestration</p> <ul> <li>Configured multi-Python test envs (<code>py311</code>, <code>py312</code>, <code>py313</code>).</li> <li>Mapped Makefile workflows into tox envs (<code>lint</code>, <code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>, <code>build</code>, <code>sbom</code>, <code>changelog</code>, <code>citation</code>) to ensure reproducibility.</li> <li>Passed <code>MAKEFLAGS</code> to execute Makefile targets inside tox-managed virtualenvs.</li> </ul> </li> <li> <p>Continuous Integration</p> <ul> <li>Added GitHub Actions workflow running tox across Python versions with Node.js 20 and Java 17 for API checks.</li> <li>Added GitLab CI sample mirroring the GitHub workflow (tox-driven) with artifacts for coverage and API logs.</li> <li>CI/CD pipelines directly leverage the modularized Makefile for consistent local/CI behavior.</li> </ul> </li> <li> <p>Packaging / PyPI page</p> <ul> <li>Built dynamic long description via hatch-fancy-pypi-readme from README.md and CHANGELOG.md for PyPI/TestPyPI.</li> <li>Packaged with <code>LICENSES/</code>, <code>REUSE.toml</code>, <code>CITATION.cff</code>, and <code>py.typed</code> included in source distributions.</li> </ul> </li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Released initial public version.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>None</li> </ul>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make participation in this community a harassment-free experience for everyone\u2014regardless of age, body size, disability (visible or invisible), ethnicity, sex characteristics, gender identity or expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual orientation. We commit to interactions that are open, welcoming, inclusive, and healthy.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Positive behaviors</p> <ul> <li>Show empathy, kindness, and respect.</li> <li>Welcome different opinions and experiences.</li> <li>Give and receive constructive feedback gracefully.</li> <li>Own mistakes, apologize, and learn.</li> <li>Prioritize what benefits the community as a whole.</li> </ul> <p>Unacceptable behaviors</p> <ul> <li>Sexualized language or imagery; unwelcome sexual attention or advances.</li> <li>Trolling; insulting/derogatory remarks; personal or political attacks.</li> <li>Public or private harassment; deliberate intimidation or stalking.</li> <li>Publishing others\u2019 private information (e.g., physical or email address) without explicit permission.</li> <li>Deliberate misgendering or use of deadnames.</li> <li>Any conduct a reasonable person would deem inappropriate in a professional setting.</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing this Code. They may remove or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code and will communicate moderation reasons when appropriate. Actions will be proportional to the circumstances.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code applies in all project spaces (repositories, issues, discussions, chats) and when individuals are officially representing the project in public spaces (e.g., using an official email, posting via an official account, or representing the project at events\u2014online or offline).</p>"},{"location":"code_of_conduct/#reporting","title":"Reporting","text":"<p>Report abusive, harassing, or otherwise unacceptable behavior to the maintainers at mousavi.bijan@gmail.com.</p> <p>To help us investigate, please include (to the extent you\u2019re comfortable):</p> <ul> <li>What happened, and when</li> <li>Where it occurred (link, channel, or location)</li> <li>Names of people involved and any witnesses</li> <li>Any relevant context or screenshots</li> </ul> <p>We will acknowledge receipt as soon as possible and handle reports promptly and fairly. We will respect the privacy and safety of reporters and witnesses.</p> <p>Anti-retaliation: Retaliation against anyone who reports a concern or participates in an investigation is a violation of this Code.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>1) Correction Impact: Inappropriate or unprofessional behavior. Consequence: Private, written warning that clarifies the violation and sets expectations. A public apology may be requested.</p> <p>2) Warning Impact: A violation through a single incident or a series of actions. Consequence: Formal warning with clear consequences for continued behavior. Limited interaction with affected parties or spaces for a set period.</p> <p>3) Temporary Ban Impact: Serious or sustained violations. Consequence: Temporary ban from interaction or public communication in project spaces for a set period. No public or private interaction with affected parties or enforcers during this time.</p> <p>4) Permanent Ban Impact: Pattern of violations, harassment, or aggression toward individuals or protected classes. Consequence: Permanent ban from all public project spaces.</p>"},{"location":"code_of_conduct/#appeals","title":"Appeals","text":"<p>If you believe an action was taken in error or without sufficient context, you may appeal by replying to the original enforcement notice or emailing mousavi.bijan@gmail.com with additional information. Appeals will be reviewed by maintainers not directly involved in the original decision when possible.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct adapts the Contributor Covenant v2.1 https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines are inspired by the Mozilla Community Participation Guidelines. FAQ: https://www.contributor-covenant.org/faq \u2022 Translations: https://www.contributor-covenant.org/translations</p>"},{"location":"contributing/","title":"Contributing to <code>bijux-cli</code>","text":"<p>This doc is the single source of truth for local setup, workflows, API validation, and PR rules. If you follow this, your changes should pass CI on the first try. \ud83d\udee0\ufe0f</p>"},{"location":"contributing/#1-quick-start","title":"1) Quick Start","text":"<p>Prereqs</p> <ul> <li>Python 3.11 / 3.12 / 3.13 (<code>pyenv</code> recommended)</li> <li>GNU Make</li> <li>Node.js + npm (for API validation tooling)</li> <li>Optional: pre-commit (to catch issues before pushing)</li> </ul> <p>Setup</p> <pre><code>git clone https://github.com/bijux/bijux-cli.git\ncd bijux-cli\n\nmake PYTHON=python3.11 install\nsource .venv/bin/activate\n\n# optional but recommended\npre-commit install\n</code></pre> <p>Sanity check</p> <pre><code>make lint test docs api\n</code></pre> <ul> <li>\u2714 Pass \u2192 your env matches CI</li> <li>\u2718 Fail \u2192 jump to Troubleshooting</li> </ul>"},{"location":"contributing/#2-daily-workflow","title":"2) Daily Workflow","text":"<ul> <li>Everything runs inside .venv/</li> <li>No global installs after <code>make install</code></li> <li>Make targets mirror CI jobs 1:1</li> </ul> <p>Core targets</p> Target What it does <code>make test</code> <code>pytest</code> + coverage (HTML in <code>htmlcov/</code>) <code>make lint</code> Format (ruff), lint (ruff), type-check (mypy/pyright), complexity (radon) <code>make quality</code> Dead code (vulture), deps hygiene (deptry), REUSE, docstrings (interrogate) <code>make security</code> Bandit + pip-audit <code>make api</code> OpenAPI lint + generator compat + Schemathesis contract tests <code>make docs</code> Build MkDocs (strict) <code>make build</code> Build sdist + wheel <code>make sbom</code> CycloneDX SBOM \u2192 <code>artifacts/sbom.json</code> <code>make mutation</code> Mutation testing (Cosmic Ray + Mutmut) <p>Handy helpers</p> <pre><code>make lint-file file=path/to/file.py\nmake docs-serve          # local docs server\n# make docs-deploy       # if you have perms\n</code></pre>"},{"location":"contributing/#3-api-development","title":"3) API Development","text":"<p>Schema: <code>api/v1/schema.yaml</code> Tooling: Prance, OpenAPI Spec Validator, Redocly, OpenAPI Generator, Schemathesis</p> <p>Validate locally</p> <pre><code>.venv/bin/uvicorn bijux_cli.httpapi:app --host 0.0.0.0 --port 8000 &amp;\nmake api\n</code></pre> <p>Contract rules</p> <ul> <li>Errors use RFC 7807 Problem JSON</li> <li>Response shapes and pagination are stable or versioned</li> <li>Breaking changes require a versioned path and a changelog entry</li> </ul>"},{"location":"contributing/#4-docs","title":"4) Docs","text":"<ul> <li>Config: <code>mkdocs.yml</code> (Material, strict)</li> <li>Build: <code>make docs</code></li> <li>Serve: <code>make docs-serve</code></li> <li>Deploy: <code>make docs-deploy</code> (if authorized)</li> </ul>"},{"location":"contributing/#5-tests-coverage","title":"5) Tests &amp; Coverage","text":"<ul> <li>Run all tests: <code>make test</code></li> <li>Focused run: <code>pytest -k \"&lt;expr&gt;\" -q</code></li> <li>Coverage report: HTML in <code>htmlcov/</code>   (Project enforces a high bar; keep it green.)</li> </ul>"},{"location":"contributing/#6-style-types-hygiene","title":"6) Style, Types, Hygiene","text":"<ul> <li>Formatting: <code>ruff format</code> (enforced in <code>make lint</code>)</li> <li>Linting: <code>ruff</code></li> <li>Types: <code>mypy</code> (strict) + <code>pyright</code> (strict)</li> <li>Complexity: <code>radon</code></li> <li>Docstrings: <code>interrogate</code> (keep modules \u2265 target thresholds)</li> </ul> <p>Run them all:</p> <pre><code>make lint\n</code></pre>"},{"location":"contributing/#7-security-supply-chain","title":"7) Security &amp; Supply Chain","text":"<pre><code>make security   # bandit + pip-audit\nmake sbom       # CycloneDX, saved to artifacts/\n</code></pre> <ul> <li>No secrets in code or tests</li> <li>Keep dependency pins sane; document any suppressions</li> </ul>"},{"location":"contributing/#8-tox-envs-mirror-ci","title":"8) Tox Envs (mirror CI)","text":"Env Runs <code>py311</code> / <code>py312</code> / <code>py313</code> <code>make test</code> <code>lint</code> <code>make lint</code> <code>quality</code> <code>make quality</code> <code>security</code> <code>make security</code> <code>api</code> <code>make api</code> <code>docs</code> <code>make docs</code> <code>build</code> <code>make build</code> <code>sbom</code> <code>make sbom</code> <p>List all:</p> <pre><code>tox -av\n</code></pre>"},{"location":"contributing/#9-commits-prs","title":"9) Commits &amp; PRs","text":""},{"location":"contributing/#conventional-commits-required","title":"Conventional Commits (required)","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Types: <code>feat</code> <code>fix</code> <code>docs</code> <code>style</code> <code>refactor</code> <code>test</code> <code>chore</code></p> <p>Example</p> <pre><code>feat(plugins): add plugin scaffolding command\n</code></pre> <p>Breaking changes must include:</p> <pre><code>BREAKING CHANGE: &lt;explanation&gt;\n</code></pre> <p>Commit messages are validated (Commitizen via pre-commit hook).</p>"},{"location":"contributing/#pr-checklist","title":"PR Checklist","text":"<ol> <li> <p>Branch from <code>main</code></p> </li> <li> <p>Run:</p> </li> </ol> <pre><code>make lint test api docs\n</code></pre> <ol> <li> <p>Ensure Conventional Commits</p> </li> <li> <p>Open PR with clear summary &amp; rationale</p> </li> </ol>"},{"location":"contributing/#10-pre-commit","title":"10) Pre-Commit","text":"<pre><code>pre-commit install\n</code></pre> <p>Runs critical checks locally (format, lint, commit message validation, etc.).</p>"},{"location":"contributing/#11-troubleshooting","title":"11) Troubleshooting","text":"<ul> <li>Missing Node.js \u2192 required for API validation tools</li> <li>Docs fail \u2192 MkDocs is strict; fix broken links/includes</li> <li>pytype on Python &gt; 3.12 \u2192 skipped automatically</li> <li>Port in use for API tests \u2192 kill old <code>uvicorn</code> or use a different port</li> </ul>"},{"location":"contributing/#12-community-conduct","title":"12) Community &amp; Conduct","text":"<p>Be kind and constructive. See the Code of Conduct in the docs site. If you see something off, let us know.</p> <p>Build well. Break nothing. </p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Bijan Mousavi</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>Creative Commons Legal Code</p> <p>CC0 1.0 Universal</p> <pre><code>CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\nLEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN\nATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\nINFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\nREGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS\nPROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM\nTHE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED\nHEREUNDER.\n</code></pre> <p>Statement of Purpose</p> <p>The laws of most jurisdictions throughout the world automatically confer exclusive Copyright and Related Rights (defined below) upon the creator and subsequent owner(s) (each and all, an \"owner\") of an original work of authorship and/or a database (each, a \"Work\").</p> <p>Certain owners wish to permanently relinquish those rights to a Work for the purpose of contributing to a commons of creative, cultural and scientific works (\"Commons\") that the public can reliably and without fear of later claims of infringement build upon, modify, incorporate in other works, reuse and redistribute as freely as possible in any form whatsoever and for any purposes, including without limitation commercial purposes. These owners may contribute to the Commons to promote the ideal of a free culture and the further production of creative, cultural and scientific works, or to gain reputation or greater distribution for their Work in part through the use and efforts of others.</p> <p>For these and/or other purposes and motivations, and without any expectation of additional consideration or compensation, the person associating CC0 with a Work (the \"Affirmer\"), to the extent that he or she is an owner of Copyright and Related Rights in the Work, voluntarily elects to apply CC0 to the Work and publicly distribute the Work under its terms, with knowledge of his or her Copyright and Related Rights in the Work and the meaning and intended legal effect of CC0 on those rights.</p> <ol> <li>Copyright and Related Rights. A Work made available under CC0 may be protected by copyright and related or neighboring rights (\"Copyright and Related Rights\"). Copyright and Related Rights include, but are not limited to, the following:</li> </ol> <p>i. the right to reproduce, adapt, distribute, perform, display,      communicate, and translate a Work;  ii. moral rights retained by the original author(s) and/or performer(s); iii. publicity and privacy rights pertaining to a person's image or      likeness depicted in a Work;  iv. rights protecting against unfair competition in regards to a Work,      subject to the limitations in paragraph 4(a), below;   v. rights protecting the extraction, dissemination, use and reuse of data      in a Work;  vi. database rights (such as those arising under Directive 96/9/EC of the      European Parliament and of the Council of 11 March 1996 on the legal      protection of databases, and under any national implementation      thereof, including any amended or successor version of such      directive); and vii. other similar, equivalent or corresponding rights throughout the      world based on applicable law or treaty, and any national      implementations thereof.</p> <ol> <li> <p>Waiver. To the greatest extent permitted by, but not in contravention of, applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and unconditionally waives, abandons, and surrenders all of Affirmer's Copyright and Related Rights and associated claims and causes of action, whether now known or unknown (including existing as well as future claims and causes of action), in the Work (i) in all territories worldwide, (ii) for the maximum duration provided by applicable law or treaty (including future time extensions), (iii) in any current or future medium and for any number of copies, and (iv) for any purpose whatsoever, including without limitation commercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes the Waiver for the benefit of each member of the public at large and to the detriment of Affirmer's heirs and successors, fully intending that such Waiver shall not be subject to revocation, rescission, cancellation, termination, or any other legal or equitable action to disrupt the quiet enjoyment of the Work by the public as contemplated by Affirmer's express Statement of Purpose.</p> </li> <li> <p>Public License Fallback. Should any part of the Waiver for any reason be judged legally invalid or ineffective under applicable law, then the Waiver shall be preserved to the maximum extent permitted taking into account Affirmer's express Statement of Purpose. In addition, to the extent the Waiver is so judged Affirmer hereby grants to each affected person a royalty-free, non transferable, non sublicensable, non exclusive, irrevocable and unconditional license to exercise Affirmer's Copyright and Related Rights in the Work (i) in all territories worldwide, (ii) for the maximum duration provided by applicable law or treaty (including future time extensions), (iii) in any current or future medium and for any number of copies, and (iv) for any purpose whatsoever, including without limitation commercial, advertising or promotional purposes (the \"License\"). The License shall be deemed effective as of the date CC0 was applied by Affirmer to the Work. Should any part of the License for any reason be judged legally invalid or ineffective under applicable law, such partial invalidity or ineffectiveness shall not invalidate the remainder of the License, and in such case Affirmer hereby affirms that he or she will not (i) exercise any of his or her remaining Copyright and Related Rights in the Work or (ii) assert any associated claims and causes of action with respect to the Work, in either case contrary to Affirmer's express Statement of Purpose.</p> </li> <li> <p>Limitations and Disclaimers.</p> </li> </ol> <p>a. No trademark or patent rights held by Affirmer are waived, abandoned,     surrendered, licensed or otherwise affected by this document.  b. Affirmer offers the Work as-is and makes no representations or     warranties of any kind concerning the Work, express, implied,     statutory or otherwise, including without limitation warranties of     title, merchantability, fitness for a particular purpose, non     infringement, or the absence of latent or other defects, accuracy, or     the present or absence of errors, whether or not discoverable, all to     the greatest extent permissible under applicable law.  c. Affirmer disclaims responsibility for clearing rights of other persons     that may apply to the Work or any use thereof, including without     limitation any person's Copyright and Related Rights in the Work.     Further, Affirmer disclaims responsibility for obtaining any necessary     consents, permissions or other rights required for any use of the     Work.  d. Affirmer understands and acknowledges that Creative Commons is not a     party to this document and has no duty or obligation with respect to     this CC0 or use of the Work.</p>"},{"location":"nav/","title":"Full Navigation","text":"<ul> <li>Home</li> <li>User Guide</li> <li>API Reference<ul> <li>Api Module</li> <li>Httpapi Module</li> <li>Cli Module</li> <li>Commands<ul> <li>Audit Command</li> <li>Docs Command</li> <li>Doctor Command</li> <li>Help Command</li> <li>Repl Command</li> <li>Sleep Command</li> <li>Status Command</li> <li>Utilities Command</li> <li>Version Command</li> </ul> </li> <li>Commands/config<ul> <li>Clear Command</li> <li>Export Command</li> <li>Get Command</li> <li>List_cmd Command</li> <li>Load Command</li> <li>Reload Command</li> <li>Service Command</li> <li>Set Command</li> <li>Unset Command</li> </ul> </li> <li>Commands/dev<ul> <li>Di Command</li> <li>List_plugins Command</li> <li>Service Command</li> </ul> </li> <li>Commands/history<ul> <li>Clear Command</li> <li>Service Command</li> </ul> </li> <li>Commands/memory<ul> <li>Clear Command</li> <li>Delete Command</li> <li>Get Command</li> <li>List Command</li> <li>Service Command</li> <li>Set Command</li> <li>Utils Command</li> </ul> </li> <li>Commands/plugins<ul> <li>Check Command</li> <li>Info Command</li> <li>Install Command</li> <li>List Command</li> <li>Scaffold Command</li> <li>Uninstall Command</li> <li>Utils Command</li> </ul> </li> <li>Contracts<ul> <li>Audit Module</li> <li>Config Module</li> <li>Context Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>Emitter Module</li> <li>History Module</li> <li>Memory Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Registry Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul> </li> <li>Core<ul> <li>Constants Module</li> <li>Context Module</li> <li>Di Module</li> <li>Engine Module</li> <li>Enums Module</li> <li>Exceptions Module</li> <li>Paths Module</li> </ul> </li> <li>Infra<ul> <li>Emitter Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul> </li> <li>Services<ul> <li>Audit Module</li> <li>Config Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>History Module</li> <li>Memory Module</li> <li>Utils Module</li> </ul> </li> <li>Services/plugins<ul> <li>Entrypoints Module</li> <li>Groups Module</li> <li>Hooks Module</li> <li>Registry Module</li> </ul> </li> </ul> </li> <li>Changelog</li> <li>Architecture Decision Records<ul> <li>Overview</li> <li>ADR 0002: Global Flags Precedence</li> <li>ADR 0003: Docstring And Documentation Style</li> <li>ADR 0004: Linting Quality Security</li> </ul> </li> </ul>"},{"location":"security/","title":"Security Policy","text":"<p>Last updated: 2025-08-10</p> <p>We take security seriously and follow Coordinated Vulnerability Disclosure (CVD). Please report vulnerabilities privately and give us reasonable time to remediate before any public disclosure.</p>"},{"location":"security/#supported-versions","title":"Supported Versions","text":"<p>We patch the latest minor line only.</p> Version Supported <code>0.1.x</code> Yes <code>&lt;0.1.0</code> No <p>When <code>0.2.0</code> is released, <code>0.1.x</code> becomes unsupported. We do not backport beyond the latest minor line.</p>"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please report privately:</p> <ul> <li>Preferred: GitHub Private Vulnerability Report https://github.com/bijux/bijux-cli/security/advisories/new</li> <li>Fallback: Email mousavi.bijan@gmail.com with subject   <code>[SECURITY] Vulnerability report: bijux-cli</code></li> </ul>"},{"location":"security/#what-to-include-to-speed-up-triage","title":"What to include (to speed up triage)","text":"<ul> <li>Affected version(s) and environment (OS, Python, install method)</li> <li>Impact and clear reproduction steps</li> <li>Minimal Proof-of-Concept (PoC), if available</li> <li>Any suggested mitigations/workarounds</li> <li>Whether you wish to be credited by name/handle</li> </ul> <p>Please do not include secrets or sensitive data in reports. If you accidentally encounter any, stop testing and report immediately.</p>"},{"location":"security/#our-process-slas-best-effort","title":"Our Process &amp; SLAs (Best Effort)","text":"<ul> <li>Acknowledgement: within 48 hours</li> <li>Initial assessment &amp; provisional CVSS: within 5 business days</li> <li> <p>Target fix window (severity by CVSS v3.x):</p> </li> <li> <p>Critical: 7 days</p> </li> <li>High: 30 days</li> <li>Medium: 90 days</li> <li>Low: 180 days</li> </ul> <p>We will publish a GitHub Security Advisory with details after a fix is available, and request a CVE when appropriate. Reporter credit is given with your consent.</p>"},{"location":"security/#safe-harbor-good-faith-research","title":"Safe Harbor (Good-Faith Research)","text":"<p>We will not pursue or support legal action for good-faith security research that:</p> <ul> <li>Avoids privacy violations, data exfiltration, and service interruption.</li> <li>Limits testing to accounts/environments you control.</li> <li>Respects rate limits; no volumetric DoS or spam.</li> <li>Does not exploit beyond what\u2019s necessary to demonstrate impact.</li> <li>Stops and reports immediately upon encountering sensitive data.</li> </ul> <p>If you\u2019re unsure whether an activity is in scope of safe harbor, ask first via the channels above.</p>"},{"location":"security/#scope","title":"Scope","text":"<p>In scope</p> <ul> <li>This repository\u2019s source code</li> <li>Release artifacts we publish</li> <li>CLI runtime behavior and default configurations</li> </ul> <p>Out of scope</p> <ul> <li>Social engineering or physical attacks</li> <li>Third-party platforms and services (unless our integration directly introduces the issue)</li> <li>Volumetric DoS (traffic floods, stress/benchmarking)</li> <li>Issues requiring pre-existing privileged local access without a viable escalation path</li> <li>Vulnerabilities in third-party plugins not maintained in this org</li> </ul> <p>If you find a dependency vulnerability: report it to the upstream project as well. We\u2019ll track, pin/upgrade, or mitigate on our side as needed.</p>"},{"location":"security/#proactive-security-practices","title":"Proactive Security Practices","text":"<ul> <li>Dependency auditing: <code>pip-audit</code> with CycloneDX SBOM (<code>artifacts/sbom.json</code>)</li> <li>Static analysis: <code>bandit</code> on Python sources</li> <li>Policy gates: CI blocks on failed security checks; any ignores are reviewed and documented</li> <li>Supply chain: pinned tooling where feasible; reproducible builds where practical; SBOM generated on release</li> </ul> <p>(We do not run a bounty program at this time.)</p>"},{"location":"security/#contact","title":"Contact","text":"<ul> <li>Private report: https://github.com/bijux/bijux-cli/security/advisories/new</li> <li>Email: mousavi.bijan@gmail.com</li> <li>Non-security questions: please open a normal GitHub issue.</li> </ul> <p>Thank you for helping keep Bijux CLI users safe.</p>"},{"location":"usage/","title":"Bijux CLI \u2014 User Guide","text":"<p>A concise, production-ready reference for commands, global flags, configuration, and operational behavior.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>Requires: Python 3.11+</p>"},{"location":"usage/#using-pip","title":"Using pip","text":"<pre><code>python -m pip install -U bijux-cli\n</code></pre>"},{"location":"usage/#using-pipx-recommended-for-isolation","title":"Using pipx (recommended for isolation)","text":"<pre><code>pipx install bijux-cli\n# later\npipx upgrade bijux-cli\n# first-time pipx users:\npipx ensurepath\n</code></pre>"},{"location":"usage/#quick-start","title":"Quick Start","text":"<pre><code># See all commands and global flags\nbijux --help\n\n# Version / sanity check\nbijux --version\n\n# Environment health check\nbijux doctor\n\n# Launch interactive REPL\nbijux\nbijux&gt; help\nbijux&gt; exit\n</code></pre>"},{"location":"usage/#shell-completion","title":"Shell Completion","text":"<p>Enable tab-completion (no sudo required).</p> <pre><code># Install completion for your shell\nbijux --install-completion\n\n# Or print the script (for manual setup)\nbijux --show-completion\n</code></pre> <p>One-liners by shell</p> <ul> <li>Bash (current session)</li> </ul> <pre><code>eval \"$(bijux --show-completion)\"\n</code></pre> <ul> <li>Zsh (persist)</li> </ul> <pre><code>echo 'fpath+=(\"$HOME/.zfunc\")' &gt;&gt; ~/.zshrc\necho 'autoload -U compinit &amp;&amp; compinit' &gt;&gt; ~/.zshrc\nbijux --install-completion\n</code></pre> <ul> <li>Fish</li> </ul> <pre><code>bijux --install-completion\n</code></pre> <ul> <li>PowerShell</li> </ul> <pre><code>bijux --install-completion\n</code></pre> <p>After installing, restart your shell. For zsh, ensure <code>compinit</code> runs and your <code>fpath</code> includes completions directory.</p>"},{"location":"usage/#global-flags-precedence-rules","title":"Global Flags \u2014 Precedence Rules","text":"<p>Flags apply to every command and are evaluated in strict priority order. Higher-priority flags override or short-circuit lower ones.</p> Priority Flag(s) Behavior 1 <code>-h</code>, <code>--help</code> Exit with code <code>0</code> immediately; ignore all other flags. 2 <code>-q</code>, <code>--quiet</code> Suppress both stdout and stderr; exit code still reflects the result. 3 <code>-d</code>, <code>--debug</code> Full diagnostics; implies <code>--verbose</code> and forces <code>--pretty</code>. 4 <code>-f, --format &lt;json\\|yaml&gt;</code> Structured output format; invalid value \u2192 exit code <code>2</code>. 5 <code>--pretty</code> / <code>--no-pretty</code> Control indentation (default: <code>--pretty</code>). 6 <code>-v</code>, <code>--verbose</code> Add runtime metadata; implied by <code>--debug</code>. <p>For details, see ADR-0002: Global Flags Precedence.</p> <p>Notes</p> <ul> <li>When <code>--format</code> is set, errors are emitted in that format to stderr (unless <code>--quiet</code>).</li> <li><code>--debug</code> implies <code>--verbose</code> and forces pretty printing.</li> </ul>"},{"location":"usage/#command-reference","title":"Command Reference","text":""},{"location":"usage/#config-manage-cli-configuration","title":"<code>config</code> \u2014 Manage CLI Configuration","text":"<p>Key-value settings stored in a dotenv-style file. Keys must use alphanumeric characters and underscores only (no dots).</p> <ul> <li>list \u2014 <code>{\"items\":[{\"key\":\"...\"}, ...]}</code></li> </ul> <pre><code>bijux config list\n</code></pre> <ul> <li>get \\ \u2014 <code>{\"value\":\"...\"}</code> <pre><code>bijux config get core_timeout\n</code></pre> <ul> <li>set \\ <pre><code>bijux config set core_timeout=30\n</code></pre> <ul> <li>unset \\ <pre><code>bijux config unset core_timeout\n</code></pre> <ul> <li>export \\ (supports <code>--format json|yaml</code>) <pre><code>bijux config export ./settings.env\nbijux config export ./settings.json --format json\n</code></pre> <ul> <li>load \\ (dotenv format) <pre><code>bijux config load ./settings.env\n</code></pre> <ul> <li>reload</li> </ul> <pre><code>bijux config reload\n</code></pre> <ul> <li>clear</li> </ul> <pre><code>bijux config clear\n</code></pre> <p>Tip: machine-friendly output <code>bijux config list --format json --no-pretty</code></p>"},{"location":"usage/#plugins-manage-plugins","title":"<code>plugins</code> \u2014 Manage Plugins","text":"<p>Default install directory: <code>~/.bijux/.plugins</code> (override via <code>BIJUXCLI_PLUGINS_DIR</code>).</p> <ul> <li>list \u2014 <code>{\"plugins\":[\"...\", ...]}</code></li> </ul> <pre><code>bijux plugins list\n</code></pre> <ul> <li>info \\ <pre><code>bijux plugins info my_plugin\nbijux plugins info ./path/to/my_plugin\n</code></pre> <ul> <li>install \\ (infers name from basename; use <code>--force</code> to overwrite) <pre><code>bijux plugins install ./path/to/my_plugin --force\n</code></pre> <ul> <li>check \\ <pre><code>bijux plugins check my_plugin\nbijux plugins check ./path/to/my_plugin\n</code></pre> <ul> <li>uninstall \\ <pre><code>bijux plugins uninstall my_plugin\n</code></pre> <ul> <li>scaffold \\ (outputs to current dir; <code>--force</code> to overwrite) <pre><code>mkdir -p ./temp_scaffold\ncd ./temp_scaffold\nbijux plugins scaffold my_plugin --template=../plugin_template --force\ncd ..\nbijux plugins install ./temp_scaffold/my_plugin --force\n</code></pre>"},{"location":"usage/#history-manage-repl-history","title":"<code>history</code> \u2014 Manage REPL History","text":"<ul> <li>list (supports <code>--limit &lt;n&gt;</code>, <code>--group-by &lt;field&gt;</code>, <code>--filter &lt;str&gt;</code>, <code>--sort &lt;field&gt;</code>)   Output shape: <code>{\"entries\":[ ... ]}</code></li> </ul> <pre><code>bijux history --limit 10\n</code></pre> <ul> <li>--export \\ <pre><code>bijux history --export ./history.json\n</code></pre> <ul> <li>--import \\ <pre><code>bijux history --import ./history.json\n</code></pre> <ul> <li>clear</li> </ul> <pre><code>bijux history clear\n</code></pre>"},{"location":"usage/#dev-developer-tools","title":"<code>dev</code> \u2014 Developer Tools","text":"<ul> <li>di \u2014 Dependency injection inventory   Output shape: <code>{\"factories\":[...], \"services\":[...]}</code></li> </ul> <pre><code>bijux dev di\n</code></pre> <ul> <li>list-plugins</li> </ul> <pre><code>bijux dev list-plugins\n</code></pre>"},{"location":"usage/#built-in-commands","title":"Built-in Commands","text":"Command Purpose Example <code>audit</code> Security/compliance audit <code>bijux audit --dry-run</code> <code>docs</code> Generate API docs/specs <code>bijux docs --out spec.json</code> <code>doctor</code> Environment health check <code>bijux doctor</code> <code>memory</code> In-memory key-value store <code>bijux memory set key=val</code> <code>repl</code> Interactive shell <code>bijux repl</code> <code>sleep</code> Pause execution <code>bijux sleep -s 5</code> <code>status</code> CLI status snapshot <code>bijux status</code> <code>version</code> Display version info <code>bijux version</code> <p>Installed plugins appear as top-level commands (e.g., <code>my_plugin</code>).</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Default Paths (overridable via env vars):</p> <ul> <li>Config: <code>~/.bijux/.env</code> (<code>BIJUXCLI_CONFIG</code>)</li> <li>History: <code>~/.bijux/.history</code> (<code>BIJUXCLI_HISTORY_FILE</code>)</li> <li>Plugins: <code>~/.bijux/.plugins</code> (<code>BIJUXCLI_PLUGINS_DIR</code>)</li> </ul> <p>To customize (e.g., plugins dir), add to your shell profile:</p> <pre><code>export BIJUXCLI_PLUGINS_DIR=~/custom_plugins\n</code></pre> <p>Resolution Precedence</p> <p>1) CLI flags \u2192 2) Environment variables \u2192 3) Config file \u2192 4) Defaults</p>"},{"location":"usage/#end-to-end-examples","title":"End-to-End Examples","text":""},{"location":"usage/#using-default-paths","title":"Using Default Paths","text":"<pre><code># Clean up (optional)\nbijux plugins uninstall my_plugin || true\nrm -rf ./temp_scaffold ./usage_test_artifacts\nmkdir -p ./usage_test_artifacts\n\n# Scaffold and install\nmkdir -p ./temp_scaffold\ncd ./temp_scaffold\nbijux plugins scaffold my_plugin --template=../plugin_template --force\ncd ..\nbijux plugins install ./temp_scaffold/my_plugin --force\n\n# Verify\nbijux plugins list\nbijux plugins info my_plugin\nbijux plugins check my_plugin\n\n# Config\nbijux config set core_timeout=30\nbijux config get core_timeout\nbijux config list\n\n# Export config\nbijux config export ./usage_test_artifacts/settings.env\nbijux config export ./usage_test_artifacts/settings.json --format json\n\n# History via REPL\nbijux repl &lt;&lt;'EOF'\nversion\nhelp\nexit\nEOF\n\n# History ops\nbijux history --limit 10\nbijux history --export ./usage_test_artifacts/history.json\nbijux history --import ./usage_test_artifacts/history.json\n\n# Cleanup\nbijux history clear\nbijux config clear\nbijux plugins uninstall my_plugin\nrm -rf ./temp_scaffold\n\n# Confirm\nbijux plugins list\n</code></pre>"},{"location":"usage/#using-local-paths","title":"Using Local Paths","text":"<pre><code># Clean up\nrm -rf ./usage_test ./temp_scaffold\nmkdir -p ./usage_test/plugins ./usage_test_artifacts\n\n# Overrides\nexport BIJUXCLI_PLUGINS_DIR=./usage_test/plugins\nexport BIJUXCLI_CONFIG=./usage_test_artifacts/.env\nexport BIJUXCLI_HISTORY_FILE=./usage_test_artifacts/.history\n\n# Scaffold and install\nmkdir -p ./temp_scaffold\ncd ./temp_scaffold\nbijux plugins scaffold my_plugin --template=../plugin_template --force\ncd ..\nbijux plugins install ./temp_scaffold/my_plugin --force\n\n# Verify\nbijux plugins list\nbijux plugins info my_plugin\nbijux plugins check my_plugin\n\n# Config\nbijux config set core_timeout=30\nbijux config get core_timeout\nbijux config list\n\n# Export config\nbijux config export ./usage_test_artifacts/settings.env\nbijux config export ./usage_test_artifacts/settings.json --format json\n\n# History via REPL\nbijux repl &lt;&lt;'EOF'\nversion\nhelp\nexit\nEOF\n\n# History ops\nbijux history --limit 10\nbijux history --export ./usage_test_artifacts/history.json\nbijux history --import ./usage_test_artifacts/history.json\n\n# Cleanup\nbijux history clear\nbijux config clear\nbijux plugins uninstall my_plugin\nrm -rf ./temp_scaffold\n\n# Confirm\nbijux plugins list\n\n# Reset overrides (optional)\nunset BIJUXCLI_PLUGINS_DIR\nunset BIJUXCLI_CONFIG\nunset BIJUXCLI_HISTORY_FILE\n</code></pre>"},{"location":"usage/#error-model-structured","title":"Error Model (Structured)","text":"<p>When <code>--format</code> is set, errors are structured and emitted to stderr (unless <code>--quiet</code>):</p> <pre><code>{\n  \"error\": \"message\",\n  \"code\": 2,\n  \"failure\": \"machine_readable_reason\",\n  \"command\": \"subcommand path\",\n  \"fmt\": \"json|yaml\"\n}\n</code></pre>"},{"location":"usage/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> General/internal error <code>2</code> Usage/invalid argument <code>3</code> Encoding/hygiene error <p>Commands may extend with non-conflicting codes.</p>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Diagnostics: <code>bijux doctor</code></li> <li>Verbosity: add <code>--verbose</code> or <code>--debug</code></li> <li>Logs: check stderr in <code>--debug</code> mode</li> <li>Issues: include <code>--debug</code> output when reporting bugs</li> </ul>"},{"location":"ADR/","title":"Architecture Decision Records Overview","text":"<p>This section lists all ADRs.</p>"},{"location":"ADR/#adrs","title":"ADRs","text":"<ul> <li>ADR 0002: Global Flags Precedence</li> <li>ADR 0003: Docstring And Documentation Style</li> <li>ADR 0004: Linting Quality Security</li> </ul>"},{"location":"ADR/0002-global-flags-precedence/","title":"ADR 0002: Global Flag Precedence Contract","text":"<ul> <li>Date: 2025\u201108\u201101</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0002-global-flags-precedence/#context","title":"Context","text":"<p>Our Bijux CLI requires a deterministic and testable handling of global flags (<code>--help</code>, <code>--quiet</code>, <code>--debug</code>, <code>--format</code>, <code>--pretty</code>/<code>--no-pretty</code>, <code>--verbose</code>) across all commands to ensure consistency. This prevents ambiguous behaviors in hypothesis-driven fuzz tests, provides a clear \"short-circuit\" model for scripting and human users, and maintains synchronization between documentation, ADRs, and implementations. Without a formal contract, variations in flag-resolution rules could lead to edge cases and debugging challenges.</p>"},{"location":"ADR/0002-global-flags-precedence/#decision","title":"Decision","text":"<p>All Bijux CLI commands must enforce global flags in the following strict precedence order, with exact semantics applied uniformly:</p> <ol> <li>Help (<code>-h</code> / <code>--help</code>)</li> <li>Short-circuits all other processing.</li> <li>Immediately prints usage information and exits with code 0.</li> <li> <p>Skips validation or processing of any other flags or arguments.</p> </li> <li> <p>Quiet (<code>-q</code> / <code>--quiet</code>)</p> </li> <li>Applies only if help is absent.</li> <li>Suppresses all normal output on stdout and stderr.</li> <li>Still performs full validation of flags and arguments, exiting with 0 on success or non-zero on errors.</li> <li> <p>Overrides debug, format, pretty/no-pretty, and verbose for output suppression, but not for exit codes.</p> </li> <li> <p>Debug (<code>--debug</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Emits diagnostics and full trace information to stderr.</li> <li>Implicitly enables verbose output (e.g., runtime metadata).</li> <li> <p>Forces <code>--pretty</code> formatting, overriding any <code>--no-pretty</code>.</p> </li> <li> <p>Format (<code>-f &lt;fmt&gt;</code> / <code>--format &lt;fmt&gt;</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Requires a valid format name (<code>json</code> or <code>yaml</code>, case-insensitive).</li> <li> <p>Invalid or missing value triggers a structured error payload and exit code 2.</p> </li> <li> <p>Pretty / No-Pretty (<code>--pretty</code> / <code>--no-pretty</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Controls indentation for human-readable structured output.</li> <li>Defaults to <code>--pretty</code> if neither is specified.</li> <li> <p>Overridden by debug, which always enforces pretty formatting.</p> </li> <li> <p>Verbose (<code>-v</code> / <code>--verbose</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Appends runtime metadata (e.g., Python version, platform) to structured output.</li> <li>No-op under quiet; implied by debug.</li> </ol>"},{"location":"ADR/0002-global-flags-precedence/#error-handling-rules","title":"Error-Handling Rules","text":"<ul> <li>Under help, always exit 0 with usage displayed, ignoring any invalid flags or arguments.</li> <li>Under quiet, suppress both stdout and stderr and return only an exit code (no JSON/YAML payload).</li> <li>Standard exit codes apply otherwise:</li> <li><code>0</code>: Success</li> <li><code>1</code>: Internal/fatal errors</li> <li><code>2</code>: Bad CLI usage (missing/invalid flags or arguments)</li> <li><code>3</code>: ASCII/encoding hygiene failures</li> <li>Every error payload (JSON or YAML) must include:</li> <li><code>\"error\"</code>: Human-readable message</li> <li><code>\"code\"</code>: Numeric exit code</li> </ul>"},{"location":"ADR/0002-global-flags-precedence/#consequences","title":"Consequences","text":""},{"location":"ADR/0002-global-flags-precedence/#pros","title":"Pros","text":"<ul> <li>Ensures deterministic behavior, eliminating flakiness in fuzz tests and user interactions.</li> <li>Provides a single source of truth for flag handling, simplifying documentation and maintenance.</li> <li>Enhances testability by allowing assertions on specific argv patterns (e.g., <code>-h</code> always yields usage and exit 0).</li> </ul>"},{"location":"ADR/0002-global-flags-precedence/#cons","title":"Cons","text":"<ul> <li>Requires each command's entrypoint to inspect <code>sys.argv</code> (or Typer/Click context) before parsing, adding initial implementation overhead.</li> <li>Contributors unfamiliar with the precedence must adapt, with no flexibility for command-specific variations.</li> </ul>"},{"location":"ADR/0002-global-flags-precedence/#enforcement","title":"Enforcement","text":"<ul> <li>No command implementation or pull request is accepted unless it fully adheres to this precedence contract.</li> <li>CI pipelines and reviewers must verify compliance through tests, rejecting any deviations in flag handling or semantics.</li> <li>This policy is binding and non-negotiable to maintain CLI consistency.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/","title":"ADR 0003: Docstring and Documentation Style","text":"<ul> <li>Date: 2025\u201108\u201101</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/#context","title":"Context","text":"<p>Our codebase demands a rigorously consistent and machine-parsable documentation style to facilitate the seamless, automated generation of comprehensive and visually appealing webpages through MkDocs. This process depends entirely on full, detailed docstrings placed at the top of every Python file, which must thoroughly explain the complete contents of that file. User-facing documentation\u2014encompassing guides, ADRs, and READMEs\u2014must remain highly readable in plain text while rendering flawlessly on the web. By utilizing tools like MkDocs for rendering and linters for validation, we enable all contributors to produce and sustain uniformly high-quality documentation, with absolutely no exceptions permitted.</p>"},{"location":"ADR/0003-docstring-and-documentation-style/#decision","title":"Decision","text":""},{"location":"ADR/0003-docstring-and-documentation-style/#docstrings","title":"Docstrings","text":"<p>We enforce the exclusive use of the Google Python Style Guide for all in-code docstrings throughout the codebase, prohibiting any deviations or mixed styles to guarantee absolute unification and automated enforcement.</p> <ul> <li>Every Python file must commence with a comprehensive module-level docstring enclosed in triple quotes <code>\"\"\"\u2026\"\"\"</code>, beginning with a concise one-sentence summary on the initial line.</li> <li>After the summary, insert a blank line followed by an exhaustive description of the file's entire code, covering its overall purpose, architectural structure, primary components, interdependencies, and pertinent usage guidelines. This docstring must be fully self-explanatory, eschewing abbreviated or partial content.</li> <li> <p>Include the following sections in precise order, omitting only those that are wholly inapplicable:</p> <ol> <li>Args: <pre><code> Args:\n     name (str): Description of the argument.\n     count (int): Description of the argument.\n</code></pre></li> <li>Returns: <pre><code>Returns:\n    bool: Description of the return value.\n</code></pre></li> <li>Raises: <pre><code>Raises:\n    ValueError: Description of when and why the exception is raised.\n</code></pre></li> </ol> </li> <li> <p>In docstrings, employ <code>*</code> exclusively for any bullet points or lists (such as in descriptions or output contracts) to ensure proper line-separated display in MkDocs-generated webpages. Example:   <pre><code>Output Contract:\n    * Success: {\"version\": str, \"timestamp\": float}\n    * Verbose: {\"python\": str, \"platform\": str}\n    * Error: {\"error\": str, \"code\": int}\n</code></pre></p> </li> <li>Avoid <code>-</code> or alternative markers that could lead to rendering inconsistencies.</li> <li>Extend full Google-style docstrings to every class, function, and method, with each providing a thorough account of its functionality and integration within the file.</li> <li>Prohibit the use of <code>&lt;module&gt;</code>, <code>:param:</code>, reST directives, or any non-Google elements\u2014strict adherence to Google format is required.</li> <li>Mandate enforcement through tools like <code>pydocstyle</code> set to the \"google\" convention, embedded in CI/CD workflows to automatically block non-conforming submissions.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/#repository-documentation","title":"Repository Documentation","text":"<ul> <li>Store all ADRs in <code>docs/ADR/</code> with filenames formatted as <code>XXXX-&lt;short-title&gt;.md</code>, where <code>XXXX</code> represents a zero-padded integer.</li> <li>Restrict all repository documentation (ADRs, READMEs, guides) to Markdown format only.</li> <li>Prefer <code>*</code> for Markdown bullet points. <code>-</code> is also acceptable to match GitHub/MkDocs defaults.</li> <li>Mandate inclusion of Date, Status, and Author headers in ADRs, as exemplified in this document.</li> <li>Set up MkDocs to draw from <code>docs/</code> as the primary source directory for automated website publication.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/#consequences","title":"Consequences","text":""},{"location":"ADR/0003-docstring-and-documentation-style/#pros","title":"Pros","text":"<ul> <li>Delivers a uniformly professional codebase with reliable introspection and automated API reference generation.</li> <li>Ensures out-of-the-box compatibility with tools like MkDocs for superior documentation websites.</li> <li>Provides contributors with unambiguous, enforceable guidelines, streamlining reviews through automation and objectivity.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/#cons","title":"Cons","text":"<ul> <li>Incurs upfront costs for refactoring existing non-compliant files.</li> <li>Necessitates adaptation for contributors unaccustomed to Google style or rigorous linting protocols.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style/#enforcement","title":"Enforcement","text":"<ul> <li>Prohibit acceptance of any code or documentation pull request that fails to comply fully with this ADR.</li> <li>Empower reviewers and CI systems to reject submissions outright for issues such as absent module-level docstrings, incomplete explanations, stylistic inconsistencies, or improper bullet formatting.</li> <li>Establish this policy as irrevocably binding, with no provisions for negotiation or exceptions.</li> </ul>"},{"location":"ADR/0004-linting-quality-security/","title":"ADR 0004: Linting, Quality, and Security Toolchain","text":"<ul> <li>Date: 2025-08-01</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0004-linting-quality-security/#context","title":"Context","text":"<p>We need a single, reproducible pipeline for code style, formatting, type-safety, complexity, documentation coverage, dead code, dependency hygiene, license compliance, and security checks \u2014 identical locally and in CI. Developers should be able to run:</p> <pre><code>make lint\nmake quality\nmake security\n</code></pre> <p>and get the same results everywhere.</p> <p>We standardized on the following tools:</p> <ul> <li>Ruff for formatting, import sorting, and linting (with auto-fix where safe).</li> <li>Mypy and Pytype for static typing (Pytype runs where supported).</li> <li>Pyright for fast type checks (editor/CI parity).</li> <li>Pydocstyle (Google convention) for docstring style.</li> <li>Interrogate for documentation coverage.</li> <li>Radon for cyclomatic complexity.</li> <li>Vulture for dead code detection.</li> <li>Deptry for unused/incorrect dependencies.</li> <li>REUSE for SPDX license header compliance.</li> <li>Bandit for security static analysis.</li> <li>pip-audit for dependency vulnerability audits.</li> </ul> <p>All configuration lives under <code>config/</code> (with a few root files like <code>REUSE.toml</code>), ensuring CI/local parity.</p>"},{"location":"ADR/0004-linting-quality-security/#decision","title":"Decision","text":""},{"location":"ADR/0004-linting-quality-security/#makefile-targets","title":"Makefile Targets","text":"<p>We enforce Makefile targets to run the full toolchain consistently.</p> Lint (<code>Makefile</code>) <pre><code># Lint Configuration\n\n\nINTERROGATE_PATHS ?= src/bijux_cli\n\nRUFF        := $(ACT)/ruff\nMYPY        := $(ACT)/mypy\nPYTYPE      := $(ACT)/pytype\nCODESPELL   := $(ACT)/codespell\nPYRIGHT     := $(ACT)/pyright\nPYDOCSTYLE  := $(ACT)/pydocstyle\nRADON       := $(ACT)/radon\nINTERROGATE := $(ACT)/interrogate\n\n.PHONY: lint lint-file lint-dir interrogate-report\n\nlint:\n    @echo \"\u2192 Running all linting checks\"\n    @$(MAKE) lint-dir dir=src/bijux_cli\n    @$(MAKE) lint-dir dir=tests\n    @echo \"\u2714 Linting completed successfully\"\n\nlint-file:\nifndef file\n    $(error Usage: make lint-file file=path/to/file.py)\nendif\n    @$(call run_tool,RuffFormat,$(RUFF) format)\n    @$(call run_tool,Ruff,$(RUFF) check --fix --config config/ruff.toml)\n    @$(call run_tool,Mypy,$(MYPY) --config-file config/mypy.ini --strict)\n    @$(call run_tool,Codespell,$(CODESPELL) -I config/bijux.dic)\n    @$(call run_tool,Pyright,$(PYRIGHT) --project config/pyrightconfig.json)\n    @$(call run_tool,Radon,$(RADON) cc -s -a)\n    @$(call run_tool,Pydocstyle,$(PYDOCSTYLE) --convention=google)\n\nlint-dir:\nifndef dir\n    $(error Usage: make lint-dir dir=&lt;directory_path&gt;)\nendif\n    @echo \"=== Linting directory '$(dir)' ===\"\n    @for file in $$(find $(dir) -type f -name '*.py'); do \\\n        $(MAKE) lint-file file=$$file; \\\n    done\n    @if $(VENV_PYTHON) -c 'import sys; sys.exit(0) if sys.version_info &gt;= (3, 13) else sys.exit(1)'; then \\\n        echo \"\u2192 Skipping Pytype (unsupported on Python &gt; 3.12)\"; \\\n    else \\\n        $(call run_tool,Pytype,$(PYTYPE) --disable import-error); \\\n    fi\n\ninterrogate-report:\n    @echo \"\u2192 Generating docstring coverage report (&lt;100%)\"\n    @set +e; \\\n      OUT=\"$$( $(INTERROGATE) --no-color --verbose $(INTERROGATE_PATHS) )\"; \\\n      rc=$$?; \\\n      OFF=\"$$(printf '%s\\n' \"$$OUT\" | awk -F'|' 'NR&gt;3 &amp;&amp; $$0 ~ /^\\|/ { \\\n        name=$$2; cov=$$6; gsub(/^[ \\t]+|[ \\t]+$$/, \"\", name); gsub(/^[ \\t]+|[ \\t]+$$/, \"\", cov); \\\n        if (name !~ /^-+$$/ &amp;&amp; cov != \"100%\") printf(\"  - %s (%s)\\n\", name, cov); \\\n      }')\"; \\\n      if [ -n \"$$OFF\" ]; then printf \"%s\\n\" \"$$OFF\"; else echo \"\u2714 All files 100% documented\"; fi; \\\n      exit $$rc\n\n##@ Lint\nlint: ## Run all lint checks (ruff, mypy, pyright, codespell, radon, pydocstyle)\nlint-file: ## Lint a single Python file (requires file=&lt;path&gt;)\nlint-dir: ## Lint all Python files in a directory (requires dir=&lt;path&gt;)\ninterrogate-report: ## Generate docstring coverage report for files &lt;100%\n</code></pre> Quality (<code>Makefile</code>) <pre><code># Quality Configuration\n\nQUALITY_PATHS ?= src/bijux_cli\nVULTURE       := $(ACT)/vulture\nDEPTRY        := $(ACT)/deptry\nREUSE         := $(ACT)/reuse\nINTERROGATE   := $(ACT)/interrogate\n\n.PHONY: quality\n\nquality:\n    @echo \"\u2192 Running quality checks...\"\n    @echo \"   - Dead code analysis (Vulture)\"\n    @$(VULTURE) $(QUALITY_PATHS) --min-confidence 80\n    @echo \"   - Dependency hygiene (Deptry)\"\n    @$(DEPTRY) $(QUALITY_PATHS)\n    @echo \"   - License &amp; SPDX compliance (REUSE)\"\n    @$(REUSE) lint\n    @echo \"   - Documentation coverage (Interrogate)\"\n    @$(MAKE) interrogate-report\n    @echo \"\u2714 Quality checks passed\"\n\n##@ Quality\nquality: ## Run all quality checks: Vulture (dead code), Deptry (deps), REUSE (SPDX), Interrogate (docs)\n</code></pre> Security (<code>Makefile</code>) <pre><code># Security Configuration\n\nSECURITY_PATHS   ?= src/bijux_cli\nBANDIT           := $(ACT)/bandit\nPIP_AUDIT        := $(ACT)/pip-audit\nSBOM_IGNORE      ?= PYSEC-2022-42969\n\n.PHONY: security\n\nsecurity:\n    @echo \"\u2192 Bandit (Python static analysis)\" &amp;&amp; $(BANDIT) -r $(SECURITY_PATHS)\n    @echo \"\u2192 Pip-audit (dependency vulnerability scan)\" &amp;&amp; \\\n      $(PIP_AUDIT) $(foreach V,$(SBOM_IGNORE),--ignore-vuln $(V))\n\n##@ Security\nsecurity: ## Run Bandit and pip-audit with optional vulnerability ignores\n</code></pre> <p>This setup supports whole-project runs as well as per-directory/per-file runs, with reasonable exclusions for generated or template content.</p>"},{"location":"ADR/0004-linting-quality-security/#tool-configurations","title":"Tool Configurations","text":"<p>The toolchain is driven by unified configs:</p> Ruff (<code>config/ruff.toml</code>) <pre><code>target-version = \"py311\"\nline-length = 88\nrespect-gitignore = true\nsrc = [\"src\", \"tests\"]\n\nexclude = [\n  \".git\", \".hg\", \".mypy_cache\", \".pytest_cache\", \".ruff_cache\", \".tox\", \".venv\",\n  \"build\", \"dist\", \"docs\", \"htmlcov\", \"__pycache__\", \"migrations\", \"*.egg-info\"\n]\n\n[lint]\nselect = [\n  \"E\",\"F\",\"I\",\"B\",\"UP\",\"SIM\",\"PT\",\"N\",\"A\",\"C4\",\"S\",\"TID\",\"PERF\",\n  # TODO: Fix - \"RUF\",\"ARG\",\"TRY\",\"T20\",\"BLE\",\"ERA\"\n]\nignore = [\"E501\", \"E203\"]\n\n[lint.per-file-ignores]\n\"tests/**\" = [\"S101\"]\n\"__init__.py\" = [\"F401\"]\n\n[lint.isort]\nforce-sort-within-sections = true\nknown-first-party = [\"bijux_cli\"]\nrequired-imports = [\"from __future__ import annotations\"]\n\n[lint.flake8-tidy-imports]\nban-relative-imports = \"parents\"\n\n[lint.mccabe]\nmax-complexity = 10\n</code></pre> Mypy (<code>config/mypy.ini</code>) <pre><code>[mypy]\npython_version = 3.11\nstrict = true\n\nshow_error_codes = true\npretty = true\nwarn_unreachable = true\nwarn_unused_configs = true\nwarn_unused_ignores = true\nfollow_imports = silent\n\nmypy_path = src\nfiles = src, tests\n\nexclude = ^(\\.venv|build|dist|docs|htmlcov|\\.mypy_cache|\\.pytest_cache|\\.ruff_cache|\\.tox|__pycache__|migrations|\\.egg-info|node_modules)/\n\nplugins = pydantic.mypy\n\n[mypy-cookiecutter.*]\nignore_missing_imports = true\n\n[mypy-bijux_cli.core.di]\ndisable_error_code = type-abstract\n\n[pydantic-mypy]\ninit_typed = true\nwarn_required_dynamic_aliases = true\nwarn_untyped_fields = true\n</code></pre> Pyright (<code>config/pyrightconfig.json</code>) <pre><code>{\n  \"include\": [\n    \"src\",\n    \"tests\"\n  ],\n  \"exclude\": [\n    \".venv\",\n    \"build\",\n    \"dist\",\n    \"htmlcov\",\n    \".pytest_cache\",\n    \".mypy_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".tox\",\n    \"**/__pycache__\",\n    \"node_modules\"\n  ],\n  \"pythonVersion\": \"3.11\",\n  \"typeCheckingMode\": \"strict\",\n  \"useLibraryCodeForTypes\": true,\n  \"reportMissingImports\": \"warning\",\n  \"reportMissingTypeStubs\": \"none\",\n  \"reportUnusedImport\": \"error\",\n  \"reportPrivateUsage\": \"warning\",\n  \"reportUnnecessaryTypeIgnoreComment\": \"warning\",\n  \"reportUnnecessaryCast\": \"warning\",\n  \"reportUnnecessaryIsInstance\": \"warning\",\n  \"reportOptionalSubscript\": \"error\",\n  \"reportOptionalMemberAccess\": \"error\",\n  \"reportOptionalCall\": \"error\",\n  \"reportOptionalIterable\": \"error\",\n  \"reportOptionalContextManager\": \"error\",\n  \"reportOptionalOperand\": \"error\",\n  \"reportGeneralTypeIssues\": \"error\",\n  \"reportUntypedClassDecorator\": \"error\",\n  \"reportIncompatibleMethodOverride\": \"error\",\n  \"reportUnknownVariableType\": \"none\",\n  \"reportUnknownParameterType\": \"none\",\n  \"reportUntypedFunctionDecorator\": \"none\",\n  \"reportUnknownMemberType\": \"none\",\n  \"reportUnknownArgumentType\": \"none\",\n  \"reportUnknownLambdaType\": \"none\",\n  \"reportUnusedVariable\": \"information\",\n  \"executionEnvironments\": [\n    {\n      \"root\": \".\",\n      \"extraPaths\": [\n        \"src\"\n      ]\n    }\n  ]\n}\n</code></pre> Deptry (<code>pyproject.toml</code>) <pre><code>[tool.deptry]\nignore = [\"DEP002\", \"DEP003\"]\n</code></pre> Interrogate (<code>pyproject.toml</code>) <pre><code>[tool.interrogate]\nfail-under = 98\nexclude = [\"src/bijux_cli/core/di.py\"]\ncolor = true\n</code></pre> REUSE (<code>REUSE.toml</code>) <pre><code>version = 1\n\n# Config/docs/assets: public domain\n[[annotations]]\npath = [\n  \"**/*.png\", \"**/*.svg\", \"**/*.ico\", \"**/*.gif\", \"**/*.jpg\", \"**/*.jpeg\",\n  \"**/*.html\", \"**/*.toml\", \"**/*.ini\", \"**/*.cfg\", \"**/*.conf\",\n  \"**/*.env\", \"**/*.env.*\", \"**/*.yaml\", \"**/*.yml\", \"**/*.json\",\n  \"**/*.cff\", \"**/*.dic\", \".coverage*\", \".gitattributes\", \".gitignore\",\n  \"changelog.d/**\", \"**/.editorconfig\", \"artifacts/**\", \"scripts/git-hooks/**\"\n]\nprecedence = \"override\"\nSPDX-License-Identifier = \"CC0-1.0\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Templates: public domain\n[[annotations]]\npath = [\"plugin_template/**\"]\nprecedence = \"override\"\nSPDX-License-Identifier = \"CC0-1.0\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Code: MIT\n[[annotations]]\npath = [\"**/*.py\", \"**/*.pyi\", \"**/*.sh\", \"**/*.mk\", \"Makefile\", \"Dockerfile\", \"Dockerfile.*\"]\nprecedence = \"closest\"\nSPDX-License-Identifier = \"MIT\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Markdown docs: MIT\n[[annotations]]\npath = [\"**/*.md\"]\nprecedence = \"closest\"\nSPDX-License-Identifier = \"MIT\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n</code></pre> <p>Docstring Style Enforcement We mandate Google-style docstrings via Pydocstyle (enforced in Makefile):</p> <pre><code>pydocstyle --convention=google path/to/file.py\n</code></pre> <p>Interrogate enforces documentation coverage thresholds as configured.</p>"},{"location":"ADR/0004-linting-quality-security/#ci-integration","title":"CI Integration","text":"<ul> <li><code>make lint</code> runs over <code>src/</code> and <code>tests/</code>.</li> <li><code>make quality</code> and <code>make security</code> run project-wide.</li> <li>Any failure blocks the build; no overrides.</li> </ul>"},{"location":"ADR/0004-linting-quality-security/#consequences","title":"Consequences","text":""},{"location":"ADR/0004-linting-quality-security/#pros","title":"Pros","text":"<ul> <li>Uniform enforcement across the repo; no drift.</li> <li>One tool (Ruff) handles formatting, import sorting, and linting with fast auto-fixes.</li> <li>Strong typing via Mypy, Pytype (where supported), and Pyright.</li> <li>Doc style &amp; coverage enforced via Pydocstyle + Interrogate.</li> <li>Maintainability boosted by Vulture (dead code), Deptry (deps), Radon (complexity).</li> <li>SPDX compliance via REUSE.</li> <li>Security posture improved through Bandit + pip-audit.</li> <li>All configs centralized under <code>config/</code>, ensuring local/CI parity.</li> </ul>"},{"location":"ADR/0004-linting-quality-security/#cons","title":"Cons","text":"<ul> <li>Initial setup and periodic rule maintenance.</li> <li>Contributors must align with strict rules and workflow.</li> </ul>"},{"location":"ADR/0004-linting-quality-security/#enforcement","title":"Enforcement","text":"<ul> <li>Code is accepted only if it passes all configured targets and checks in this ADR.</li> <li>Reviewers &amp; CI must reject non-compliant changes (lint, quality, security, or config deviations).</li> <li>This policy is binding to preserve the integrity of the toolchain.</li> </ul>"},{"location":"reference/api/","title":"Api Module API Reference","text":"<p>This section documents the internals of the <code>api</code> module in Bijux CLI. </p>"},{"location":"reference/api/#bijux_cli.api","title":"<code>bijux_cli.api</code>","text":"<p>Provides a high-level, synchronous facade for the Bijux CLI's core engine.</p> <p>This module defines the <code>BijuxAPI</code> class, which serves as the primary public interface for programmatic interaction with the CLI. It wraps the asynchronous core <code>Engine</code> and other services to present a stable, thread-safe, and synchronous API.</p> <p>This facade is intended for use in integrations, testing, or any scenario where the CLI's command and plugin management logic needs to be embedded within another Python application.</p>"},{"location":"reference/api/#bijux_cli.api.BijuxAPI","title":"<code>BijuxAPI(*, debug: bool = False)</code>","text":"<p>A thread-safe, synchronous access layer for the Bijux CLI engine.</p> <p>This class provides a stable public API for registering commands, executing them, and managing plugins. It wraps the internal asynchronous <code>Engine</code> to allow for simpler, synchronous integration into other applications.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_engine</code>               (<code>Engine</code>)           \u2013            <p>The core asynchronous runtime engine.</p> </li> <li> <code>_registry</code>               (<code>RegistryProtocol</code>)           \u2013            <p>The plugin registry service.</p> </li> <li> <code>_obs</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service.</p> </li> </ul> <p>Initializes the <code>BijuxAPI</code> and the underlying CLI engine.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode for all underlying services. Defaults to False.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def __init__(self, *, debug: bool = False) -&gt; None:\n    \"\"\"Initializes the `BijuxAPI` and the underlying CLI engine.\n\n    Args:\n        debug (bool): If True, enables debug mode for all underlying\n            services. Defaults to False.\n    \"\"\"\n    DIContainer.reset()\n    self._di = DIContainer.current()\n    self._engine = Engine(\n        self._di,\n        debug=debug,\n        fmt=OutputFormat.JSON,\n    )\n    self._registry: RegistryProtocol = self._di.resolve(RegistryProtocol)\n    self._obs: ObservabilityProtocol = self._di.resolve(ObservabilityProtocol)\n    self._tel: TelemetryProtocol = self._di.resolve(TelemetryProtocol)\n</code></pre>"},{"location":"reference/api/#bijux_cli.api.BijuxAPI.load_plugin","title":"<code>load_plugin(path: str | Path) -&gt; None</code>","text":"<p>Loads or reloads a plugin module from a file path.</p> <p>This method dynamically loads the specified plugin file, initializes it, and registers it with the CLI system. If the plugin is already loaded, it is reloaded.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The filesystem path to the plugin's Python file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If plugin loading, initialization, or registration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def load_plugin(self, path: str | Path) -&gt; None:\n    \"\"\"Loads or reloads a plugin module from a file path.\n\n    This method dynamically loads the specified plugin file, initializes it,\n    and registers it with the CLI system. If the plugin is already loaded,\n    it is reloaded.\n\n    Args:\n        path (str | Path): The filesystem path to the plugin's Python file.\n\n    Raises:\n        BijuxError: If plugin loading, initialization, or registration fails.\n    \"\"\"\n    from bijux_cli.__version__ import __version__\n    from bijux_cli.services.plugins import load_plugin as _load_plugin\n\n    p = Path(path).expanduser().resolve()\n    module_name = f\"bijux_plugin_{p.stem}\"\n\n    try:\n        if module_name in sys.modules:\n            importlib.reload(sys.modules[module_name])\n\n        plugin = _load_plugin(p, module_name)\n        plugin.startup(self._engine.di)\n\n        if self._registry.has(p.stem):\n            self._registry.deregister(p.stem)\n\n        self._registry.register(\n            p.stem,\n            plugin,\n            alias=str(__version__),\n        )\n        self._obs.log(\"info\", \"Loaded plugin\", extra={\"path\": str(p)})\n        self._schedule_event(\"api.plugin_loaded\", {\"path\": str(p)})\n\n    except Exception as exc:\n        self._schedule_event(\n            \"api.plugin_load.error\", {\"path\": str(p), \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Failed to load plugin {p}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api/#bijux_cli.api.BijuxAPI.register","title":"<code>register(name: str, callback: Callable[..., Any]) -&gt; None</code>","text":"<p>Registers or replaces a Python callable as a CLI command.</p> <p>The provided callable is wrapped to handle both synchronous and asynchronous functions automatically.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The command name to register.</p> </li> <li> <code>callback</code>               (<code>Callable[..., Any]</code>)           \u2013            <p>The Python function to be executed when the command is run.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the command name is already in use or another registration error occurs.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def register(self, name: str, callback: Callable[..., Any]) -&gt; None:\n    \"\"\"Registers or replaces a Python callable as a CLI command.\n\n    The provided callable is wrapped to handle both synchronous and\n    asynchronous functions automatically.\n\n    Args:\n        name (str): The command name to register.\n        callback (Callable[..., Any]): The Python function to be executed\n            when the command is run.\n\n    Raises:\n        BijuxError: If the command name is already in use or another\n            registration error occurs.\n    \"\"\"\n\n    class _Wrapper:\n        \"\"\"Wraps a user-provided callable to be executed asynchronously.\"\"\"\n\n        def __init__(self, cb: Callable[..., Any]) -&gt; None:\n            \"\"\"Initializes the wrapper.\n\n            Args:\n                cb (Callable[..., Any]): The callable to wrap.\n            \"\"\"\n            self._cb = cb\n\n        async def execute(self, *args: Any, **kwargs: Any) -&gt; Any:\n            \"\"\"Execute the wrapped callable, awaiting if it's a coroutine.\n\n            Args:\n                *args (Any): Positional arguments to pass to the callable.\n                **kwargs (Any): Keyword arguments to pass to the callable.\n\n            Returns:\n                Any: The result of the callable execution.\n            \"\"\"\n            if asyncio.iscoroutinefunction(self._cb):\n                return await self._cb(*args, **kwargs)\n            return self._cb(*args, **kwargs)\n\n    try:\n        if self._registry.has(name):\n            self._registry.deregister(name)\n        self._registry.register(name, _Wrapper(callback))\n        self._obs.log(\"info\", \"Registered command\", extra={\"name\": name})\n        self._schedule_event(\"api.register\", {\"name\": name})\n    except ServiceError as exc:\n        self._schedule_event(\n            \"api.register.error\", {\"name\": name, \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Could not register command {name}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api/#bijux_cli.api.BijuxAPI.run_async","title":"<code>run_async(name: str, *args: Any, quiet: bool = False, verbose: bool = False, fmt: str = 'json', pretty: bool = True, debug: bool = False, **kwargs: Any) -&gt; Any</code>  <code>async</code>","text":"<p>Runs a command asynchronously with validation.</p> <p>This method performs validation of flags and environment variables before dispatching the command to the internal engine for execution.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to execute.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the command.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables verbose output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'json'</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, formats the output for readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>For invalid flags, unsupported formats, or internal execution errors.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>async def run_async(\n    self,\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Runs a command asynchronously with validation.\n\n    This method performs validation of flags and environment variables\n    before dispatching the command to the internal engine for execution.\n\n    Args:\n        name (str): The name of the command to execute.\n        *args (Any): Positional arguments for the command.\n        quiet (bool): If True, suppresses output.\n        verbose (bool): If True, enables verbose output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, formats the output for readability.\n        debug (bool): If True, enables debug mode.\n        **kwargs (Any): Additional keyword arguments to pass to the command.\n\n    Returns:\n        Any: The result of the command's execution.\n\n    Raises:\n        BijuxError: For invalid flags, unsupported formats, or internal\n            execution errors.\n    \"\"\"\n    try:\n        fmt = fmt.lower()\n        if fmt not in (\"json\", \"yaml\"):\n            raise BijuxError(\"Unsupported format\", http_status=400)\n\n        if quiet and (verbose or debug):\n            raise BijuxError(\n                \"--quiet cannot be combined with --verbose/--debug\", http_status=400\n            )\n\n        validate_common_flags(fmt, name, quiet, verbose or debug)\n\n        for k, v in os.environ.items():\n            if k in IGNORE:\n                continue\n            if not v.isascii():\n                raise BijuxError(\n                    \"Non-ASCII characters in environment\", http_status=400\n                )\n\n        result = await self._engine.run_command(name, *args, **kwargs)\n        self._schedule_event(\"api.run\", {\"name\": name})\n        return result\n\n    except CommandError as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n\n    except ServiceError as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n\n    except BijuxError:\n        raise\n\n    except Exception as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api/#bijux_cli.api.BijuxAPI.run_sync","title":"<code>run_sync(name: str, *args: Any, quiet: bool = False, verbose: bool = False, fmt: str = 'json', pretty: bool = True, debug: bool = False, **kwargs: Any) -&gt; Any</code>","text":"<p>Runs a command synchronously.</p> <p>This method is a blocking wrapper around the asynchronous <code>run_async</code> method. It manages the asyncio event loop to provide a simple, synchronous interface.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to run.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the command.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables verbose logging.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'json'</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, formats the output for readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def run_sync(\n    self,\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Runs a command synchronously.\n\n    This method is a blocking wrapper around the asynchronous `run_async`\n    method. It manages the asyncio event loop to provide a simple,\n    synchronous interface.\n\n    Args:\n        name (str): The name of the command to run.\n        *args (Any): Positional arguments for the command.\n        quiet (bool): If True, suppresses output.\n        verbose (bool): If True, enables verbose logging.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, formats the output for readability.\n        debug (bool): If True, enables debug mode.\n        **kwargs (Any): Additional keyword arguments to pass to the command.\n\n    Returns:\n        Any: The result of the command's execution.\n    \"\"\"\n    try:\n        loop = asyncio.get_running_loop()\n    except RuntimeError:\n        return asyncio.run(\n            self.run_async(\n                name,\n                *args,\n                quiet=quiet,\n                verbose=verbose,\n                fmt=fmt,\n                pretty=pretty,\n                debug=debug,\n                **kwargs,\n            )\n        )\n    else:\n        return loop.run_until_complete(\n            self.run_async(\n                name,\n                *args,\n                quiet=quiet,\n                verbose=verbose,\n                fmt=fmt,\n                pretty=pretty,\n                debug=debug,\n                **kwargs,\n            )\n        )\n</code></pre>"},{"location":"reference/cli/","title":"Cli Module API Reference","text":"<p>This section documents the internals of the <code>cli</code> module in Bijux CLI. </p>"},{"location":"reference/cli/#bijux_cli.cli","title":"<code>bijux_cli.cli</code>","text":"<p>Constructs the main <code>Typer</code> application for the Bijux CLI.</p> <p>This module serves as the primary builder for the entire CLI. It defines the root <code>Typer</code> app, orchestrates the registration of all core commands and the discovery of dynamic plugins, and sets the default behavior for when the CLI is invoked without any command.</p>"},{"location":"reference/cli/#bijux_cli.cli.build_app","title":"<code>build_app() -&gt; typer.Typer</code>","text":"<p>Builds and configures the root <code>Typer</code> application.</p> <p>This factory function performs the main steps of assembling the CLI: 1.  Creates the root <code>Typer</code> app instance. 2.  Registers all core, built-in commands. 3.  Discovers and registers all dynamic plugins. 4.  Sets the default callback to launch the REPL.</p> <p>Returns:</p> <ul> <li> <code>Typer</code>           \u2013            <p>typer.Typer: The fully constructed <code>Typer</code> application.</p> </li> </ul> Source code in <code>src/bijux_cli/cli.py</code> <pre><code>def build_app() -&gt; typer.Typer:\n    \"\"\"Builds and configures the root `Typer` application.\n\n    This factory function performs the main steps of assembling the CLI:\n    1.  Creates the root `Typer` app instance.\n    2.  Registers all core, built-in commands.\n    3.  Discovers and registers all dynamic plugins.\n    4.  Sets the default callback to launch the REPL.\n\n    Returns:\n        typer.Typer: The fully constructed `Typer` application.\n    \"\"\"\n    app = typer.Typer(\n        help=\"Bijux CLI \u2013 Lean, plug-in\u2011driven command\u2011line interface.\",\n        invoke_without_command=True,\n        context_settings={\n            \"ignore_unknown_options\": True,\n            \"allow_extra_args\": True,\n        },\n    )\n    register_commands(app)\n    register_dynamic_plugins(app)\n    app.callback(invoke_without_command=True)(maybe_default_to_repl)\n    return app\n</code></pre>"},{"location":"reference/cli/#bijux_cli.cli.maybe_default_to_repl","title":"<code>maybe_default_to_repl(ctx: Context) -&gt; None</code>","text":"<p>Invokes the <code>repl</code> command if no other subcommand is specified.</p> <p>This function is used as the root callback for the main <code>Typer</code> application. It checks if a subcommand was invoked and, if not, re-executes the CLI with the <code>repl</code> command.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used to check for an invoked subcommand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/cli.py</code> <pre><code>def maybe_default_to_repl(ctx: Context) -&gt; None:\n    \"\"\"Invokes the `repl` command if no other subcommand is specified.\n\n    This function is used as the root callback for the main `Typer` application.\n    It checks if a subcommand was invoked and, if not, re-executes the CLI\n    with the `repl` command.\n\n    Args:\n        ctx (Context): The Typer context, used to check for an invoked subcommand.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand is None:\n        subprocess.call([sys.argv[0], \"repl\"])  # noqa: S603  # nosec B603\n</code></pre>"},{"location":"reference/httpapi/","title":"Httpapi Module API Reference","text":"<p>This section documents the internals of the <code>httpapi</code> module in Bijux CLI. </p>"},{"location":"reference/httpapi/#bijux_cli.httpapi","title":"<code>bijux_cli.httpapi</code>","text":"<p>Provides a self-contained FastAPI application for a CRUD API.</p> <p>This module defines a complete HTTP API for managing \"Item\" resources using the FastAPI framework. It includes all necessary components for a functional web service.</p> Services <ul> <li>Pydantic Models: <code>ItemIn</code>, <code>Item</code>, and response models for data     validation and serialization.</li> <li>Storage Layer: A formal <code>ItemStoreProtocol</code> and a concrete,     thread-safe <code>InMemoryItemStore</code> implementation.</li> <li>API Endpoints: A FastAPI <code>APIRouter</code> with path operations for all     CRUD (Create, Read, Update, Delete) actions.</li> <li>Application Lifecycle: A <code>lifespan</code> manager to prepopulate and     clear the data store on startup and shutdown.</li> </ul>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore","title":"<code>InMemoryItemStore()</code>","text":"<p>               Bases: <code>ItemStoreProtocol</code></p> <p>A thread-safe, in-memory implementation of the <code>ItemStoreProtocol</code>.</p> <p>Attributes:</p> <ul> <li> <code>_items</code>               (<code>dict</code>)           \u2013            <p>The main dictionary storing items by their ID.</p> </li> <li> <code>_name_index</code>               (<code>dict</code>)           \u2013            <p>An index to enforce unique item names.</p> </li> <li> <code>_lock</code>               (<code>RLock</code>)           \u2013            <p>A lock to ensure thread-safe operations.</p> </li> <li> <code>_next_id</code>               (<code>int</code>)           \u2013            <p>A counter for generating new item IDs.</p> </li> </ul> <p>Initializes the in-memory item store.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the in-memory item store.\"\"\"\n    self._items: dict[int, Item] = {}\n    self._name_index: dict[str, int] = {}\n    self._lock = threading.RLock()\n    self._next_id = 1\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.create","title":"<code>create(data: ItemIn) -&gt; Item</code>","text":"<p>Creates a new item.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ItemIn</code>)           \u2013            <p>The data for the new item.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The newly created item, including its generated ID.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 409 if an item with the same name exists.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def create(self, data: ItemIn) -&gt; Item:\n    \"\"\"Creates a new item.\n\n    Args:\n        data (ItemIn): The data for the new item.\n\n    Returns:\n        The newly created item, including its generated ID.\n\n    Raises:\n        HTTPException: With status 409 if an item with the same name exists.\n    \"\"\"\n    with self._lock:\n        name = data.name  # Already stripped by validator\n        if name in self._name_index:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/conflict\"),\n                    title=\"Conflict\",\n                    status=status.HTTP_409_CONFLICT,\n                    detail=\"Item with this name already exists\",\n                    instance=\"/v1/items\",\n                ).model_dump(mode=\"json\"),\n            )\n        item_id = self._next_id\n        self._next_id += 1\n        item = Item(id=item_id, name=name, description=data.description)\n        self._items[item_id] = item\n        self._name_index[name] = item_id\n        logger.info(f\"Created item: {item}\")\n        return item\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.delete","title":"<code>delete(item_id: int) -&gt; None</code>","text":"<p>Deletes an item by its unique ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def delete(self, item_id: int) -&gt; None:\n    \"\"\"Deletes an item by its unique ID.\n\n    Args:\n        item_id (int): The ID of the item to delete.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found.\n    \"\"\"\n    with self._lock:\n        item = self._items.pop(item_id, None)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        del self._name_index[item.name]\n        logger.info(f\"Deleted item id={item_id}\")\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.get","title":"<code>get(item_id: int) -&gt; Item</code>","text":"<p>Gets an item by its unique ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The requested item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get(self, item_id: int) -&gt; Item:\n    \"\"\"Gets an item by its unique ID.\n\n    Args:\n        item_id (int): The ID of the item to retrieve.\n\n    Returns:\n        The requested item.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found.\n    \"\"\"\n    with self._lock:\n        item = self._items.get(item_id)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        return item\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.list_items","title":"<code>list_items(limit: int, offset: int) -&gt; tuple[list[Item], int]</code>","text":"<p>Lists items with pagination in a thread-safe manner.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>)           \u2013            <p>The maximum number of items to return.</p> </li> <li> <code>offset</code>               (<code>int</code>)           \u2013            <p>The starting index for the items to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[Item], int]</code>           \u2013            <p>A tuple containing the list of items and the total number of items.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def list_items(self, limit: int, offset: int) -&gt; tuple[list[Item], int]:\n    \"\"\"Lists items with pagination in a thread-safe manner.\n\n    Args:\n        limit (int): The maximum number of items to return.\n        offset (int): The starting index for the items to return.\n\n    Returns:\n        A tuple containing the list of items and the total number of items.\n    \"\"\"\n    with self._lock:\n        items = list(self._items.values())\n        return items[offset : offset + limit], len(items)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.prepopulate","title":"<code>prepopulate(data: list[dict[str, Any]]) -&gt; None</code>","text":"<p>Prepopulates the store with a list of items.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def prepopulate(self, data: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Prepopulates the store with a list of items.\"\"\"\n    with self._lock:\n        for entry in data:\n            self.create(ItemIn(**entry))\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets the store to its initial empty state.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the store to its initial empty state.\"\"\"\n    with self._lock:\n        self._items.clear()\n        self._name_index.clear()\n        self._next_id = 1\n        logger.info(\"Store reset\")\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.InMemoryItemStore.update","title":"<code>update(item_id: int, data: ItemIn) -&gt; Item</code>","text":"<p>Updates an existing item.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to update.</p> </li> <li> <code>data</code>               (<code>ItemIn</code>)           \u2013            <p>The new data for the item.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The updated item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found, or 409 if the new name conflicts with another existing item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def update(self, item_id: int, data: ItemIn) -&gt; Item:\n    \"\"\"Updates an existing item.\n\n    Args:\n        item_id (int): The ID of the item to update.\n        data (ItemIn): The new data for the item.\n\n    Returns:\n        The updated item.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found, or 409\n            if the new name conflicts with another existing item.\n    \"\"\"\n    with self._lock:\n        item = self._items.get(item_id)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        name = data.name  # Already stripped by validator\n        if name != item.name and name in self._name_index:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/conflict\"),\n                    title=\"Conflict\",\n                    status=status.HTTP_409_CONFLICT,\n                    detail=\"Item with this name already exists\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        if name != item.name:\n            del self._name_index[item.name]\n            self._name_index[name] = item_id\n        updated = Item(id=item_id, name=name, description=data.description)\n        self._items[item_id] = updated\n        logger.info(f\"Updated item: {updated}\")\n        return updated\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.Item","title":"<code>Item</code>","text":"<p>               Bases: <code>ItemIn</code></p> <p>Defines the full item model, including its unique identifier.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>The unique identifier for the item.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the item.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>An optional description for the item.</p> </li> </ul>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemIn","title":"<code>ItemIn</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the input model for creating or updating an item.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the item.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>An optional description for the item.</p> </li> </ul>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemIn.normalize_name","title":"<code>normalize_name(v: str) -&gt; str</code>  <code>classmethod</code>","text":"<p>Strips leading/trailing whitespace from the name field.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef normalize_name(cls: type[ItemIn], v: str) -&gt; str:  # noqa: N805\n    \"\"\"Strips leading/trailing whitespace from the name field.\"\"\"\n    return v.strip()\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemListResponse","title":"<code>ItemListResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the response model for a paginated list of items.</p> <p>Attributes:</p> <ul> <li> <code>items</code>               (<code>list[Item]</code>)           \u2013            <p>The list of items on the current page.</p> </li> <li> <code>total</code>               (<code>int</code>)           \u2013            <p>The total number of items available.</p> </li> </ul>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol","title":"<code>ItemStoreProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for an item storage service.</p>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.create","title":"<code>create(data: ItemIn) -&gt; Item</code>","text":"<p>Creates a new item.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def create(self, data: ItemIn) -&gt; Item:\n    \"\"\"Creates a new item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.delete","title":"<code>delete(item_id: int) -&gt; None</code>","text":"<p>Deletes an item by its unique ID.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def delete(self, item_id: int) -&gt; None:\n    \"\"\"Deletes an item by its unique ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.get","title":"<code>get(item_id: int) -&gt; Item</code>","text":"<p>Gets an item by its unique ID.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get(self, item_id: int) -&gt; Item:\n    \"\"\"Gets an item by its unique ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.list_items","title":"<code>list_items(limit: int, offset: int) -&gt; tuple[list[Item], int]</code>","text":"<p>Lists items with pagination.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def list_items(self, limit: int, offset: int) -&gt; tuple[list[Item], int]:\n    \"\"\"Lists items with pagination.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.prepopulate","title":"<code>prepopulate(data: list[dict[str, Any]]) -&gt; None</code>","text":"<p>Prepopulates the store with a list of items.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def prepopulate(self, data: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Prepopulates the store with a list of items.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets the store to its initial empty state.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the store to its initial empty state.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.ItemStoreProtocol.update","title":"<code>update(item_id: int, data: ItemIn) -&gt; Item</code>","text":"<p>Updates an existing item.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def update(self, item_id: int, data: ItemIn) -&gt; Item:\n    \"\"\"Updates an existing item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.Problem","title":"<code>Problem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a standard RFC 7807 problem details response.</p> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>AnyUrl</code>)           \u2013            <p>A URI reference that identifies the problem type.</p> </li> <li> <code>title</code>               (<code>str</code>)           \u2013            <p>A short, human-readable summary of the problem type.</p> </li> <li> <code>status</code>               (<code>int</code>)           \u2013            <p>The HTTP status code.</p> </li> <li> <code>detail</code>               (<code>str</code>)           \u2013            <p>A human-readable explanation specific to this occurrence.</p> </li> <li> <code>instance</code>               (<code>str</code>)           \u2013            <p>A URI reference that identifies the specific occurrence.</p> </li> </ul>"},{"location":"reference/httpapi/#bijux_cli.httpapi.create_item","title":"<code>create_item(item: ItemIn = Body(...), store: ItemStoreProtocol = Depends(get_store)) -&gt; Item</code>","text":"<p>Creates a new item.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>ItemIn</code>, default:                   <code>Body(...)</code> )           \u2013            <p>The data for the new item from the request body.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The newly created item, including its server-generated ID.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.post(\n    \"/items\",\n    response_model=Item,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create item\",\n    description=\"Create a new item.\",\n    responses={409: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef create_item(\n    item: ItemIn = Body(...),  # noqa: B008\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Creates a new item.\n\n    Args:\n        item (ItemIn): The data for the new item from the request body.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The newly created item, including its server-generated ID.\n    \"\"\"\n    return store.create(item)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.delete_item","title":"<code>delete_item(item_id: int = Path(..., gt=0), store: ItemStoreProtocol = Depends(get_store)) -&gt; Response</code>","text":"<p>Deletes an item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to delete.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Response</code> (              <code>Response</code> )          \u2013            <p>An empty response with a 204 No Content status code.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.delete(\n    \"/items/{item_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete item\",\n    description=\"Delete an item by its ID.\",\n    responses={404: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef delete_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Response:\n    \"\"\"Deletes an item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to delete.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Response: An empty response with a 204 No Content status code.\n    \"\"\"\n    store.delete(item_id)\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.get_item","title":"<code>get_item(item_id: int = Path(..., gt=0), store: ItemStoreProtocol = Depends(get_store)) -&gt; Item</code>","text":"<p>Retrieves a single item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to retrieve.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The requested item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.get(\n    \"/items/{item_id}\",\n    response_model=Item,\n    summary=\"Get item\",\n    description=\"Get a single item by its ID.\",\n    responses={404: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef get_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Retrieves a single item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to retrieve.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The requested item.\n    \"\"\"\n    return store.get(item_id)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.get_store","title":"<code>get_store() -&gt; ItemStoreProtocol</code>","text":"<p>A FastAPI dependency to provide the <code>ItemStoreProtocol</code> instance.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get_store() -&gt; ItemStoreProtocol:\n    \"\"\"A FastAPI dependency to provide the `ItemStoreProtocol` instance.\"\"\"\n    return store\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.health","title":"<code>health() -&gt; dict[str, str]</code>  <code>async</code>","text":"<p>Lightweight readiness probe used by Makefile <code>api-test</code>.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.get(\"/health\", summary=\"Health check\", tags=[\"Health\"])\nasync def health() -&gt; dict[str, str]:\n    \"\"\"Lightweight readiness probe used by Makefile `api-test`.\"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.http_exception_handler","title":"<code>http_exception_handler(request: Request, exc: HTTPException) -&gt; JSONResponse</code>  <code>async</code>","text":"<p>A custom exception handler for <code>HTTPException</code>.</p> <p>This handler intercepts FastAPI's standard HTTP exceptions and ensures they are logged and returned in the standard JSON error format.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The incoming request.</p> </li> <li> <code>exc</code>               (<code>HTTPException</code>)           \u2013            <p>The HTTP exception.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JSONResponse</code> (              <code>JSONResponse</code> )          \u2013            <p>A JSON response detailing the HTTP error.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException) -&gt; JSONResponse:\n    \"\"\"A custom exception handler for `HTTPException`.\n\n    This handler intercepts FastAPI's standard HTTP exceptions and ensures they\n    are logged and returned in the standard JSON error format.\n\n    Args:\n        request (Request): The incoming request.\n        exc (HTTPException): The HTTP exception.\n\n    Returns:\n        JSONResponse: A JSON response detailing the HTTP error.\n    \"\"\"\n    logger.warning(f\"HTTP error: {exc.status_code} {exc.detail}\")\n    return JSONResponse(status_code=exc.status_code, content=exc.detail)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.lifespan","title":"<code>lifespan(app: FastAPI) -&gt; AsyncIterator[None]</code>  <code>async</code>","text":"<p>Manages the application's lifespan events for startup and shutdown.</p> <p>On startup, this context manager resets and prepopulates the in-memory store with demo data. On shutdown, it resets the store again.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>The FastAPI application instance.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>AsyncIterator[None]</code> )          \u2013            <p>Yields control to the application while it is running.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Manages the application's lifespan events for startup and shutdown.\n\n    On startup, this context manager resets and prepopulates the in-memory\n    store with demo data. On shutdown, it resets the store again.\n\n    Args:\n        app (FastAPI): The FastAPI application instance.\n\n    Yields:\n        None: Yields control to the application while it is running.\n    \"\"\"\n    store.reset()\n    store.prepopulate(\n        [\n            {\"name\": \"Item One\", \"description\": \"Description one\"},\n            {\"name\": \"Item Two\", \"description\": \"Description two\"},\n        ]\n    )\n    logger.info(\"Prepopulated store with demo items\")\n    yield\n    store.reset()\n    logger.info(\"Store reset on shutdown\")\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.list_items","title":"<code>list_items(limit: int = Query(10, ge=1, le=100), offset: int = Query(0, ge=0), store: ItemStoreProtocol = Depends(get_store)) -&gt; ItemListResponse</code>","text":"<p>Retrieves a paginated list of items.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=100)</code> )           \u2013            <p>The maximum number of items per page.</p> </li> <li> <code>offset</code>               (<code>int</code>, default:                   <code>Query(0, ge=0)</code> )           \u2013            <p>The starting offset for the item list.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemListResponse</code> (              <code>ItemListResponse</code> )          \u2013            <p>An object containing the list of items and total count.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.get(\n    \"/items\",\n    response_model=ItemListResponse,\n    summary=\"List items\",\n    description=\"List all items with pagination.\",\n    tags=[\"Items\"],\n)\ndef list_items(\n    limit: int = Query(10, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; ItemListResponse:\n    \"\"\"Retrieves a paginated list of items.\n\n    Args:\n        limit (int): The maximum number of items per page.\n        offset (int): The starting offset for the item list.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        ItemListResponse: An object containing the list of items and total count.\n    \"\"\"\n    items, total = store.list_items(limit, offset)\n    return ItemListResponse(items=items, total=total)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.update_item","title":"<code>update_item(item_id: int = Path(..., gt=0), item: ItemIn = Body(...), store: ItemStoreProtocol = Depends(get_store)) -&gt; Item</code>","text":"<p>Updates an existing item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to update.</p> </li> <li> <code>item</code>               (<code>ItemIn</code>, default:                   <code>Body(...)</code> )           \u2013            <p>The new data for the item from the request body.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The updated item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.put(\n    \"/items/{item_id}\",\n    response_model=Item,\n    summary=\"Update item\",\n    description=\"Update an existing item.\",\n    responses={404: {\"model\": Problem}, 409: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef update_item(\n    item_id: int = Path(..., gt=0),\n    item: ItemIn = Body(...),  # noqa: B008\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Updates an existing item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to update.\n        item (ItemIn): The new data for the item from the request body.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The updated item.\n    \"\"\"\n    return store.update(item_id, item)\n</code></pre>"},{"location":"reference/httpapi/#bijux_cli.httpapi.validation_exception_handler","title":"<code>validation_exception_handler(request: Request, exc: RequestValidationError) -&gt; JSONResponse</code>  <code>async</code>","text":"<p>A custom exception handler for <code>RequestValidationError</code>.</p> <p>This handler intercepts validation errors from FastAPI and formats them into a standard <code>JSONResponse</code> with a 422 status code.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The incoming request.</p> </li> <li> <code>exc</code>               (<code>RequestValidationError</code>)           \u2013            <p>The validation exception.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JSONResponse</code> (              <code>JSONResponse</code> )          \u2013            <p>A JSON response detailing the validation error.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request, exc: RequestValidationError\n) -&gt; JSONResponse:\n    \"\"\"A custom exception handler for `RequestValidationError`.\n\n    This handler intercepts validation errors from FastAPI and formats them\n    into a standard `JSONResponse` with a 422 status code.\n\n    Args:\n        request (Request): The incoming request.\n        exc (RequestValidationError): The validation exception.\n\n    Returns:\n        JSONResponse: A JSON response detailing the validation error.\n    \"\"\"\n    logger.warning(f\"Validation error: {exc.errors()}\")\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content=Problem(\n            type=AnyUrl(\"https://bijux-cli.dev/docs/errors/validation-error\"),\n            title=\"Validation error\",\n            status=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=str(exc),\n            instance=str(request.url),\n        ).model_dump(mode=\"json\"),\n    )\n</code></pre>"},{"location":"reference/commands/audit/","title":"Audit Command API Reference","text":"<p>This section documents the internals of the <code>audit</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/audit/#bijux_cli.commands.audit","title":"<code>bijux_cli.commands.audit</code>","text":"<p>Audit command for the Bijux CLI.</p> <p>Audits the current environment and configuration, emitting machine-readable structured output in JSON or YAML. Supports dry-run simulation and writing results to a file. Handles ASCII hygiene and structured error contracts. Output is automation-safe and suitable for scripting or monitoring.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"completed\"}</code></li> <li>Dry-run: <code>{\"status\": \"dry-run\"}</code></li> <li>Written: <code>{\"status\": \"written\", \"file\": \"&lt;path&gt;\"}</code></li> <li>Verbose: <code>{\"python\": str, \"platform\": str}</code></li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success, dry-run, or write success.</li> <li><code>1</code>: Unexpected/internal error.</li> <li><code>2</code>: CLI argument/flag/format or output-path error.</li> <li><code>3</code>: ASCII/encoding error.</li> </ul>"},{"location":"reference/commands/audit/#bijux_cli.commands.audit.audit","title":"<code>audit(ctx: typer.Context, dry_run: bool = DRY_RUN_OPTION, output: Path | None = OUTPUT_OPTION, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux audit</code> command.</p> <p>This function orchestrates the entire audit process. It validates all CLI flags and arguments, performs environment checks (e.g., for non-ASCII characters), builds the appropriate result payload, and emits it to stdout or a file in the specified format. All errors are handled and emitted in a structured format before exiting with a specific code.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used to manage command state and detect stray arguments.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>DRY_RUN_OPTION</code> )           \u2013            <p>If True, simulates the audit and reports a \"dry-run\" status without performing actions.</p> </li> <li> <code>output</code>               (<code>Path | None</code>, default:                   <code>OUTPUT_OPTION</code> )           \u2013            <p>If a path is provided, writes the audit result to the specified file instead of stdout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors. The exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability. This is overridden by <code>debug</code>.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, which implies <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a status code and structured error payload upon validation failures (e.g., bad arguments, ASCII errors), I/O issues, or unexpected exceptions. The exit code follows the contract defined in the module docstring.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/audit.py</code> <pre><code>@audit_app.callback(invoke_without_command=True)\ndef audit(\n    ctx: typer.Context,\n    dry_run: bool = DRY_RUN_OPTION,\n    output: Path | None = OUTPUT_OPTION,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux audit` command.\n\n    This function orchestrates the entire audit process. It validates all CLI\n    flags and arguments, performs environment checks (e.g., for non-ASCII\n    characters), builds the appropriate result payload, and emits it to\n    stdout or a file in the specified format. All errors are handled and\n    emitted in a structured format before exiting with a specific code.\n\n    Args:\n        ctx (typer.Context): The Typer context, used to manage command state\n            and detect stray arguments.\n        dry_run (bool): If True, simulates the audit and reports a \"dry-run\"\n            status without performing actions.\n        output (Path | None): If a path is provided, writes the audit result\n            to the specified file instead of stdout.\n        quiet (bool): If True, suppresses all output except for errors. The\n            exit code is the primary indicator of the outcome.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n            This is overridden by `debug`.\n        debug (bool): If True, enables debug diagnostics, which implies `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a status code and structured error payload upon\n            validation failures (e.g., bad arguments, ASCII errors), I/O\n            issues, or unexpected exceptions. The exit code follows the\n            contract defined in the module docstring.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"audit\"\n\n    try:\n        stray_args = [a for a in ctx.args if not a.startswith(\"-\")]\n        if stray_args:\n            raise typer.BadParameter(f\"No such argument: {stray_args[0]}\")\n        fmt_lower = validate_common_flags(fmt, command, quiet)\n        include_runtime = verbose or debug\n        effective_pretty = debug or pretty\n        out_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n\n        if contains_non_ascii_env():\n            emit_error_and_exit(\n                \"Non-ASCII environment variables detected\",\n                code=3,\n                failure=\"ascii_env\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n            )\n        try:\n            validate_env_file_if_present(os.environ.get(\"BIJUXCLI_CONFIG\", \"\"))\n        except ValueError as exc:\n            emit_error_and_exit(\n                str(exc),\n                code=3,\n                failure=\"ascii\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n            )\n\n    except typer.BadParameter as exc:\n        error_fmt = fmt.lower() if fmt.lower() in (\"json\", \"yaml\") else \"json\"\n        emit_error_and_exit(\n            exc.message,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=verbose or debug,\n        )\n\n    try:\n        emitter = DIContainer.current().resolve(EmitterProtocol)\n        payload = _build_payload(include_runtime, dry_run)\n\n        if output is not None:\n            _write_output_file(\n                output_path=output,\n                payload=payload,\n                emitter=emitter,\n                fmt=out_format,\n                pretty=effective_pretty,\n                debug=debug,\n                dry_run=dry_run,\n            )\n            payload = {\"status\": \"written\", \"file\": str(output)}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n\n        new_run_command(\n            command_name=command,\n            payload_builder=lambda _: payload,\n            quiet=quiet,\n            verbose=(verbose or debug),\n            fmt=fmt_lower,\n            pretty=(debug or pretty),\n            debug=debug,\n        )\n\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n    except OSError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=2,\n            failure=\"output_file\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"An unexpected error occurred: {exc}\",\n            code=1,\n            failure=\"unexpected\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n</code></pre>"},{"location":"reference/commands/docs/","title":"Docs Command API Reference","text":"<p>This section documents the internals of the <code>docs</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/docs/#bijux_cli.commands.docs","title":"<code>bijux_cli.commands.docs</code>","text":"<p>Docs command for the Bijux CLI.</p> <p>Generates a machine-readable specification of the entire CLI, outputting it as JSON or YAML. This command is designed for automation, enabling integration with external documentation tools or APIs. It supports outputting to stdout or a file and ensures all text is ASCII-safe.</p> Output Contract <ul> <li>Success (file):   <code>{\"status\": \"written\", \"file\": \"&lt;path&gt;\"}</code></li> <li>Success (stdout): The raw specification string is printed directly.</li> <li>Spec fields:      <code>{\"version\": str, \"commands\": list, ...}</code></li> <li>Verbose:          Adds <code>{\"python\": str, \"platform\": str}</code> to the spec.</li> <li>Error:            <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Fatal or internal error.</li> <li><code>2</code>: CLI argument, flag, or format error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/docs/#bijux_cli.commands.docs.docs","title":"<code>docs(ctx: typer.Context, out: Path | None = OUT_OPTION, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux docs</code> command.</p> <p>This function orchestrates the entire specification generation process. It validates CLI flags, checks for ASCII-safe environment variables, resolves the output destination, builds the specification payload, and writes the result to a file or stdout. All errors are handled and emitted in a structured format before exiting with a specific code.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used for managing command state.</p> </li> <li> <code>out</code>               (<code>Path | None</code>, default:                   <code>OUT_OPTION</code> )           \u2013            <p>The output destination: a file path, a directory, or '-' to signify stdout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform metadata in the spec.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits the application with a contract-compliant status code and payload upon any error, including argument validation, ASCII violations, serialization failures, or I/O issues.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/docs.py</code> <pre><code>@docs_app.callback(invoke_without_command=True)\ndef docs(\n    ctx: typer.Context,\n    out: Path | None = OUT_OPTION,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux docs` command.\n\n    This function orchestrates the entire specification generation process. It\n    validates CLI flags, checks for ASCII-safe environment variables, resolves\n    the output destination, builds the specification payload, and writes the\n    result to a file or stdout. All errors are handled and emitted in a\n    structured format before exiting with a specific code.\n\n    Args:\n        ctx (typer.Context): The Typer context, used for managing command state.\n        out (Path | None): The output destination: a file path, a directory, or\n            '-' to signify stdout.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform metadata in the spec.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits the application with a contract-compliant status code\n            and payload upon any error, including argument validation, ASCII\n            violations, serialization failures, or I/O issues.\n    \"\"\"\n    from bijux_cli.commands.utilities import normalize_format\n    from bijux_cli.infra.serializer import OrjsonSerializer, PyYAMLSerializer\n    from bijux_cli.infra.telemetry import NullTelemetry\n\n    command = \"docs\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = normalize_format(fmt)\n\n    if ctx.args:\n        stray = ctx.args[0]\n        msg = (\n            f\"No such option: {stray}\"\n            if stray.startswith(\"-\")\n            else f\"Too many arguments: {' '.join(ctx.args)}\"\n        )\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII characters in environment variables\",\n            code=3,\n            failure=\"ascii_env\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    out_env = os.environ.get(\"BIJUXCLI_DOCS_OUT\")\n    if out is None and out_env:\n        out = Path(out_env)\n\n    target, path = _resolve_output_target(out, fmt_lower)\n\n    try:\n        spec = _build_spec_payload(effective_include_runtime)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    serializer = (\n        PyYAMLSerializer(NullTelemetry())\n        if output_format is OutputFormat.YAML\n        else OrjsonSerializer(NullTelemetry())\n    )\n    try:\n        content = serializer.dumps(spec, fmt=output_format, pretty=effective_pretty)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Serialization failed: {exc}\",\n            code=1,\n            failure=\"serialize\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if os.environ.get(\"BIJUXCLI_TEST_IO_FAIL\") == \"1\":\n        emit_error_and_exit(\n            \"Simulated I/O failure for test\",\n            code=1,\n            failure=\"io_fail\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if target == \"-\":\n        if not quiet:\n            typer.echo(content)\n        raise typer.Exit(0)\n\n    if path is None:\n        emit_error_and_exit(\n            \"Internal error: expected non-null output path\",\n            code=1,\n            failure=\"internal\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    parent = path.parent\n    if not parent.exists():\n        emit_error_and_exit(\n            f\"Output directory does not exist: {parent}\",\n            code=2,\n            failure=\"output_dir\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    try:\n        path.write_text(content, encoding=\"utf-8\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to write spec: {exc}\",\n            code=2,\n            failure=\"write\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    emit_and_exit(\n        {\"status\": \"written\", \"file\": str(path)},\n        output_format,\n        effective_pretty,\n        verbose,\n        debug,\n        quiet,\n        command,\n    )\n</code></pre>"},{"location":"reference/commands/doctor/","title":"Doctor Command API Reference","text":"<p>This section documents the internals of the <code>doctor</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/doctor/#bijux_cli.commands.doctor","title":"<code>bijux_cli.commands.doctor</code>","text":"<p>Implements the <code>doctor</code> command for the Bijux CLI.</p> <p>This module provides the functionality for the <code>bijux doctor</code> command, which runs a series of health diagnostics on the CLI's operating environment. It checks for common configuration issues and reports a summary of its findings in a structured, machine-readable format suitable for automation.</p> Output Contract <ul> <li>Success: <code>{\"status\": str, \"summary\": list[str]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success (command ran without errors, regardless of health status).</li> <li><code>1</code>: Internal or fatal error (e.g., dependency injection failure).</li> <li><code>2</code>: CLI argument or flag error.</li> </ul>"},{"location":"reference/commands/doctor/#bijux_cli.commands.doctor.doctor","title":"<code>doctor(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux doctor</code> command.</p> <p>This function orchestrates the health check process. It validates all CLI flags, performs critical pre-flight checks (like dependency availability), and then invokes the main run utility to build and emit the health payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for managing command state.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output; the exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits the application with a contract-compliant status code and payload upon any error, such as invalid arguments or an internal system failure.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/doctor.py</code> <pre><code>@doctor_app.callback(invoke_without_command=True)\ndef doctor(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux doctor` command.\n\n    This function orchestrates the health check process. It validates all CLI\n    flags, performs critical pre-flight checks (like dependency availability),\n    and then invokes the main run utility to build and emit the health payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for managing command state.\n        quiet (bool): If True, suppresses all output; the exit code is the\n            primary indicator of the outcome.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits the application with a contract-compliant status code\n            and payload upon any error, such as invalid arguments or an\n            internal system failure.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"doctor\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if ctx.args:\n        stray = ctx.args[0]\n        msg = (\n            f\"No such option: {stray}\"\n            if stray.startswith(\"-\")\n            else f\"Too many arguments: {' '.join(ctx.args)}\"\n        )\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    try:\n        DIContainer.current().resolve(EmitterProtocol)\n        DIContainer.current().resolve(TelemetryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=1,\n            failure=\"internal\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=_build_payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/help/","title":"Help Command API Reference","text":"<p>This section documents the internals of the <code>help</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/help/#bijux_cli.commands.help","title":"<code>bijux_cli.commands.help</code>","text":"<p>Implements the <code>help</code> command for the Bijux CLI.</p> <p>This module provides a contextual help system that can generate and display help text for any command or subcommand. It supports multiple output formats, including human-readable text for interactive use and structured JSON or YAML for automation and integration purposes. It also includes special logic to suppress known noisy warnings from the plugin system during help generation.</p> Output Contract <ul> <li>Human:      Standard CLI help text is printed to stdout.</li> <li>JSON/YAML:  <code>{\"help\": str}</code></li> <li>Verbose:    Adds <code>{\"python\": str, \"platform\": str, \"runtime_ms\": int}</code>.</li> <li>Error:      <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Fatal or internal error.</li> <li><code>2</code>: CLI argument, flag, or \"command not found\" error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/help/#bijux_cli.commands.help.help_callback","title":"<code>help_callback(ctx: typer.Context, command_path: list[str] | None = ARGS, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option(_HUMAN, '-f', '--format', help=HELP_FORMAT_HELP), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux help</code> command.</p> <p>This function orchestrates the entire help generation process. It parses the target command path, finds the corresponding command object, performs ASCII and format validation, and emits the help text in the specified format.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>command_path</code>               (<code>list[str] | None</code>, default:                   <code>ARGS</code> )           \u2013            <p>A list of tokens representing the path to the target command (e.g., <code>[\"config\", \"get\"]</code>).</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output. The exit code is the primary indicator of outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in structured output formats.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option(_HUMAN, '-f', '--format', help=HELP_FORMAT_HELP)</code> )           \u2013            <p>The output format: \"human\", \"json\", or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints structured output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant exit code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/help.py</code> <pre><code>@help_app.callback(invoke_without_command=True)\ndef help_callback(\n    ctx: typer.Context,\n    command_path: list[str] | None = ARGS,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(_HUMAN, \"-f\", \"--format\", help=HELP_FORMAT_HELP),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux help` command.\n\n    This function orchestrates the entire help generation process. It parses the\n    target command path, finds the corresponding command object, performs ASCII\n    and format validation, and emits the help text in the specified format.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        command_path (list[str] | None): A list of tokens representing the path\n            to the target command (e.g., `[\"config\", \"get\"]`).\n        quiet (bool): If True, suppresses all output. The exit code is the\n            primary indicator of outcome.\n        verbose (bool): If True, includes Python and platform details in\n            structured output formats.\n        fmt (str): The output format: \"human\", \"json\", or \"yaml\".\n        pretty (bool): If True, pretty-prints structured output.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant exit code and payload\n            upon completion or error.\n    \"\"\"\n    started_at = time.perf_counter()\n\n    if \"-h\" in sys.argv or \"--help\" in sys.argv:\n        all_args = sys.argv[2:]\n        known_flags_with_args = {\"-f\", \"--format\"}\n        path_tokens = []\n        i = 0\n        while i &lt; len(all_args):\n            arg = all_args[i]\n            if arg in known_flags_with_args:\n                i += 2\n            elif arg.startswith(\"-\"):\n                i += 1\n            else:\n                path_tokens.append(arg)\n                i += 1\n\n        target = _find_target_command(ctx, path_tokens) or _find_target_command(ctx, [])\n        if target:\n            target_cmd, target_ctx = target\n            help_text = _get_formatted_help(target_cmd, target_ctx)\n            typer.echo(help_text)\n        raise typer.Exit(0)\n\n    tokens = command_path or []\n    command = \"help\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n    fmt_lower = fmt.strip().lower()\n    error_fmt = fmt_lower if fmt_lower in (\"json\", \"yaml\") else \"json\"\n\n    if quiet:\n        if fmt_lower not in _VALID_FORMATS:\n            raise SystemExit(2)\n\n        for token in tokens:\n            if \"\\x00\" in token:\n                raise SystemExit(3)\n            try:\n                token.encode(\"ascii\")\n            except UnicodeEncodeError as err:\n                raise SystemExit(3) from err\n\n        if contains_non_ascii_env():\n            raise SystemExit(3)\n\n        if not _find_target_command(ctx, tokens):\n            raise SystemExit(2)\n\n        raise SystemExit(0)\n\n    if fmt_lower != \"human\":\n        validate_common_flags(\n            fmt,\n            command,\n            quiet,\n            include_runtime=effective_include_runtime,\n        )\n\n    if fmt_lower not in _VALID_FORMATS:\n        emit_error_and_exit(\n            f\"Unsupported format: '{fmt}'\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    for token in tokens:\n        if \"\\x00\" in token:\n            emit_error_and_exit(\n                \"Embedded null byte in command path\",\n                code=3,\n                failure=\"null_byte\",\n                command=command,\n                fmt=error_fmt,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n        try:\n            token.encode(\"ascii\")\n        except UnicodeEncodeError:\n            emit_error_and_exit(\n                f\"Non-ASCII characters in command path: {token!r}\",\n                code=3,\n                failure=\"ascii\",\n                command=command,\n                fmt=error_fmt,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII in environment\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    target = _find_target_command(ctx, tokens)\n    if not target:\n        emit_error_and_exit(\n            f\"No such command: {' '.join(tokens)}\",\n            code=2,\n            failure=\"not_found\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    DIContainer.current().resolve(EmitterProtocol)\n    target_cmd, target_ctx = target\n    help_text = _get_formatted_help(target_cmd, target_ctx)\n\n    if fmt_lower == _HUMAN:\n        typer.echo(help_text)\n        raise typer.Exit(0)\n\n    try:\n        payload = _build_help_payload(help_text, effective_include_runtime, started_at)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    emit_and_exit(\n        payload=payload,\n        fmt=output_format,\n        effective_pretty=effective_pretty,\n        verbose=verbose,\n        debug=debug,\n        quiet=quiet,\n        command=command,\n        exit_code=0,\n    )\n</code></pre>"},{"location":"reference/commands/repl/","title":"Repl Command API Reference","text":"<p>This section documents the internals of the <code>repl</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/repl/#bijux_cli.commands.repl","title":"<code>bijux_cli.commands.repl</code>","text":"<p>Implements the interactive Read-Eval-Print Loop (REPL) for the Bijux CLI.</p> <p>This module provides a rich, interactive shell for executing Bijux CLI commands. It enhances the user experience with features like persistent command history, context-aware tab-completion, and a colorized prompt. Users can chain multiple commands on a single line using semicolons. The REPL can also operate in a non-interactive mode to process commands piped from stdin.</p> <p>The REPL itself operates in a human-readable format. When executing commands, it respects global flags like <code>--format</code> or <code>--quiet</code> for those specific invocations.</p> Exit Codes <ul> <li><code>0</code>: The REPL session was exited cleanly (e.g., via <code>exit</code>, <code>quit</code>,   Ctrl+D, or a caught signal).</li> <li><code>2</code>: An invalid flag was provided to the <code>repl</code> command itself   (e.g., <code>--format=json</code>).</li> </ul>"},{"location":"reference/commands/repl/#bijux_cli.commands.repl.CommandCompleter","title":"<code>CommandCompleter(main_app: typer.Typer)</code>","text":"<p>               Bases: <code>Completer</code></p> <p>Provides context-aware tab-completion for the REPL.</p> <p>Initializes the completer.</p> <p>Parameters:</p> <ul> <li> <code>main_app</code>               (<code>Typer</code>)           \u2013            <p>The root Typer application whose commands and options will be used for completion suggestions.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def __init__(self, main_app: typer.Typer) -&gt; None:\n    \"\"\"Initializes the completer.\n\n    Args:\n        main_app (typer.Typer): The root Typer application whose commands\n            and options will be used for completion suggestions.\n    \"\"\"\n    self.main_app = main_app\n    self._cmd_map = self._collect(main_app)\n    self._BUILTINS = _BUILTINS\n</code></pre>"},{"location":"reference/commands/repl/#bijux_cli.commands.repl.CommandCompleter.get_completions","title":"<code>get_completions(document: Document, _complete_event: CompleteEvent) -&gt; Iterator[Completion]</code>","text":"<p>Yields completion suggestions for the current input.</p> <p>Parameters:</p> <ul> <li> <code>document</code>               (<code>Document</code>)           \u2013            <p>The current <code>prompt_toolkit</code> document.</p> </li> <li> <code>_complete_event</code>               (<code>CompleteEvent</code>)           \u2013            <p>The completion event (unused).</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Completion</code> (              <code>Completion</code> )          \u2013            <p>A <code>prompt_toolkit</code> <code>Completion</code> object.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def get_completions(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    document: Document,\n    _complete_event: CompleteEvent,\n) -&gt; Iterator[Completion]:\n    \"\"\"Yields completion suggestions for the current input.\n\n    Args:\n        document (Document): The current `prompt_toolkit` document.\n        _complete_event (CompleteEvent): The completion event (unused).\n\n    Yields:\n        Completion: A `prompt_toolkit` `Completion` object.\n    \"\"\"\n    text = document.text_before_cursor\n    try:\n        words: list[str] = shlex.split(text)\n    except ValueError:\n        return\n    if text.endswith(\" \") or not text:\n        words.append(\"\")\n    current = words[-1]\n\n    found = False\n\n    if current.startswith(\"-\"):\n        for opt in GLOBAL_OPTS:\n            if opt.startswith(current):\n                found = True\n                yield Completion(opt, start_position=-len(current))\n\n    cmd_obj, _rem = self._find(words[:-1])\n    if cmd_obj is None:\n        for b in self._BUILTINS:\n            if b.startswith(current):\n                found = True\n                yield Completion(b, start_position=-len(current))\n\n    if cmd_obj is None:\n        for key in self._cmd_map:\n            if len(key) == 1 and key[0].startswith(current):\n                found = True\n                yield Completion(key[0], start_position=-len(current))\n        return\n\n    if isinstance(cmd_obj, typer.Typer):\n        names = [c.name for c in getattr(cmd_obj, \"registered_commands\", [])]\n        names += [g.name for g in getattr(cmd_obj, \"registered_groups\", [])]\n        for n in names:\n            if n.startswith(current):\n                found = True\n                yield Completion(n, start_position=-len(current))\n\n    if not isinstance(cmd_obj, typer.Typer) and hasattr(cmd_obj, \"params\"):\n        for param in cmd_obj.params:\n            for opt in (*param.opts, *(getattr(param, \"secondary_opts\", []) or [])):\n                if opt.startswith(current):\n                    found = True\n                    yield Completion(opt, start_position=-len(current))\n\n    if \"--help\".startswith(current):\n        found = True\n        yield Completion(\"--help\", start_position=-len(current))\n\n    if not found:\n        if (\n            len(words) &gt;= 3\n            and words[0] == \"config\"\n            and words[1] == \"set\"\n            and words[2] == \"\"\n        ):\n            yield Completion(\"KEY=VALUE\", display=\"KEY=VALUE\", start_position=0)\n        elif current == \"\":\n            yield Completion(\"DUMMY\", display=\"DUMMY\", start_position=0)\n</code></pre>"},{"location":"reference/commands/repl/#bijux_cli.commands.repl.get_prompt","title":"<code>get_prompt() -&gt; str | ANSI</code>","text":"<p>Returns the REPL prompt string.</p> <p>The prompt is styled with ANSI colors unless <code>NO_COLOR</code> or a test mode environment variable is set.</p> <p>Returns:</p> <ul> <li> <code>str | ANSI</code>           \u2013            <p>str | ANSI: The prompt string, which may include ANSI color codes.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def get_prompt() -&gt; str | ANSI:\n    \"\"\"Returns the REPL prompt string.\n\n    The prompt is styled with ANSI colors unless `NO_COLOR` or a test mode\n    environment variable is set.\n\n    Returns:\n        str | ANSI: The prompt string, which may include ANSI color codes.\n    \"\"\"\n    if os.environ.get(\"BIJUXCLI_TEST_MODE\") == \"1\" or os.environ.get(\"NO_COLOR\") == \"1\":\n        return \"bijux&gt; \"\n    return ANSI(\"\\x1b[36mbijux&gt; \\x1b[0m\")\n</code></pre>"},{"location":"reference/commands/repl/#bijux_cli.commands.repl.main","title":"<code>main(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('human', '-f', '--format', help=HELP_FORMAT_HELP), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint for the <code>bijux repl</code> command.</p> <p>This function initializes the REPL environment. It validates flags, sets up signal handlers for clean shutdown, and dispatches to either the non-interactive (piped) mode or the interactive async prompt loop.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, forces non-interactive mode and suppresses prompts and command output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, enables verbose output for subcommands.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('human', '-f', '--format', help=HELP_FORMAT_HELP)</code> )           \u2013            <p>The desired output format. Only \"human\" is supported for the REPL itself.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, enables pretty-printing for subcommands.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics for subcommands.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>@repl_app.callback(invoke_without_command=True)\ndef main(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"human\", \"-f\", \"--format\", help=HELP_FORMAT_HELP),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux repl` command.\n\n    This function initializes the REPL environment. It validates flags, sets\n    up signal handlers for clean shutdown, and dispatches to either the\n    non-interactive (piped) mode or the interactive async prompt loop.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, forces non-interactive mode and suppresses\n            prompts and command output.\n        verbose (bool): If True, enables verbose output for subcommands.\n        fmt (str): The desired output format. Only \"human\" is supported for\n            the REPL itself.\n        pretty (bool): If True, enables pretty-printing for subcommands.\n        debug (bool): If True, enables debug diagnostics for subcommands.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"repl\"\n    effective_include_runtime = (verbose or debug) and not quiet\n\n    fmt_lower = fmt.strip().lower()\n\n    if fmt_lower != \"human\":\n        validate_common_flags(\n            fmt_lower,\n            command,\n            quiet,\n            include_runtime=effective_include_runtime,\n        )\n        emit_error_and_exit(\n            \"REPL only supports human format.\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    for sig in (\n        signal.SIGINT,\n        signal.SIGTERM,\n        signal.SIGHUP,\n        signal.SIGQUIT,\n        signal.SIGUSR1,\n    ):\n        with suppress(Exception):\n            signal.signal(sig, _exit_on_signal)\n\n    if quiet or not sys.stdin.isatty():\n        _run_piped(quiet)\n    else:\n        try:\n            asyncio.get_event_loop()\n        except RuntimeError:\n            asyncio.set_event_loop(asyncio.new_event_loop())\n\n        asyncio.run(_run_interactive())\n</code></pre>"},{"location":"reference/commands/sleep/","title":"Sleep Command API Reference","text":"<p>This section documents the internals of the <code>sleep</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/sleep/#bijux_cli.commands.sleep","title":"<code>bijux_cli.commands.sleep</code>","text":"<p>Implements the <code>sleep</code> command for the Bijux CLI.</p> <p>This module provides a simple command to pause execution for a specified duration. It is primarily used for scripting, testing, or rate-limiting operations within automated workflows. The command returns a structured payload confirming the duration slept.</p> Output Contract <ul> <li>Success: <code>{\"slept\": float}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or configuration-related error.</li> <li><code>2</code>: Invalid argument (e.g., negative duration) or timeout exceeded.</li> </ul>"},{"location":"reference/commands/sleep/#bijux_cli.commands.sleep.sleep","title":"<code>sleep(ctx: typer.Context, seconds: float = typer.Option(..., '--seconds', '-s', help='Duration in seconds (must be \u2265 0)'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux sleep</code> command.</p> <p>This function validates the requested sleep duration against configuration limits, pauses execution, and then emits a structured payload confirming the duration.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>Option(..., '--seconds', '-s', help='Duration in seconds (must be \u2265 0)')</code> )           \u2013            <p>The duration in seconds to pause execution. Must be non-negative and not exceed the configured command timeout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a contract-compliant status code and payload upon any error, such as a negative sleep duration or a timeout violation.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/sleep.py</code> <pre><code>@sleep_app.callback(invoke_without_command=True)\ndef sleep(\n    ctx: typer.Context,\n    seconds: float = typer.Option(\n        ..., \"--seconds\", \"-s\", help=\"Duration in seconds (must be \u2265 0)\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux sleep` command.\n\n    This function validates the requested sleep duration against configuration\n    limits, pauses execution, and then emits a structured payload confirming\n    the duration.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        seconds (float): The duration in seconds to pause execution. Must be\n            non-negative and not exceed the configured command timeout.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a contract-compliant status code and payload\n            upon any error, such as a negative sleep duration or a timeout\n            violation.\n    \"\"\"\n    command = \"sleep\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if seconds &lt; 0:\n        emit_error_and_exit(\n            \"sleep length must be non-negative\",\n            code=2,\n            failure=\"negative\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    cfg: ConfigProtocol = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        timeout = float(cfg.get(\"BIJUXCLI_COMMAND_TIMEOUT\", DEFAULT_COMMAND_TIMEOUT))\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to read timeout: {exc}\",\n            code=1,\n            failure=\"config\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if seconds &gt; timeout:\n        emit_error_and_exit(\n            \"Command timed out because sleep duration exceeded the configured timeout.\",\n            code=2,\n            failure=\"timeout\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    time.sleep(seconds)\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, seconds),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/status/","title":"Status Command API Reference","text":"<p>This section documents the internals of the <code>status</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/status/#bijux_cli.commands.status","title":"<code>bijux_cli.commands.status</code>","text":"<p>Implements the <code>status</code> command for the Bijux CLI.</p> <p>This module provides a lightweight \"liveness probe\" for the CLI, designed for health checks and monitoring. In its default mode, it performs a quick check and returns a simple \"ok\" status. It also supports a continuous \"watch\" mode that emits status updates at a regular interval.</p> Output Contract <ul> <li>Success:          <code>{\"status\": \"ok\"}</code></li> <li>Verbose:          Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Watch Mode Tick:  <code>{\"status\": \"ok\", \"ts\": float, ...}</code></li> <li>Watch Mode Stop:  <code>{\"status\": \"watch-stopped\", ...}</code></li> <li>Error:            <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or fatal error during execution.</li> <li><code>2</code>: Invalid argument (e.g., bad watch interval or format).</li> <li><code>3</code>: ASCII encoding error.</li> </ul>"},{"location":"reference/commands/status/#bijux_cli.commands.status.status","title":"<code>status(ctx: typer.Context, watch: float | None = typer.Option(None, '--watch', help='Poll every N seconds'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux status</code> command.</p> <p>This function orchestrates the status check. It validates flags and then dispatches to either the single-run logic or the continuous watch mode based on the presence of the <code>--watch</code> flag.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>watch</code>               (<code>float | None</code>, default:                   <code>Option(None, '--watch', help='Poll every N seconds')</code> )           \u2013            <p>If provided, enters watch mode, polling at this interval in seconds. Must be a positive number.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Watch mode only supports \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a contract-compliant status code and payload upon any error, such as an invalid watch interval.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/status.py</code> <pre><code>@status_app.callback(invoke_without_command=True)\ndef status(\n    ctx: typer.Context,\n    watch: float | None = typer.Option(None, \"--watch\", help=\"Poll every N seconds\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux status` command.\n\n    This function orchestrates the status check. It validates flags and then\n    dispatches to either the single-run logic or the continuous watch mode\n    based on the presence of the `--watch` flag.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        watch (float | None): If provided, enters watch mode, polling at this\n            interval in seconds. Must be a positive number.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Watch mode only\n            supports \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a contract-compliant status code and payload\n            upon any error, such as an invalid watch interval.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    emitter = DIContainer.current().resolve(EmitterProtocol)\n    telemetry = DIContainer.current().resolve(TelemetryProtocol)\n    command = \"status\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if watch is not None:\n        try:\n            interval = float(watch)\n            if interval &lt;= 0:\n                raise ValueError\n        except (ValueError, TypeError):\n            emit_error_and_exit(\n                \"Invalid watch interval: must be &gt; 0\",\n                code=2,\n                failure=\"interval\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n        _run_watch_mode(\n            command=command,\n            watch_interval=interval,\n            fmt=fmt_lower,\n            quiet=quiet,\n            verbose=verbose,\n            debug=debug,\n            effective_pretty=pretty,\n            include_runtime=verbose,\n            telemetry=telemetry,\n            emitter=emitter,\n        )\n    else:\n        new_run_command(\n            command_name=command,\n            payload_builder=lambda include: _build_payload(include),\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/utilities/","title":"Utilities Command API Reference","text":"<p>This section documents the internals of the <code>utilities</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities","title":"<code>bijux_cli.commands.utilities</code>","text":"<p>Provides shared, reusable utilities for Bijux CLI commands.</p> <p>This module centralizes common logic to ensure consistency and reduce code duplication across the various command implementations. It includes a suite of functions for handling standard CLI tasks, such as:</p> <ul> <li>Validation: Functions for validating common CLI flags (like <code>--format</code>)     and checking the environment for non-ASCII characters or malformed     configuration files.</li> <li>Output &amp; Exit: A set of high-level emitters (<code>emit_and_exit</code>,     <code>emit_error_and_exit</code>) that handle payload serialization (JSON/YAML),     pretty-printing, and terminating the application with a contract-compliant     exit code and structured message.</li> <li>Command Orchestration: A primary helper (<code>new_run_command</code>) that     encapsulates the standard lifecycle of a command: validation, payload     construction, and emission.</li> <li>Parsing &amp; Sanitization: Helpers for sanitizing strings to be ASCII-safe     and a pre-parser for global flags (<code>--quiet</code>, <code>--debug</code>, etc.) that     operates before Typer's main dispatch.</li> <li>Plugin Management: Utilities for discovering and listing installed     plugins from the filesystem.</li> </ul>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.ascii_safe","title":"<code>ascii_safe(text: Any, _field: str = '') -&gt; str</code>","text":"<p>Converts any value to a string containing only printable ASCII characters.</p> <p>Non-ASCII characters are replaced with '?'. Newlines, carriage returns, and tabs are preserved.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>Any</code>)           \u2013            <p>The value to sanitize.</p> </li> <li> <code>_field</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An unused parameter for potential future use in context or telemetry. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>An ASCII-safe string.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def ascii_safe(text: Any, _field: str = \"\") -&gt; str:\n    \"\"\"Converts any value to a string containing only printable ASCII characters.\n\n    Non-ASCII characters are replaced with '?'. Newlines, carriage returns,\n    and tabs are preserved.\n\n    Args:\n        text (Any): The value to sanitize.\n        _field (str, optional): An unused parameter for potential future use\n            in context or telemetry. Defaults to \"\".\n\n    Returns:\n        str: An ASCII-safe string.\n    \"\"\"\n    text_str = text if isinstance(text, str) else str(text)\n\n    return \"\".join(\n        ch if (32 &lt;= ord(ch) &lt;= 126) or ch in _ALLOWED_CTRL else \"?\" for ch in text_str\n    )\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.contains_non_ascii_env","title":"<code>contains_non_ascii_env() -&gt; bool</code>","text":"<p>Checks for non-ASCII characters in the CLI's environment.</p> <p>This function returns True if any of the following are detected: * The <code>BIJUXCLI_CONFIG</code> environment variable contains non-ASCII characters. * The file path pointed to by <code>BIJUXCLI_CONFIG</code> exists and its contents     cannot be decoded as ASCII. * Any environment variable with a name starting with <code>BIJUXCLI_</code> has a     value containing non-ASCII characters.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a non-ASCII condition is found, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def contains_non_ascii_env() -&gt; bool:\n    \"\"\"Checks for non-ASCII characters in the CLI's environment.\n\n    This function returns True if any of the following are detected:\n    * The `BIJUXCLI_CONFIG` environment variable contains non-ASCII characters.\n    * The file path pointed to by `BIJUXCLI_CONFIG` exists and its contents\n        cannot be decoded as ASCII.\n    * Any environment variable with a name starting with `BIJUXCLI_` has a\n        value containing non-ASCII characters.\n\n    Returns:\n        bool: True if a non-ASCII condition is found, otherwise False.\n    \"\"\"\n    config_path_str = os.environ.get(\"BIJUXCLI_CONFIG\")\n    if config_path_str:\n        if not config_path_str.isascii():\n            return True\n        config_path = Path(config_path_str)\n        if config_path.exists():\n            try:\n                config_path.read_text(encoding=\"ascii\")\n            except UnicodeDecodeError:\n                return True\n            except (IsADirectoryError, PermissionError, FileNotFoundError, OSError):\n                pass\n\n    for k, v in os.environ.items():\n        if k.startswith(\"BIJUXCLI_\") and not v.isascii():\n            return True\n    return False\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.emit_and_exit","title":"<code>emit_and_exit(payload: Mapping[str, Any], fmt: OutputFormat, effective_pretty: bool, verbose: bool, debug: bool, quiet: bool, command: str, *, exit_code: int = 0) -&gt; NoReturn</code>","text":"<p>Serializes and emits a payload, records history, and exits.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>The data to serialize and print.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The output format (JSON or YAML).</p> </li> <li> <code>effective_pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime info in history records.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, emits a diagnostic message to stderr.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses all output and exits immediately.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The command name, used for history tracking.</p> </li> <li> <code>exit_code</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The exit status code to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with <code>exit_code</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def emit_and_exit(\n    payload: Mapping[str, Any],\n    fmt: OutputFormat,\n    effective_pretty: bool,\n    verbose: bool,\n    debug: bool,\n    quiet: bool,\n    command: str,\n    *,\n    exit_code: int = 0,\n) -&gt; NoReturn:\n    \"\"\"Serializes and emits a payload, records history, and exits.\n\n    Args:\n        payload (Mapping[str, Any]): The data to serialize and print.\n        fmt (OutputFormat): The output format (JSON or YAML).\n        effective_pretty (bool): If True, pretty-prints the output.\n        verbose (bool): If True, includes runtime info in history records.\n        debug (bool): If True, emits a diagnostic message to stderr.\n        quiet (bool): If True, suppresses all output and exits immediately.\n        command (str): The command name, used for history tracking.\n        exit_code (int): The exit status code to use.\n\n    Raises:\n        SystemExit: Always exits the process with `exit_code`.\n    \"\"\"\n    if (not quiet) and (not command.startswith(\"history\")):\n        try:\n            from bijux_cli.contracts import HistoryProtocol\n            from bijux_cli.core.di import DIContainer\n\n            hist = DIContainer.current().resolve(HistoryProtocol)\n            hist.add(\n                command=command,\n                params=[],\n                success=(exit_code == 0),\n                return_code=exit_code,\n                duration_ms=0.0,\n            )\n        except PermissionError as exc:\n            print(f\"Permission denied writing history: {exc}\", file=sys.stderr)\n        except OSError as exc:\n            import errno as _errno\n\n            if exc.errno in (_errno.EACCES, _errno.EPERM):\n                print(f\"Permission denied writing history: {exc}\", file=sys.stderr)\n            elif exc.errno in (_errno.ENOSPC, _errno.EDQUOT):\n                print(\n                    f\"No space left on device while writing history: {exc}\",\n                    file=sys.stderr,\n                )\n            else:\n                print(f\"Error writing history: {exc}\", file=sys.stderr)\n        except Exception as exc:\n            print(f\"Error writing history: {exc}\", file=sys.stderr)\n\n    if quiet:\n        sys.exit(exit_code)\n\n    if debug:\n        print(\"Diagnostics: emitted payload\", file=sys.stderr)\n\n    indent = 2 if effective_pretty else None\n    if fmt == OutputFormat.JSON:\n        separators = (\", \", \": \") if effective_pretty else (\",\", \":\")\n        output = json.dumps(payload, indent=indent, separators=separators)\n    else:\n        default_flow_style = None if effective_pretty else True\n        output = yaml.safe_dump(\n            payload,\n            indent=indent,\n            sort_keys=False,\n            default_flow_style=default_flow_style,\n        )\n    cleaned = output.rstrip(\"\\n\")\n    print(cleaned)\n    sys.exit(exit_code)\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.emit_error_and_exit","title":"<code>emit_error_and_exit(message: str, code: int, failure: str, command: str | None = None, fmt: str | None = None, quiet: bool = False, include_runtime: bool = False, debug: bool = False, extra: dict[str, Any] | None = None) -&gt; NoReturn</code>","text":"<p>Emits a structured error payload to stderr and exits the process.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The primary error message.</p> </li> <li> <code>code</code>               (<code>int</code>)           \u2013            <p>The exit status code.</p> </li> <li> <code>failure</code>               (<code>str</code>)           \u2013            <p>A short, machine-readable failure code.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The command name where the error occurred.</p> </li> <li> <code>fmt</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format context.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses all output and exits immediately.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, adds runtime info to the error payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, prints a full traceback to stderr.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to merge into the payload.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with the specified <code>code</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def emit_error_and_exit(\n    message: str,\n    code: int,\n    failure: str,\n    command: str | None = None,\n    fmt: str | None = None,\n    quiet: bool = False,\n    include_runtime: bool = False,\n    debug: bool = False,\n    extra: dict[str, Any] | None = None,\n) -&gt; NoReturn:\n    \"\"\"Emits a structured error payload to stderr and exits the process.\n\n    Args:\n        message (str): The primary error message.\n        code (int): The exit status code.\n        failure (str): A short, machine-readable failure code.\n        command (str | None): The command name where the error occurred.\n        fmt (str | None): The output format context.\n        quiet (bool): If True, suppresses all output and exits immediately.\n        include_runtime (bool): If True, adds runtime info to the error payload.\n        debug (bool): If True, prints a full traceback to stderr.\n        extra (dict[str, Any] | None): Additional fields to merge into the payload.\n\n    Raises:\n        SystemExit: Always exits the process with the specified `code`.\n    \"\"\"\n    if quiet:\n        sys.exit(code)\n\n    if debug:\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n    error_payload = {\"error\": message, \"code\": code}\n    if failure:\n        error_payload[\"failure\"] = failure\n    if command:\n        error_payload[\"command\"] = command\n    if fmt:\n        error_payload[\"fmt\"] = fmt\n    if extra:\n        error_payload.update(extra)\n    if include_runtime:\n        error_payload[\"python\"] = ascii_safe(sys.version.split()[0], \"python_version\")\n        error_payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        error_payload[\"timestamp\"] = str(time.time())\n\n    try:\n        output = json.dumps(error_payload).rstrip(\"\\n\")\n        print(output, file=sys.stderr, flush=True)\n    except Exception:\n        print('{\"error\": \"Unserializable error\"}', file=sys.stderr, flush=True)\n    sys.exit(code)\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.handle_list_plugins","title":"<code>handle_list_plugins(command: str, quiet: bool, verbose: bool, fmt: str, pretty: bool, debug: bool) -&gt; None</code>","text":"<p>Handles the logic for commands that list installed plugins.</p> <p>This function serves as a common handler for <code>plugins list</code> and similar commands. It retrieves the list of plugins and uses <code>new_run_command</code> to emit the result.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The name of the command being executed.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses normal output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in the payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def handle_list_plugins(\n    command: str,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Handles the logic for commands that list installed plugins.\n\n    This function serves as a common handler for `plugins list` and similar\n    commands. It retrieves the list of plugins and uses `new_run_command`\n    to emit the result.\n\n    Args:\n        command (str): The name of the command being executed.\n        quiet (bool): If True, suppresses normal output.\n        verbose (bool): If True, includes runtime metadata in the payload.\n        fmt (str): The requested output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug mode.\n\n    Returns:\n        None:\n    \"\"\"\n    format_lower = validate_common_flags(fmt, command, quiet)\n\n    try:\n        plugins = list_installed_plugins()\n    except RuntimeError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=1,\n            failure=\"dir_error\",\n            command=command,\n            fmt=format_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    else:\n\n        def _build_payload(include: bool) -&gt; dict[str, object]:\n            \"\"\"Constructs a payload describing installed plugins.\n\n            Args:\n                include (bool): If True, includes Python/platform info.\n\n            Returns:\n                dict[str, object]: A dictionary containing a \"plugins\" list\n                    and optional runtime metadata.\n            \"\"\"\n            payload: dict[str, object] = {\"plugins\": plugins}\n            if include:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=_build_payload,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=format_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.list_installed_plugins","title":"<code>list_installed_plugins() -&gt; list[str]</code>","text":"<p>Scans the plugins directory and returns a list of installed plugin names.</p> <p>A directory is considered a valid plugin if it is a direct child of the plugins directory and contains a <code>plugin.py</code> file.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A sorted list of valid plugin names.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the plugins directory is invalid, inaccessible, is not a directory, or contains a symlink loop.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def list_installed_plugins() -&gt; list[str]:\n    \"\"\"Scans the plugins directory and returns a list of installed plugin names.\n\n    A directory is considered a valid plugin if it is a direct child of the\n    plugins directory and contains a `plugin.py` file.\n\n    Returns:\n        list[str]: A sorted list of valid plugin names.\n\n    Raises:\n        RuntimeError: If the plugins directory is invalid, inaccessible,\n            is not a directory, or contains a symlink loop.\n    \"\"\"\n    plugins_dir = get_plugins_dir()\n\n    try:\n        resolved = plugins_dir.resolve(strict=True)\n    except FileNotFoundError:\n        return []\n    except RuntimeError as e:\n        raise RuntimeError(f\"Symlink loop detected at '{plugins_dir}'.\") from e\n    except Exception as exc:\n        raise RuntimeError(\n            f\"Plugins directory '{plugins_dir}' invalid or inaccessible.\"\n        ) from exc\n\n    if not resolved.is_dir():\n        raise RuntimeError(f\"Plugins directory '{plugins_dir}' is not a directory.\")\n\n    plugins: list[str] = []\n    for entry in resolved.iterdir():\n        with suppress(Exception):\n            p = entry.resolve()\n            if p.is_dir() and (p / \"plugin.py\").is_file():\n                plugins.append(entry.name)\n\n    plugins.sort()\n    return plugins\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.new_run_command","title":"<code>new_run_command(command_name: str, payload_builder: Callable[[bool], Mapping[str, object]], quiet: bool, verbose: bool, fmt: str, pretty: bool, debug: bool, exit_code: int = 0) -&gt; NoReturn</code>","text":"<p>Orchestrates the standard execution flow of a CLI command.</p> <p>This function handles dependency resolution, validation, payload construction, and final emission, ensuring a consistent lifecycle for all commands that use it.</p> <p>Parameters:</p> <ul> <li> <code>command_name</code>               (<code>str</code>)           \u2013            <p>The name of the command for telemetry/error context.</p> </li> <li> <code>payload_builder</code>               (<code>Callable[[bool], Mapping[str, object]]</code>)           \u2013            <p>A function that takes a boolean <code>include_runtime</code> and returns the command's structured output payload.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses normal output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug-level output.</p> </li> <li> <code>exit_code</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The exit code to use on successful execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with the given <code>exit_code</code> or an appropriate error code on failure.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def new_run_command(\n    command_name: str,\n    payload_builder: Callable[[bool], Mapping[str, object]],\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n    exit_code: int = 0,\n) -&gt; NoReturn:\n    \"\"\"Orchestrates the standard execution flow of a CLI command.\n\n    This function handles dependency resolution, validation, payload\n    construction, and final emission, ensuring a consistent lifecycle for all\n    commands that use it.\n\n    Args:\n        command_name (str): The name of the command for telemetry/error context.\n        payload_builder: A function that takes a boolean `include_runtime` and\n            returns the command's structured output payload.\n        quiet (bool): If True, suppresses normal output.\n        verbose (bool): If True, includes runtime metadata in the output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug-level output.\n        exit_code (int): The exit code to use on successful execution.\n\n    Raises:\n        SystemExit: Always exits the process with the given `exit_code` or an\n            appropriate error code on failure.\n    \"\"\"\n    from bijux_cli.contracts import EmitterProtocol, TelemetryProtocol\n    from bijux_cli.core.di import DIContainer\n\n    DIContainer.current().resolve(EmitterProtocol)\n    DIContainer.current().resolve(TelemetryProtocol)\n\n    include_runtime = verbose or debug\n\n    format_lower = validate_common_flags(\n        fmt,\n        command_name,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    output_format = OutputFormat.YAML if format_lower == \"yaml\" else OutputFormat.JSON\n    effective_pretty = debug or pretty\n\n    try:\n        payload = payload_builder(include_runtime)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command_name,\n            fmt=output_format,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    else:\n        emit_and_exit(\n            payload=payload,\n            fmt=output_format,\n            effective_pretty=effective_pretty,\n            verbose=verbose,\n            debug=debug,\n            quiet=quiet,\n            command=command_name,\n            exit_code=exit_code,\n        )\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.normalize_format","title":"<code>normalize_format(fmt: str | None) -&gt; str</code>","text":"<p>Normalizes a format string to lowercase and removes whitespace.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str | None</code>)           \u2013            <p>The format string to normalize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The normalized format string, or an empty string if input is None.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def normalize_format(fmt: str | None) -&gt; str:\n    \"\"\"Normalizes a format string to lowercase and removes whitespace.\n\n    Args:\n        fmt (str | None): The format string to normalize.\n\n    Returns:\n        str: The normalized format string, or an empty string if input is None.\n    \"\"\"\n    return (fmt or \"\").strip().lower()\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.parse_global_flags","title":"<code>parse_global_flags() -&gt; dict[str, Any]</code>","text":"<p>Parses global CLI flags from <code>sys.argv</code> before Typer dispatch.</p> <p>This function inspects and consumes known global flags, rewriting <code>sys.argv</code> to contain only the remaining arguments. This allows global settings to be processed independently of the command-specific parsing done by Typer.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary of parsed flag values, such as <code>help</code>, <code>quiet</code>, <code>debug</code>, <code>verbose</code>, <code>format</code>, and <code>pretty</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If a flag requires an argument that is missing (e.g., <code>--format</code> with no value).</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def parse_global_flags() -&gt; dict[str, Any]:\n    \"\"\"Parses global CLI flags from `sys.argv` before Typer dispatch.\n\n    This function inspects and consumes known global flags, rewriting `sys.argv`\n    to contain only the remaining arguments. This allows global settings to be\n    processed independently of the command-specific parsing done by Typer.\n\n    Returns:\n        dict[str, Any]: A dictionary of parsed flag values, such as `help`,\n            `quiet`, `debug`, `verbose`, `format`, and `pretty`.\n\n    Raises:\n        SystemExit: If a flag requires an argument that is missing (e.g.,\n            `--format` with no value).\n    \"\"\"\n    argv = sys.argv[1:]\n    flags: dict[str, Any] = {\n        \"help\": False,\n        \"quiet\": False,\n        \"debug\": False,\n        \"verbose\": False,\n        \"format\": \"json\",\n        \"pretty\": True,\n    }\n    retained: list[str] = []\n\n    def _bail(msg: str, failure: str) -&gt; NoReturn:\n        \"\"\"Emits a standardized error and exits with code 2.\n\n        Args:\n            msg (str): The error message to report.\n            failure (str): A short failure code (e.g., \"missing_argument\").\n\n        Raises:\n            SystemExit: Always exits the process.\n        \"\"\"\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=failure,\n            command=\"global\",\n            fmt=flags[\"format\"],\n            quiet=flags[\"quiet\"],\n            include_runtime=flags[\"verbose\"],\n            debug=flags[\"debug\"],\n        )\n\n    i = 0\n    while i &lt; len(argv):\n        tok = argv[i]\n\n        if tok in (\"-h\", \"--help\"):\n            flags[\"help\"] = True\n            retained.append(tok)\n            i += 1\n        elif tok in (\"-q\", \"--quiet\"):\n            flags[\"quiet\"] = True\n            i += 1\n        elif tok == \"--debug\":\n            flags[\"debug\"] = True\n            flags[\"verbose\"] = True\n            flags[\"pretty\"] = True\n            i += 1\n        elif tok in (\"-v\", \"--verbose\"):\n            flags[\"verbose\"] = True\n            i += 1\n        elif tok == \"--pretty\":\n            flags[\"pretty\"] = True\n            i += 1\n        elif tok == \"--no-pretty\":\n            flags[\"pretty\"] = False\n            i += 1\n        elif tok in (\"-f\", \"--format\"):\n            i += 1\n            if i &gt;= len(argv):\n                _bail(\"Missing argument for --format\", \"missing_argument\")\n            else:\n                value = argv[i].lower()\n                flags[\"format\"] = value\n                if flags[\"help\"]:\n                    retained.append(tok.lstrip(\"-\"))\n                    retained.append(argv[i])\n                if not flags[\"help\"] and value not in (\"json\", \"yaml\"):\n                    _bail(f\"Unsupported format: {value}\", \"invalid_format\")\n                i += 1\n        else:\n            retained.append(tok)\n            i += 1\n\n    if flags[\"help\"]:\n        retained = [\n            arg.lstrip(\"-\") if arg.startswith(\"-\") and arg not in KNOWN else arg\n            for arg in retained\n        ]\n\n    sys.argv = [sys.argv[0], *retained]\n    return flags\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.validate_common_flags","title":"<code>validate_common_flags(fmt: str, command: str, quiet: bool, include_runtime: bool = False) -&gt; str</code>","text":"<p>Validates common CLI flags and environment settings.</p> <p>This function ensures the format is supported and the environment is ASCII-safe, exiting with a structured error if validation fails.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The name of the command for error reporting context.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses output on error before exiting.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, includes runtime info in error payloads.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The validated and normalized format string (\"json\" or \"yaml\").</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with code 2 for an unsupported format or 3 for a non-ASCII environment.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def validate_common_flags(\n    fmt: str,\n    command: str,\n    quiet: bool,\n    include_runtime: bool = False,\n) -&gt; str:\n    \"\"\"Validates common CLI flags and environment settings.\n\n    This function ensures the format is supported and the environment is\n    ASCII-safe, exiting with a structured error if validation fails.\n\n    Args:\n        fmt (str): The requested output format.\n        command (str): The name of the command for error reporting context.\n        quiet (bool): If True, suppresses output on error before exiting.\n        include_runtime (bool): If True, includes runtime info in error payloads.\n\n    Returns:\n        str: The validated and normalized format string (\"json\" or \"yaml\").\n\n    Raises:\n        SystemExit: Exits with code 2 for an unsupported format or 3 for\n            a non-ASCII environment.\n    \"\"\"\n    format_lower = (fmt or \"\").lower()\n    if format_lower not in (\"json\", \"yaml\"):\n        emit_error_and_exit(\n            f\"Unsupported format: {fmt}\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=format_lower or \"json\",\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=False,\n        )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII in configuration or environment\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=format_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=False,\n        )\n\n    return format_lower\n</code></pre>"},{"location":"reference/commands/utilities/#bijux_cli.commands.utilities.validate_env_file_if_present","title":"<code>validate_env_file_if_present(path_str: str) -&gt; None</code>","text":"<p>Validates the syntax of an environment configuration file if it exists.</p> <p>Checks that every non-comment, non-blank line conforms to a <code>KEY=VALUE</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>The path to the environment file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the file cannot be read or contains a malformed line.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def validate_env_file_if_present(path_str: str) -&gt; None:\n    \"\"\"Validates the syntax of an environment configuration file if it exists.\n\n    Checks that every non-comment, non-blank line conforms to a `KEY=VALUE`\n    pattern.\n\n    Args:\n        path_str (str): The path to the environment file.\n\n    Raises:\n        ValueError: If the file cannot be read or contains a malformed line.\n    \"\"\"\n    if not path_str or not Path(path_str).exists():\n        return\n    try:\n        text = Path(path_str).read_text(encoding=\"utf-8\", errors=\"strict\")\n    except Exception as exc:\n        raise ValueError(f\"Cannot read config file: {exc}\") from exc\n\n    for i, line in enumerate(text.splitlines(), start=1):\n        s = line.strip()\n        if s and not s.startswith(\"#\") and not _ENV_LINE_RX.match(s):\n            raise ValueError(f\"Malformed line {i} in config: {line!r}\")\n</code></pre>"},{"location":"reference/commands/version/","title":"Version Command API Reference","text":"<p>This section documents the internals of the <code>version</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/version/#bijux_cli.commands.version","title":"<code>bijux_cli.commands.version</code>","text":"<p>Implements the <code>version</code> command for the Bijux CLI.</p> <p>This module reports the CLI's version and runtime environment information. The output is machine-readable, available in JSON or YAML, and is designed to be safe for automation and scripting by adhering to a strict output contract and ASCII hygiene.</p> Output Contract <ul> <li>Success: <code>{\"version\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str, \"timestamp\": float}</code>.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or fatal error.</li> <li><code>2</code>: CLI argument, flag, or format error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/version/#bijux_cli.commands.version.version","title":"<code>version(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint and logic for the <code>bijux version</code> command.</p> <p>This function orchestrates the version reporting process by validating flags and then using the shared <code>new_run_command</code> helper to build and emit the final payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output; the exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python, platform, and timestamp details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/version.py</code> <pre><code>@version_app.callback(invoke_without_command=True)\ndef version(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux version` command.\n\n    This function orchestrates the version reporting process by validating\n    flags and then using the shared `new_run_command` helper to build and\n    emit the final payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output; the exit code is the\n            primary indicator of the outcome.\n        verbose (bool): If True, includes Python, platform, and timestamp\n            details in the output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    DIContainer.current().resolve(EmitterProtocol)\n    DIContainer.current().resolve(TelemetryProtocol)\n    command = \"version\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/clear/","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/clear/#bijux_cli.commands.config.clear","title":"<code>bijux_cli.commands.config.clear</code>","text":"<p>Implements the <code>config clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for completely erasing all key-value pairs from the active configuration store. This action is irreversible and effectively resets the configuration to an empty state. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while clearing the configuration.</li> </ul>"},{"location":"reference/commands/config/clear/#bijux_cli.commands.config.clear.clear_config","title":"<code>clear_config(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Clears all configuration settings from the active store.</p> <p>This command erases all key-value pairs, effectively resetting the configuration. It emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/clear.py</code> <pre><code>def clear_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Clears all configuration settings from the active store.\n\n    This command erases all key-value pairs, effectively resetting the\n    configuration. It emits a structured payload to confirm the operation.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config clear\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear config: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration clear.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"cleared\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/export/","title":"Export Command API Reference","text":"<p>This section documents the internals of the <code>export</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/export/#bijux_cli.commands.config.export","title":"<code>bijux_cli.commands.config.export</code>","text":"<p>Implements the <code>config export</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for exporting the application's entire current configuration to a specified destination, which can be a file or standard output. The output format can be explicitly set to 'env', 'json', or 'yaml', or it can be inferred from the destination file's extension.</p> Output Contract <ul> <li>Success (to file):   <code>{\"status\": \"exported\", \"file\": str, \"format\": str}</code></li> <li>Success (to stdout): The raw exported configuration data is printed directly.</li> <li>Verbose (to file):   Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:               <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code> or <code>2</code>: An error occurred during the export process, such as a file   write error or invalid format request.</li> </ul>"},{"location":"reference/commands/config/export/#bijux_cli.commands.config.export.export_config","title":"<code>export_config(ctx: typer.Context, path: str = typer.Argument(..., help='Destination file \u2013 use \u201c-\u201d to write to STDOUT'), out_fmt: str = typer.Option(None, '--out-format', help='Force output format: env | json | yaml'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Exports the current configuration to a file or standard output.</p> <p>This function writes all configuration key-value pairs to a specified destination. If the destination is a file path, a structured JSON/YAML confirmation message is printed to stdout upon success. If the destination is \"-\", the raw exported configuration is printed directly to stdout.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Destination file \u2013 use \u201c-\u201d to write to STDOUT')</code> )           \u2013            <p>The destination file path, or \"-\" for standard output.</p> </li> <li> <code>out_fmt</code>               (<code>str</code>, default:                   <code>Option(None, '--out-format', help='Force output format: env | json | yaml')</code> )           \u2013            <p>The desired output format ('env', 'json', 'yaml'). If unspecified, it is inferred from the file extension.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the confirmation payload (file export only).</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The format for the confirmation payload (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the confirmation payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/export.py</code> <pre><code>def export_config(\n    ctx: typer.Context,\n    path: str = typer.Argument(\n        ..., help=\"Destination file \u2013 use \u201c-\u201d to write to STDOUT\"\n    ),\n    out_fmt: str = typer.Option(\n        None, \"--out-format\", help=\"Force output format: env | json | yaml\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Exports the current configuration to a file or standard output.\n\n    This function writes all configuration key-value pairs to a specified\n    destination. If the destination is a file path, a structured JSON/YAML\n    confirmation message is printed to stdout upon success. If the destination\n    is \"-\", the raw exported configuration is printed directly to stdout.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        path (str): The destination file path, or \"-\" for standard output.\n        out_fmt (str): The desired output format ('env', 'json', 'yaml'). If\n            unspecified, it is inferred from the file extension.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the\n            confirmation payload (file export only).\n        fmt (str): The format for the confirmation payload (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the confirmation payload.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config export\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.export(path, out_fmt)\n    except CommandError as exc:\n        code = 2 if getattr(exc, \"http_status\", 0) == 400 else 1\n        emit_error_and_exit(\n            f\"Failed to export config: {exc}\",\n            code=code,\n            failure=\"export_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if path != \"-\":\n\n        def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n            \"\"\"Builds the payload confirming a successful export to a file.\n\n            Args:\n                include_runtime (bool): If True, includes Python and platform info.\n\n            Returns:\n                dict[str, object]: The structured payload.\n            \"\"\"\n            payload: dict[str, object] = {\n                \"status\": \"exported\",\n                \"file\": path,\n                \"format\": out_fmt or \"auto\",\n            }\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/config/get/","title":"Get Command API Reference","text":"<p>This section documents the internals of the <code>get</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/get/#bijux_cli.commands.config.get","title":"<code>bijux_cli.commands.config.get</code>","text":"<p>Implements the <code>config get</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for retrieving the value of a specific key from the active configuration store. It provides a structured, machine-readable response containing the value or an error if the key is not found.</p> Output Contract <ul> <li>Success: <code>{\"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> <li><code>2</code>: The specified key was not found in the configuration.</li> </ul>"},{"location":"reference/commands/config/get/#bijux_cli.commands.config.get.get_config","title":"<code>get_config(ctx: typer.Context, key: str = typer.Argument(..., help='Configuration key to look up'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Retrieves the value for a given configuration key.</p> <p>This function fetches the value for the specified key from the configuration service and uses the <code>new_run_command</code> helper to emit it in a structured payload. It handles errors, such as the key not being found.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Configuration key to look up')</code> )           \u2013            <p>The configuration key whose value should be retrieved.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/get.py</code> <pre><code>def get_config(\n    ctx: typer.Context,\n    key: str = typer.Argument(..., help=\"Configuration key to look up\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Retrieves the value for a given configuration key.\n\n    This function fetches the value for the specified key from the configuration\n    service and uses the `new_run_command` helper to emit it in a structured\n    payload. It handles errors, such as the key not being found.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        key (str): The configuration key whose value should be retrieved.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config get\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        value = config_svc.get(key)\n    except CommandError as exc:\n        if str(exc).startswith(\"Config key not found\"):\n            emit_error_and_exit(\n                f\"Config key not found: {key}\",\n                code=2,\n                failure=\"not_found\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n                extra={\"key\": key},\n            )\n        emit_error_and_exit(\n            f\"Failed to get config: {exc}\",\n            code=1,\n            failure=\"get_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds a payload containing the retrieved configuration value.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: A dictionary containing the key's value and\n                optional runtime metadata.\n        \"\"\"\n        payload: dict[str, object] = {\"value\": value}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/list_cmd/","title":"List_cmd Command API Reference","text":"<p>This section documents the internals of the <code>list_cmd</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/list_cmd/#bijux_cli.commands.config.list_cmd","title":"<code>bijux_cli.commands.config.list_cmd</code>","text":"<p>Implements the <code>config list</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for listing all keys currently defined in the active configuration store. It retrieves the keys and presents them in a structured, machine-readable list format.</p> Output Contract <ul> <li>Success: <code>{\"items\": [{\"key\": str}, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> </ul>"},{"location":"reference/commands/config/list_cmd/#bijux_cli.commands.config.list_cmd.list_config","title":"<code>list_config(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Lists all configuration keys from the active configuration store.</p> <p>This function retrieves all defined keys, sorts them, and then uses the <code>new_run_command</code> helper to emit them in a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/list_cmd.py</code> <pre><code>def list_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all configuration keys from the active configuration store.\n\n    This function retrieves all defined keys, sorts them, and then uses the\n    `new_run_command` helper to emit them in a structured payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config list\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        keys = config_svc.list_keys()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list config: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; Mapping[str, object]:\n        \"\"\"Builds a payload containing the list of configuration keys.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, object]: A dictionary containing a sorted list of\n                keys under an \"items\" field, plus optional runtime metadata.\n        \"\"\"\n        payload: dict[str, object] = {\n            \"items\": [{\"key\": k} for k in sorted(keys, key=str.lower)]\n        }\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/load/","title":"Load Command API Reference","text":"<p>This section documents the internals of the <code>load</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/load/#bijux_cli.commands.config.load","title":"<code>bijux_cli.commands.config.load</code>","text":"<p>Implements the <code>config load</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for replacing the application's entire configuration with the contents of a specified file. It discards any in-memory settings and loads the new configuration, emitting a structured confirmation upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"loaded\", \"file\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>2</code>: The specified file could not be found, read, or parsed.</li> </ul>"},{"location":"reference/commands/config/load/#bijux_cli.commands.config.load.load_config","title":"<code>load_config(ctx: typer.Context, path: str = typer.Argument(..., help='Path to load from'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Loads configuration from a specified file.</p> <p>This function replaces the current in-memory configuration with the contents of the file at the given path. It provides a structured payload to confirm the operation was successful.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Path to load from')</code> )           \u2013            <p>The path to the configuration file to load.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/load.py</code> <pre><code>def load_config(\n    ctx: typer.Context,\n    path: str = typer.Argument(..., help=\"Path to load from\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Loads configuration from a specified file.\n\n    This function replaces the current in-memory configuration with the\n    contents of the file at the given path. It provides a structured payload\n    to confirm the operation was successful.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        path (str): The path to the configuration file to load.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config load\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.load(path)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to load config: {exc}\",\n            code=2,\n            failure=\"load_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"path\": path},\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration load.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"loaded\", \"file\": path}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/reload/","title":"Reload Command API Reference","text":"<p>This section documents the internals of the <code>reload</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/reload/#bijux_cli.commands.config.reload","title":"<code>bijux_cli.commands.config.reload</code>","text":"<p>Implements the <code>config reload</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for manually reloading the application's configuration from its source file on disk. It discards any in-memory settings and replaces them with the content of the configuration file, emitting a structured confirmation upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"reloaded\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>2</code>: The configuration file could not be read or parsed.</li> </ul>"},{"location":"reference/commands/config/reload/#bijux_cli.commands.config.reload.reload_config","title":"<code>reload_config(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Reloads the configuration from disk and emits a structured result.</p> <p>This function forces a refresh of the application's configuration from its persistent storage file. It is useful when the configuration has been modified externally. A success or error payload is always emitted.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/reload.py</code> <pre><code>def reload_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Reloads the configuration from disk and emits a structured result.\n\n    This function forces a refresh of the application's configuration from its\n    persistent storage file. It is useful when the configuration has been\n    modified externally. A success or error payload is always emitted.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config reload\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.reload()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to reload config: {exc}\",\n            code=2,\n            failure=\"reload_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration reload.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"reloaded\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/service/","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/service/#bijux_cli.commands.config.service","title":"<code>bijux_cli.commands.config.service</code>","text":"<p>Implements the root callback for the <code>bijux config</code> command group.</p> <p>This module defines the default action for the <code>bijux config</code> command. When invoked without a subcommand (like <code>get</code>, <code>set</code>, or <code>unset</code>), it lists all key-value pairs currently stored in the active configuration, presenting them in a structured, machine-readable format.</p> Output Contract <ul> <li>Success: <code>{\"KEY_1\": \"VALUE_1\", \"KEY_2\": \"VALUE_2\", ...}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> </ul>"},{"location":"reference/commands/config/service/#bijux_cli.commands.config.service.config","title":"<code>config(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint for the <code>bijux config</code> command group.</p> <p>This function serves as the default action when <code>bijux config</code> is run without a subcommand. It retrieves and displays all key-value pairs from the current configuration. If a subcommand (<code>get</code>, <code>set</code>, etc.) is invoked, this function yields control to it.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/config/service.py</code> <pre><code>def config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux config` command group.\n\n    This function serves as the default action when `bijux config` is run\n    without a subcommand. It retrieves and displays all key-value pairs from\n    the current configuration. If a subcommand (`get`, `set`, etc.) is\n    invoked, this function yields control to it.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    fmt_lower = fmt.lower()\n\n    command = \"config\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload containing all configuration values.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: A dictionary of all configuration key-value\n                pairs and optional runtime metadata.\n        \"\"\"\n        data = config_svc.all()\n        payload: dict[str, object] = dict(data)\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/set/","title":"Set Command API Reference","text":"<p>This section documents the internals of the <code>set</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/set/#bijux_cli.commands.config.set","title":"<code>bijux_cli.commands.config.set</code>","text":"<p>Implements the <code>config set</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for creating or updating a key-value pair in the active configuration store. It accepts input either as a direct argument or from stdin, performs strict validation on keys and values, and provides a structured, machine-readable response.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"updated\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred, such as a file lock or write failure.</li> <li><code>2</code>: An invalid argument was provided (e.g., malformed pair, invalid key).</li> <li><code>3</code>: The key, value, or configuration path contained non-ASCII or forbidden   control characters.</li> </ul>"},{"location":"reference/commands/config/set/#bijux_cli.commands.config.set.set_config","title":"<code>set_config(ctx: typer.Context, pair: str | None = typer.Argument(None, help='KEY=VALUE to set; if omitted, read from stdin'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Sets or updates a configuration key-value pair.</p> <p>This function orchestrates the <code>set</code> operation. It accepts a <code>KEY=VALUE</code> pair from either a command-line argument or standard input. It performs extensive validation on the key and value for format and content, handles file locking to prevent race conditions, and emits a structured payload confirming the update.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>pair</code>               (<code>str | None</code>, default:                   <code>Argument(None, help='KEY=VALUE to set; if omitted, read from stdin')</code> )           \u2013            <p>A string in \"KEY=VALUE\" format. If None, the pair is read from stdin.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/set.py</code> <pre><code>def set_config(\n    ctx: typer.Context,\n    pair: str | None = typer.Argument(\n        None, help=\"KEY=VALUE to set; if omitted, read from stdin\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Sets or updates a configuration key-value pair.\n\n    This function orchestrates the `set` operation. It accepts a `KEY=VALUE`\n    pair from either a command-line argument or standard input. It performs\n    extensive validation on the key and value for format and content, handles\n    file locking to prevent race conditions, and emits a structured payload\n    confirming the update.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        pair (str | None): A string in \"KEY=VALUE\" format. If None, the pair\n            is read from stdin.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    cfg_path = os.environ.get(\"BIJUXCLI_CONFIG\", \"\") or \"\"\n    if cfg_path:\n        try:\n            cfg_path.encode(\"ascii\")\n        except UnicodeEncodeError:\n            emit_error_and_exit(\n                \"Non-ASCII characters in config path\",\n                code=3,\n                failure=\"ascii\",\n                command=\"config set\",\n                fmt=\"json\",\n                quiet=False,\n                include_runtime=False,\n                debug=False,\n                extra={\"path\": \"[non-ascii path provided]\"},\n            )\n    flags = parse_global_flags()\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n    command = \"config set\"\n    if os.name == \"posix\":\n        with suppress(Exception):\n            import fcntl\n\n            with open(cfg_path, \"a+\") as fh:\n                try:\n                    fcntl.flock(fh, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                except OSError:\n                    emit_error_and_exit(\n                        \"Config file is locked\",\n                        code=1,\n                        failure=\"file_locked\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=include_runtime,\n                        debug=debug,\n                        extra={\"path\": cfg_path},\n                    )\n                finally:\n                    with suppress(Exception):\n                        fcntl.flock(fh, fcntl.LOCK_UN)\n    if pair is None:\n        if sys.stdin.isatty():\n            emit_error_and_exit(\n                \"Missing argument: KEY=VALUE required\",\n                code=2,\n                failure=\"missing_argument\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n        pair = sys.stdin.read().rstrip(\"\\n\")\n    if not pair or \"=\" not in pair:\n        emit_error_and_exit(\n            \"Invalid argument: KEY=VALUE required\",\n            code=2,\n            failure=\"invalid_argument\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    raw_key, raw_value = pair.split(\"=\", 1)\n    key = raw_key.strip()\n    service_value_str = raw_value\n    if len(service_value_str) &gt;= 2 and (\n        (service_value_str[0] == service_value_str[-1] == '\"')\n        or (service_value_str[0] == service_value_str[-1] == \"'\")\n    ):\n        import codecs\n\n        service_value_str = codecs.decode(service_value_str[1:-1], \"unicode_escape\")\n    if not key:\n        emit_error_and_exit(\n            \"Key cannot be empty\",\n            code=2,\n            failure=\"empty_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    if not all(ord(c) &lt; 128 for c in key + service_value_str):\n        emit_error_and_exit(\n            \"Non-ASCII characters are not allowed in keys or values.\",\n            code=3,\n            failure=\"ascii_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    if not re.match(r\"^[A-Za-z0-9_]+$\", key):\n        emit_error_and_exit(\n            \"Invalid key: only alphanumerics and underscore allowed.\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    if not all(\n        c in string.printable and c not in \"\\r\\n\\t\\x0b\\x0c\" for c in service_value_str\n    ):\n        emit_error_and_exit(\n            \"Control characters are not allowed in config values.\",\n            code=3,\n            failure=\"control_char_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n    try:\n        config_svc.set(key, service_value_str)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to set config: {exc}\",\n            code=1,\n            failure=\"set_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a key was set or updated.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\n            \"status\": \"updated\",\n            \"key\": key,\n            \"value\": service_value_str,\n        }\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/unset/","title":"Unset Command API Reference","text":"<p>This section documents the internals of the <code>unset</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/unset/#bijux_cli.commands.config.unset","title":"<code>bijux_cli.commands.config.unset</code>","text":"<p>Implements the <code>config unset</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for removing a key-value pair from the active configuration store. It provides a structured, machine-readable response to confirm the deletion or report an error, such as if the key does not exist.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"deleted\", \"key\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> <li><code>2</code>: The specified key was not found in the configuration.</li> </ul>"},{"location":"reference/commands/config/unset/#bijux_cli.commands.config.unset.unset_config","title":"<code>unset_config(ctx: typer.Context, key: str = typer.Argument(..., help='Key to remove'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Removes a key from the active configuration store.</p> <p>This function orchestrates the <code>unset</code> operation. It manually parses global flags, resolves the configuration service, attempts to remove the specified key, and then uses the <code>new_run_command</code> helper to emit a structured payload confirming the action.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to remove')</code> )           \u2013            <p>The configuration key to remove.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/unset.py</code> <pre><code>def unset_config(\n    ctx: typer.Context,\n    key: str = typer.Argument(..., help=\"Key to remove\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes a key from the active configuration store.\n\n    This function orchestrates the `unset` operation. It manually parses global\n    flags, resolves the configuration service, attempts to remove the specified\n    key, and then uses the `new_run_command` helper to emit a structured\n    payload confirming the action.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        key (str): The configuration key to remove.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config unset\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.unset(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Config key not found: {key}\",\n            code=2,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to unset config: {exc}\",\n            code=1,\n            failure=\"unset_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a key was deleted.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"deleted\", \"key\": key}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/dev/di/","title":"Di Command API Reference","text":"<p>This section documents the internals of the <code>di</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/di/#bijux_cli.commands.dev.di","title":"<code>bijux_cli.commands.dev.di</code>","text":"<p>Implements the <code>dev di</code> subcommand for the Bijux CLI.</p> <p>This module provides a developer-focused command to introspect the internal Dependency Injection (DI) container. It outputs a graph of all registered service and factory protocols, which is useful for debugging the application's architecture and service resolution.</p> Output Contract <ul> <li>Success: <code>{\"factories\": list, \"services\": list}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal internal error occurred (e.g., during serialization).</li> <li><code>2</code>: An invalid argument or environment setting was provided (e.g.,   bad output path, unreadable config, invalid limit).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/di/#bijux_cli.commands.dev.di.dev_di_graph","title":"<code>dev_di_graph(quiet: bool = QUIET_OPTION, verbose: bool = VERBOSE_OPTION, fmt: str = FORMAT_OPTION, pretty: bool = PRETTY_OPTION, debug: bool = DEBUG_OPTION, output: list[Path] = OUTPUT_OPTION) -&gt; None</code>","text":"<p>Generates and outputs the Dependency Injection (DI) container graph.</p> <p>This developer tool inspects the DI container, validates environment settings, and outputs the registration graph to stdout and/or one or more files.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>QUIET_OPTION</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>VERBOSE_OPTION</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>FORMAT_OPTION</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>PRETTY_OPTION</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>DEBUG_OPTION</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> <li> <code>output</code>               (<code>list[Path]</code>, default:                   <code>OUTPUT_OPTION</code> )           \u2013            <p>A list of file paths to write the output to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/di.py</code> <pre><code>def dev_di_graph(\n    quiet: bool = QUIET_OPTION,\n    verbose: bool = VERBOSE_OPTION,\n    fmt: str = FORMAT_OPTION,\n    pretty: bool = PRETTY_OPTION,\n    debug: bool = DEBUG_OPTION,\n    output: list[Path] = OUTPUT_OPTION,\n) -&gt; None:\n    \"\"\"Generates and outputs the Dependency Injection (DI) container graph.\n\n    This developer tool inspects the DI container, validates environment\n    settings, and outputs the registration graph to stdout and/or one or more\n    files.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n        output (list[Path]): A list of file paths to write the output to.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"dev di\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    limit_env = os.environ.get(\"BIJUXCLI_DI_LIMIT\")\n    limit: int | None = None\n    if limit_env is not None:\n        try:\n            limit = int(limit_env)\n            if limit &lt; 0:\n                emit_error_and_exit(\n                    f\"Invalid BIJUXCLI_DI_LIMIT value: '{limit_env}'\",\n                    code=2,\n                    failure=\"limit\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n        except (ValueError, TypeError):\n            emit_error_and_exit(\n                f\"Invalid BIJUXCLI_DI_LIMIT value: '{limit_env}'\",\n                code=2,\n                failure=\"limit\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    config_env = os.environ.get(\"BIJUXCLI_CONFIG\")\n    if config_env and not config_env.isascii():\n        emit_error_and_exit(\n            f\"Config path contains non-ASCII characters: {config_env!r}\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if config_env:\n        cfg_path = Path(config_env)\n        if cfg_path.exists() and not os.access(cfg_path, os.R_OK):\n            emit_error_and_exit(\n                f\"Config path not readable: {cfg_path}\",\n                code=2,\n                failure=\"config_unreadable\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    try:\n        payload = _build_dev_di_payload(effective_include_runtime)\n        if limit is not None:\n            payload[\"factories\"] = payload[\"factories\"][:limit]\n            payload[\"services\"] = payload[\"services\"][:limit]\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    outputs = output\n    if outputs:\n        for p in outputs:\n            if p.is_dir():\n                emit_error_and_exit(\n                    f\"Output path is a directory: {p}\",\n                    code=2,\n                    failure=\"output_dir\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n            p.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                if fmt_lower == \"json\":\n                    p.write_text(\n                        json.dumps(payload, indent=2 if effective_pretty else None)\n                        + \"\\n\",\n                        encoding=\"utf-8\",\n                    )\n                else:\n                    p.write_text(\n                        yaml.safe_dump(\n                            payload,\n                            default_flow_style=False,\n                            indent=2 if effective_pretty else None,\n                        ),\n                        encoding=\"utf-8\",\n                    )\n            except OSError as exc:\n                emit_error_and_exit(\n                    f\"Failed to write output file '{p}': {exc}\",\n                    code=2,\n                    failure=\"output_write\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n\n        if quiet:\n            raise typer.Exit(0)\n\n    if os.environ.get(\"BIJUXCLI_TEST_FORCE_SERIALIZE_FAIL\") == \"1\":\n        emit_error_and_exit(\n            \"Forced serialization failure\",\n            code=1,\n            failure=\"serialize\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda _: payload,\n        quiet=quiet,\n        verbose=effective_include_runtime,\n        fmt=fmt_lower,\n        pretty=effective_pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/dev/list_plugins/","title":"List_plugins Command API Reference","text":"<p>This section documents the internals of the <code>list_plugins</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/list_plugins/#bijux_cli.commands.dev.list_plugins","title":"<code>bijux_cli.commands.dev.list_plugins</code>","text":"<p>Implements the <code>dev list-plugins</code> subcommand for the Bijux CLI.</p> <p>This module provides a developer-focused command to list all installed CLI plugins. It delegates its core logic to the shared <code>handle_list_plugins</code> utility, which scans the filesystem and returns a structured list.</p> Output Contract <ul> <li>Success: <code>{\"plugins\": [str, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An error occurred while accessing the plugins directory.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/list_plugins/#bijux_cli.commands.dev.list_plugins.dev_list_plugins","title":"<code>dev_list_plugins(quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Lists all installed CLI plugins.</p> <p>This command acts as a wrapper around the shared <code>handle_list_plugins</code> utility to provide a consistent interface for developers.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/list_plugins.py</code> <pre><code>def dev_list_plugins(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all installed CLI plugins.\n\n    This command acts as a wrapper around the shared `handle_list_plugins`\n    utility to provide a consistent interface for developers.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"dev list-plugins\"\n\n    validate_common_flags(fmt, command, quiet)\n\n    handle_list_plugins(command, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/dev/service/","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/service/#bijux_cli.commands.dev.service","title":"<code>bijux_cli.commands.dev.service</code>","text":"<p>Implements the root callback for the <code>bijux dev</code> command group.</p> <p>This module defines the default action for the <code>bijux dev</code> command. This command group is intended for developers of the CLI. When invoked without a subcommand, it provides a simple status confirmation.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\"}</code></li> <li>With Env Var: Adds <code>{\"mode\": str}</code> if <code>BIJUXCLI_DEV_MODE</code> is set.</li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An internal or unexpected error occurred.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/service/#bijux_cli.commands.dev.service.dev","title":"<code>dev(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint for the <code>bijux dev</code> command group.</p> <p>This function serves as the default action when <code>bijux dev</code> is run without a subcommand. It emits a simple status payload. If a subcommand is invoked, this function yields control to it.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/service.py</code> <pre><code>def dev(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux dev` command group.\n\n    This function serves as the default action when `bijux dev` is run\n    without a subcommand. It emits a simple status payload. If a subcommand\n    is invoked, this function yields control to it.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"dev\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    mode = os.environ.get(\"BIJUXCLI_DEV_MODE\")\n\n    def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload for the dev status command.\n\n        The payload indicates an \"ok\" status and includes optional mode and\n        runtime information based on the parent function's scope.\n\n        Args:\n            _ (bool): An unused parameter to match the expected signature of\n                the `payload_builder` in `new_run_command`.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"status\": \"ok\"}\n        if mode:\n            payload[\"mode\"] = mode\n        if effective_include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=effective_include_runtime,\n        fmt=fmt_lower,\n        pretty=effective_pretty,\n        debug=(debug and not quiet),\n    )\n</code></pre>"},{"location":"reference/commands/history/clear/","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/history/clear/#bijux_cli.commands.history.clear","title":"<code>bijux_cli.commands.history.clear</code>","text":"<p>Implements the <code>history clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently erasing all entries from the command history store. This action is irreversible. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred, such as the history service being   unavailable or a failure during the clear operation.</li> </ul>"},{"location":"reference/commands/history/clear/#bijux_cli.commands.history.clear.clear_history","title":"<code>clear_history(quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Erases all stored command history.</p> <p>This command permanently removes all entries from the history store and emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/clear.py</code> <pre><code>def clear_history(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Erases all stored command history.\n\n    This command permanently removes all entries from the history store and\n    emits a structured payload to confirm the operation.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"history clear\"\n    if debug:\n        verbose = True\n        pretty = True\n    include_runtime = verbose\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    history_svc = resolve_history_service(\n        command, fmt_lower, quiet, include_runtime, debug\n    )\n\n    try:\n        history_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear history: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload confirming the history was cleared.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"status\": \"cleared\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/history/clear/#bijux_cli.commands.history.clear.resolve_history_service","title":"<code>resolve_history_service(command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool) -&gt; HistoryProtocol</code>","text":"<p>Resolves the HistoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"history clear\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HistoryProtocol</code> (              <code>HistoryProtocol</code> )          \u2013            <p>An instance of the history service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/clear.py</code> <pre><code>def resolve_history_service(\n    command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool\n) -&gt; HistoryProtocol:\n    \"\"\"Resolves the HistoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"history clear\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        HistoryProtocol: An instance of the history service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(HistoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"History service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/history/service/","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/history/service/#bijux_cli.commands.history.service","title":"<code>bijux_cli.commands.history.service</code>","text":"<p>Implements the <code>history</code> command for the Bijux CLI.</p> <p>This module provides functionality to interact with the persistent command history. It allows for listing, filtering, sorting, grouping, importing, and exporting history entries. All operations produce structured, machine-readable output.</p> <p>The command has three primary modes of operation: 1.  Listing (Default): When no import/export flags are used, it lists     history entries, which can be filtered, sorted, and grouped. 2.  Import: The <code>--import</code> flag replaces the current history with data     from a specified JSON file. 3.  Export: The <code>--export</code> flag writes the entire current history to a     specified JSON file.</p> Output Contract <ul> <li>List Success:   <code>{\"entries\": list}</code></li> <li>Import Success: <code>{\"status\": \"imported\", \"file\": str}</code></li> <li>Export Success: <code>{\"status\": \"exported\", \"file\": str}</code></li> <li>Verbose:        Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:          <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., history service unavailable).</li> <li><code>2</code>: An invalid argument was provided or an I/O error occurred during   import/export.</li> </ul>"},{"location":"reference/commands/history/service/#bijux_cli.commands.history.service.history","title":"<code>history(ctx: typer.Context, limit: int = typer.Option(20, '--limit', '-l', help='Maximum number of entries (0 means none).'), group_by: str | None = typer.Option(None, '--group-by', '-g', help=\"Group entries by a field (e.g., 'command').\"), filter_cmd: str | None = typer.Option(None, '--filter', '-F', help='Return only entries whose command contains TEXT.'), sort: str | None = typer.Option(None, '--sort', help=\"Sort key; currently only 'timestamp' is recognized.\"), export_path: str = typer.Option(None, '--export', help='Write entire history to FILE (JSON). Overwrites.'), import_path: str = typer.Option(None, '--import', help='Load history from FILE (JSON), replacing current store.'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Lists, imports, or exports the command history.</p> <p>This function orchestrates all history-related operations. It first checks for an import or export action. If neither is specified, it proceeds to list the history, applying any specified filtering, grouping, or sorting.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Option(20, '--limit', '-l', help='Maximum number of entries (0 means none).')</code> )           \u2013            <p>The maximum number of entries to return for a list operation.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>Option(None, '--group-by', '-g', help=\"Group entries by a field (e.g., 'command').\")</code> )           \u2013            <p>The field to group history entries by ('command').</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>Option(None, '--filter', '-F', help='Return only entries whose command contains TEXT.')</code> )           \u2013            <p>A substring to filter command names by.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>Option(None, '--sort', help=\"Sort key; currently only 'timestamp' is recognized.\")</code> )           \u2013            <p>The key to sort entries by ('timestamp').</p> </li> <li> <code>export_path</code>               (<code>str</code>, default:                   <code>Option(None, '--export', help='Write entire history to FILE (JSON). Overwrites.')</code> )           \u2013            <p>The path to export history to. This is an exclusive action.</p> </li> <li> <code>import_path</code>               (<code>str</code>, default:                   <code>Option(None, '--import', help='Load history from FILE (JSON), replacing current store.')</code> )           \u2013            <p>The path to import history from. This is an exclusive action.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/service.py</code> <pre><code>def history(\n    ctx: typer.Context,\n    limit: int = typer.Option(\n        20, \"--limit\", \"-l\", help=\"Maximum number of entries (0 means none).\"\n    ),\n    group_by: str | None = typer.Option(\n        None, \"--group-by\", \"-g\", help=\"Group entries by a field (e.g., 'command').\"\n    ),\n    filter_cmd: str | None = typer.Option(\n        None, \"--filter\", \"-F\", help=\"Return only entries whose command contains TEXT.\"\n    ),\n    sort: str | None = typer.Option(\n        None, \"--sort\", help=\"Sort key; currently only 'timestamp' is recognized.\"\n    ),\n    export_path: str = typer.Option(\n        None, \"--export\", help=\"Write entire history to FILE (JSON). Overwrites.\"\n    ),\n    import_path: str = typer.Option(\n        None, \"--import\", help=\"Load history from FILE (JSON), replacing current store.\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists, imports, or exports the command history.\n\n    This function orchestrates all history-related operations. It first checks\n    for an import or export action. If neither is specified, it proceeds to\n    list the history, applying any specified filtering, grouping, or sorting.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        limit (int): The maximum number of entries to return for a list operation.\n        group_by (str | None): The field to group history entries by ('command').\n        filter_cmd (str | None): A substring to filter command names by.\n        sort (str | None): The key to sort entries by ('timestamp').\n        export_path (str): The path to export history to. This is an exclusive action.\n        import_path (str): The path to import history from. This is an exclusive action.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"history\"\n    if debug:\n        verbose = True\n        pretty = True\n    include_runtime = verbose\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    history_svc = resolve_history_service(\n        command, fmt_lower, quiet, include_runtime, debug\n    )\n\n    if limit &lt; 0:\n        emit_error_and_exit(\n            \"Invalid value for --limit: must be non-negative.\",\n            code=2,\n            failure=\"limit\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if sort and sort != \"timestamp\":\n        emit_error_and_exit(\n            \"Invalid sort key: only 'timestamp' is supported.\",\n            code=2,\n            failure=\"sort\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if group_by and group_by != \"command\":\n        emit_error_and_exit(\n            \"Invalid group_by: only 'command' is supported.\",\n            code=2,\n            failure=\"group_by\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if import_path:\n        try:\n            text = Path(import_path).read_text(encoding=\"utf-8\").strip()\n            data = json.loads(text or \"[]\")\n            if not isinstance(data, list):\n                raise ValueError(\"Import file must contain a JSON array.\")\n            history_svc.clear()\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n                cmd = str(item.get(\"command\") or item.get(\"cmd\", \"\"))\n                cmd = ascii_safe(cmd, \"command\")\n                if not cmd:\n                    continue\n                history_svc.add(\n                    command=cmd,\n                    params=item.get(\"params\", []),\n                    success=bool(item.get(\"success\", True)),\n                    return_code=item.get(\"return_code\", 0),\n                    duration_ms=item.get(\"duration_ms\", 0.0),\n                )\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to import history: {exc}\",\n                code=2,\n                failure=\"import_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n\n        def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n            \"\"\"Builds the payload confirming a successful import.\n\n            Args:\n                _ (bool): Unused parameter to match the expected signature.\n\n            Returns:\n                Mapping[str, Any]: The structured payload.\n            \"\"\"\n            payload: dict[str, Any] = {\"status\": \"imported\", \"file\": import_path}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n\n    if export_path:\n        try:\n            entries = history_svc.list()\n            Path(export_path).write_text(\n                json.dumps(entries, indent=2 if pretty else None) + \"\\n\",\n                encoding=\"utf-8\",\n            )\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to export history: {exc}\",\n                code=2,\n                failure=\"export_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n\n        def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n            \"\"\"Builds the payload confirming a successful export.\n\n            Args:\n                _ (bool): Unused parameter to match the expected signature.\n\n            Returns:\n                Mapping[str, Any]: The structured payload.\n            \"\"\"\n            payload: dict[str, Any] = {\"status\": \"exported\", \"file\": export_path}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n\n    try:\n        entries = history_svc.list()\n        if filter_cmd:\n            entries = [e for e in entries if filter_cmd in e.get(\"command\", \"\")]\n        if sort == \"timestamp\":\n            entries = sorted(entries, key=lambda e: e.get(\"timestamp\", 0))\n        if group_by == \"command\":\n            groups: dict[str, list[dict[str, Any]]] = {}\n            for e in entries:\n                groups.setdefault(e.get(\"command\", \"\"), []).append(e)\n            entries = [\n                {\"group\": k, \"count\": len(v), \"entries\": v} for k, v in groups.items()\n            ]\n        if limit == 0:\n            entries = []\n        elif limit &gt; 0:\n            entries = entries[-limit:]\n\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list history: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def list_payload_builder(include_runtime: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload containing a list of history entries.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"entries\": entries}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=list_payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/history/service/#bijux_cli.commands.history.service.resolve_history_service","title":"<code>resolve_history_service(command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool) -&gt; HistoryProtocol</code>","text":"<p>Resolves the HistoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"history\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HistoryProtocol</code> (              <code>HistoryProtocol</code> )          \u2013            <p>An instance of the history service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/service.py</code> <pre><code>def resolve_history_service(\n    command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool\n) -&gt; HistoryProtocol:\n    \"\"\"Resolves the HistoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"history\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        HistoryProtocol: An instance of the history service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(HistoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"History service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/memory/clear/","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/clear/#bijux_cli.commands.memory.clear","title":"<code>bijux_cli.commands.memory.clear</code>","text":"<p>Implements the <code>memory clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently erasing all entries from the transient, in-memory data store. This action is irreversible for the current process. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\", \"count\": 0}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, clear failed).</li> </ul>"},{"location":"reference/commands/memory/clear/#bijux_cli.commands.memory.clear.clear_memory","title":"<code>clear_memory(quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Removes all key-value pairs from the transient in-memory store.</p> <p>This command erases all entries from the memory service and emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/clear.py</code> <pre><code>def clear_memory(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes all key-value pairs from the transient in-memory store.\n\n    This command erases all entries from the memory service and emits a\n    structured payload to confirm the operation.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory clear\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear memory: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/delete/","title":"Delete Command API Reference","text":"<p>This section documents the internals of the <code>delete</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/delete/#bijux_cli.commands.memory.delete","title":"<code>bijux_cli.commands.memory.delete</code>","text":"<p>Implements the <code>memory delete</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for removing a specific key and its associated value from the transient, in-memory data store. It provides a structured, machine-readable confirmation of the deletion.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"deleted\", \"key\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The key was not found, or another unexpected error occurred.</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/delete/#bijux_cli.commands.memory.delete.delete_memory","title":"<code>delete_memory(key: str = typer.Argument(..., help='Key to delete'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Deletes a key from the transient in-memory store.</p> <p>This command validates the key's format and then removes the corresponding key-value pair from the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to delete')</code> )           \u2013            <p>The memory key to remove. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/delete.py</code> <pre><code>def delete_memory(\n    key: str = typer.Argument(..., help=\"Key to delete\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Deletes a key from the transient in-memory store.\n\n    This command validates the key's format and then removes the corresponding\n    key-value pair from the memory service.\n\n    Args:\n        key (str): The memory key to remove. Must be between 1 and 4096\n            printable, non-whitespace characters.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory delete\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.delete(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Key not found: {key}\",\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to delete memory key: {exc}\",\n            code=1,\n            failure=\"delete_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/get/","title":"Get Command API Reference","text":"<p>This section documents the internals of the <code>get</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/get/#bijux_cli.commands.memory.get","title":"<code>bijux_cli.commands.memory.get</code>","text":"<p>Implements the <code>memory get</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for retrieving the value of a specific key from the transient, in-memory data store. It provides a structured, machine-readable response containing the value or an error if the key is not found.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The key was not found, or another unexpected error occurred.</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/get/#bijux_cli.commands.memory.get.get_memory","title":"<code>get_memory(key: str = typer.Argument(..., help='Key to retrieve'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Retrieves a value by key from the transient in-memory store.</p> <p>This command validates the key's format and then fetches the corresponding value from the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to retrieve')</code> )           \u2013            <p>The memory key to look up. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/get.py</code> <pre><code>def get_memory(\n    key: str = typer.Argument(..., help=\"Key to retrieve\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Retrieves a value by key from the transient in-memory store.\n\n    This command validates the key's format and then fetches the corresponding\n    value from the memory service.\n\n    Args:\n        key (str): The memory key to look up. Must be between 1 and 4096\n            printable, non-whitespace characters.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory get\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        value = memory_svc.get(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Key not found: {key}\",\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to get memory: {exc}\",\n            code=1,\n            failure=\"get_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key, value),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/list/","title":"List Command API Reference","text":"<p>This section documents the internals of the <code>list</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/list/#bijux_cli.commands.memory.list","title":"<code>bijux_cli.commands.memory.list</code>","text":"<p>Implements the <code>memory list</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for listing all keys currently held in the transient, in-memory data store. It retrieves the keys and presents them in a structured, machine-readable list format.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"keys\": list, \"count\": int}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, list failed).</li> </ul>"},{"location":"reference/commands/memory/list/#bijux_cli.commands.memory.list.list_memory","title":"<code>list_memory(quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Lists all keys currently stored in the transient in-memory store.</p> <p>This command retrieves all defined keys from the memory service, sorts them, and then emits them in a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/list.py</code> <pre><code>def list_memory(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all keys currently stored in the transient in-memory store.\n\n    This command retrieves all defined keys from the memory service, sorts them,\n    and then emits them in a structured payload.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory list\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        keys = sorted(memory_svc.keys())\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list memory keys: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, keys),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/service/","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/service/#bijux_cli.commands.memory.service","title":"<code>bijux_cli.commands.memory.service</code>","text":"<p>Implements the root callback for the <code>bijux memory</code> command group.</p> <p>This module defines the default action for the <code>bijux memory</code> command. When invoked without a subcommand, it provides a summary of the transient, in-memory data store, including the number of keys currently set.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"count\": int|None, \"message\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/memory/service/#bijux_cli.commands.memory.service.memory","title":"<code>memory(ctx: typer.Context, quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Defines the entrypoint for the <code>bijux memory</code> command group.</p> <p>This function serves as the main callback. It handles <code>--help</code> requests and, if no subcommand is invoked, delegates to the <code>memory_summary</code> function to display the default summary view.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>Exit</code>             \u2013            <p>Exits after displaying help text.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/service.py</code> <pre><code>def memory(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux memory` command group.\n\n    This function serves as the main callback. It handles `--help` requests and,\n    if no subcommand is invoked, delegates to the `memory_summary` function to\n    display the default summary view.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        typer.Exit: Exits after displaying help text.\n    \"\"\"\n    if any(arg in (\"-h\", \"--help\") for arg in sys.argv):\n        if ctx.invoked_subcommand:\n            cmd = getattr(ctx.command, \"get_command\", None)\n            sub_cmd = cmd(ctx, ctx.invoked_subcommand) if callable(cmd) else None\n            if sub_cmd and hasattr(sub_cmd, \"get_help\"):\n                typer.echo(\n                    sub_cmd.get_help(ctx)  # pyright: ignore[reportAttributeAccessIssue]\n                )\n            else:\n                typer.echo(ctx.get_help())\n        else:\n            typer.echo(ctx.get_help())\n        raise typer.Exit()\n    if ctx.invoked_subcommand is None:\n        memory_summary(ctx, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/memory/service/#bijux_cli.commands.memory.service.memory_summary","title":"<code>memory_summary(ctx: typer.Context, quiet: bool, verbose: bool, fmt: str, pretty: bool, debug: bool) -&gt; None</code>","text":"<p>Handles the logic for the default <code>bijux memory</code> command action.</p> <p>This function is called by the main Typer callback when no subcommand is specified. It resolves the memory service, gets the key count, and then executes the one-shot summary.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/service.py</code> <pre><code>def memory_summary(\n    ctx: typer.Context,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Handles the logic for the default `bijux memory` command action.\n\n    This function is called by the main Typer callback when no subcommand is\n    specified. It resolves the memory service, gets the key count, and then\n    executes the one-shot summary.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    command = \"memory\"\n    include_runtime = verbose or debug\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    effective_pretty = debug or pretty\n\n    svc = resolve_memory_service(command, fmt_lower, quiet, include_runtime, debug)\n\n    keys_count = None\n    with contextlib.suppress(Exception):\n        keys_count = len(svc.keys())\n\n    _run_one_shot_mode(\n        command=command,\n        fmt=fmt_lower,\n        output_format=output_format,\n        quiet=quiet,\n        verbose=verbose,\n        debug=debug,\n        effective_pretty=effective_pretty,\n        include_runtime=include_runtime,\n        keys_count=keys_count,\n    )\n</code></pre>"},{"location":"reference/commands/memory/set/","title":"Set Command API Reference","text":"<p>This section documents the internals of the <code>set</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/set/#bijux_cli.commands.memory.set","title":"<code>bijux_cli.commands.memory.set</code>","text":"<p>Implements the <code>memory set</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for storing a key-value pair in a transient, in-memory data store. The data persists only for the lifetime of the application's parent process. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"updated\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, set failed).</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/set/#bijux_cli.commands.memory.set.set_memory","title":"<code>set_memory(key: str = typer.Argument(..., help='Key to set'), value: str = typer.Argument(..., help='Value to set'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Sets a key-value pair in the transient in-memory store.</p> <p>This command validates the key's format and then stores the key-value pair using the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to set')</code> )           \u2013            <p>The memory key to set. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>value</code>               (<code>str</code>, default:                   <code>Argument(..., help='Value to set')</code> )           \u2013            <p>The value to associate with the key.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/set.py</code> <pre><code>def set_memory(\n    key: str = typer.Argument(..., help=\"Key to set\"),\n    value: str = typer.Argument(..., help=\"Value to set\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Sets a key-value pair in the transient in-memory store.\n\n    This command validates the key's format and then stores the key-value\n    pair using the memory service.\n\n    Args:\n        key (str): The memory key to set. Must be between 1 and 4096 printable,\n            non-whitespace characters.\n        value (str): The value to associate with the key.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory set\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.set(key, value)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to set memory: {exc}\",\n            code=1,\n            failure=\"set_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key, value),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/utils/","title":"Utils Command API Reference","text":"<p>This section documents the internals of the <code>utils</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/utils/#bijux_cli.commands.memory.utils","title":"<code>bijux_cli.commands.memory.utils</code>","text":"<p>Provides shared utilities for the <code>bijux memory</code> command group.</p> <p>This module centralizes common logic used by the memory-related subcommands. Its primary responsibility is to provide a consistent way to resolve the <code>MemoryProtocol</code> service from the Dependency Injection (DI) container, including standardized error handling for cases where the service is unavailable.</p>"},{"location":"reference/commands/memory/utils/#bijux_cli.commands.memory.utils.resolve_memory_service","title":"<code>resolve_memory_service(command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool) -&gt; MemoryProtocol</code>","text":"<p>Resolves the MemoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"memory list\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MemoryProtocol</code> (              <code>MemoryProtocol</code> )          \u2013            <p>An instance of the memory service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/utils.py</code> <pre><code>def resolve_memory_service(\n    command: str,\n    fmt_lower: str,\n    quiet: bool,\n    include_runtime: bool,\n    debug: bool,\n) -&gt; MemoryProtocol:\n    \"\"\"Resolves the MemoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"memory list\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        MemoryProtocol: An instance of the memory service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(MemoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Memory service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n</code></pre>"},{"location":"reference/commands/plugins/check/","title":"Check Command API Reference","text":"<p>This section documents the internals of the <code>check</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/check/#bijux_cli.commands.plugins.check","title":"<code>bijux_cli.commands.plugins.check</code>","text":"<p>Implements the <code>plugins check</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for performing a health check on a specific installed plugin. It validates the plugin's files, dynamically imports its code, and executes a <code>health()</code> hook function if available. The result is reported in a structured, machine-readable format.</p> Output Contract <ul> <li>Healthy:   <code>{\"plugin\": str, \"status\": \"healthy\"}</code></li> <li>Unhealthy: <code>{\"plugin\": str, \"status\": \"unhealthy\"}</code> (exits with code 1)</li> <li>Verbose:   Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:     <code>{\"error\": \"...\", \"code\": int}</code> (for pre-check failures)</li> </ul> Exit Codes <ul> <li><code>0</code>: The plugin is healthy.</li> <li><code>1</code>: The plugin is unhealthy, could not be found, or an error occurred   during import or execution.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/check/#bijux_cli.commands.plugins.check.check_plugin","title":"<code>check_plugin(name: str = typer.Argument(..., help='Plugin name'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Runs a health check on a specific installed plugin.</p> <p>This function validates a plugin's structure, dynamically imports its <code>plugin.py</code> file, and executes its <code>health()</code> hook to determine its operational status. The final status is emitted as a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name of the plugin to check.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating the health status or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/check.py</code> <pre><code>def check_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Runs a health check on a specific installed plugin.\n\n    This function validates a plugin's structure, dynamically imports its\n    `plugin.py` file, and executes its `health()` hook to determine its\n    operational status. The final status is emitted as a structured payload.\n\n    Args:\n        name (str): The name of the plugin to check.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating the health status or detailing an error.\n    \"\"\"\n    command = \"plugins check\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    plug_dir = get_plugins_dir() / name\n    plug_py = plug_dir / \"plugin.py\"\n    meta_json = plug_dir / \"plugin.json\"\n\n    if not plug_py.is_file():\n        emit_error_and_exit(\n            f'Plugin \"{name}\" not found',\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n            extra={\"plugin\": name},\n        )\n\n    if not meta_json.is_file():\n        emit_error_and_exit(\n            f'Plugin \"{name}\" metadata (plugin.json) is missing',\n            code=1,\n            failure=\"metadata_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    try:\n        meta = json.loads(meta_json.read_text(\"utf-8\"))\n        if not (isinstance(meta, dict) and meta.get(\"name\") and meta.get(\"desc\")):\n            raise ValueError(\"Incomplete metadata\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f'Plugin \"{name}\" metadata is corrupt: {exc}',\n            code=1,\n            failure=\"metadata_corrupt\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    mod_name = f\"_bijux_cli_plugin_{name}\"\n    try:\n        spec = importlib.util.spec_from_file_location(mod_name, plug_py)\n        if not spec or not spec.loader:\n            raise ImportError(\"Cannot create import spec\")\n        module = types.ModuleType(mod_name)\n        sys.modules[mod_name] = module\n        spec.loader.exec_module(module)\n    except Exception as exc:\n        err = f\"Import error: {exc}\"\n        if debug:\n            err += \"\\n\" + traceback.format_exc()\n        emit_error_and_exit(\n            err,\n            code=1,\n            failure=\"import_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    async def _run_health() -&gt; dict[str, Any]:\n        \"\"\"Isolates and executes the plugin's `health()` hook.\n\n        This function finds and calls the `health()` function within the\n        imported plugin module. It handles both synchronous and asynchronous\n        hooks, validates their signatures, and safely captures any exceptions\n        during execution.\n\n        Returns:\n            dict[str, Any]: A dictionary containing the health check result,\n                which includes the plugin name and a status ('healthy' or\n                'unhealthy'), or an error message.\n        \"\"\"\n        hook = getattr(module, \"health\", None)\n        if not callable(hook):\n            return {\"plugin\": name, \"error\": \"No health() hook\"}\n        try:\n            sig = inspect.signature(hook)\n            if len(sig.parameters) != 1:\n                return {\n                    \"plugin\": name,\n                    \"error\": \"health() hook must take exactly one argument (di)\",\n                }\n        except Exception as exc1:\n            return {\"plugin\": name, \"error\": f\"health() signature error: {exc1}\"}\n        try:\n            if asyncio.iscoroutinefunction(hook):\n                res = await hook(None)\n            else:\n                loop = asyncio.get_running_loop()\n                res = await loop.run_in_executor(None, hook, None)\n        except BaseException as exc2:\n            return {\"plugin\": name, \"error\": str(exc2) or exc2.__class__.__name__}\n\n        if res is True:\n            return {\"plugin\": name, \"status\": \"healthy\"}\n        if res is False:\n            return {\"plugin\": name, \"status\": \"unhealthy\"}\n        if isinstance(res, dict) and res.get(\"status\") in (\"healthy\", \"unhealthy\"):\n            return {\"plugin\": name, \"status\": res[\"status\"]}\n        return {\"plugin\": name, \"status\": \"unhealthy\"}\n\n    result = asyncio.run(_run_health())\n    sys.modules.pop(mod_name, None)\n    exit_code = 1 if result.get(\"status\") == \"unhealthy\" else 0\n\n    if result.get(\"error\"):\n        emit_error_and_exit(\n            result[\"error\"],\n            code=1,\n            failure=\"health_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    def _build_payload(include: bool) -&gt; Mapping[str, object]:\n        \"\"\"Constructs the final result payload.\n\n        Args:\n            include (bool): If True, adds Python and platform info to the payload.\n\n        Returns:\n            Mapping[str, object]: The payload containing the health check\n                result and optional runtime metadata.\n        \"\"\"\n        payload = result\n        if include:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=_build_payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n        exit_code=exit_code,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/info/","title":"Info Command API Reference","text":"<p>This section documents the internals of the <code>info</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/info/#bijux_cli.commands.plugins.info","title":"<code>bijux_cli.commands.plugins.info</code>","text":"<p>Implements the <code>plugins info</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for displaying detailed metadata about a single installed plugin. It locates the plugin by name, reads its <code>plugin.json</code> manifest file, and presents the contents in a structured, machine-readable format.</p> Output Contract <ul> <li>Success: <code>{\"name\": str, \"path\": str, ... (plugin.json contents)}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The plugin was not found, or its metadata file was corrupt.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/info/#bijux_cli.commands.plugins.info.info_plugin","title":"<code>info_plugin(name: str = typer.Argument(..., help='Plugin name'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Shows detailed metadata for a specific installed plugin.</p> <p>This function locates an installed plugin by its directory name, parses its <code>plugin.json</code> manifest file, and emits the contents as a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The case-sensitive name of the plugin to inspect.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/info.py</code> <pre><code>def info_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Shows detailed metadata for a specific installed plugin.\n\n    This function locates an installed plugin by its directory name, parses its\n    `plugin.json` manifest file, and emits the contents as a structured\n    payload.\n\n    Args:\n        name (str): The case-sensitive name of the plugin to inspect.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins info\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    plug_dir = get_plugins_dir() / name\n    if not (plug_dir.is_dir() and (plug_dir / \"plugin.py\").is_file()):\n        emit_error_and_exit(\n            f'Plugin \"{name}\" not found',\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    meta_file = plug_dir / \"plugin.json\"\n    meta: dict[str, Any] = {}\n    if meta_file.is_file():\n        try:\n            meta = json.loads(meta_file.read_text(\"utf-8\"))\n            if not meta.get(\"name\"):\n                raise ValueError(\"Missing required fields\")\n        except Exception as exc:\n            emit_error_and_exit(\n                f'Plugin \"{name}\" metadata is corrupt: {exc}',\n                code=1,\n                failure=\"metadata_corrupt\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    payload = {\"name\": name, \"path\": str(plug_dir), **meta}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, payload),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/install/","title":"Install Command API Reference","text":"<p>This section documents the internals of the <code>install</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/install/#bijux_cli.commands.plugins.install","title":"<code>bijux_cli.commands.plugins.install</code>","text":"<p>Implements the <code>plugins install</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for installing a new plugin by copying its source directory into the CLI's plugins folder. The process is designed to be atomic and safe, incorporating validation of the plugin's name and metadata, version compatibility checks against the current CLI version, and file locking to prevent race conditions during installation.</p> Output Contract <ul> <li>Install Success: <code>{\"status\": \"installed\", \"plugin\": str, \"dest\": str}</code></li> <li>Dry Run Success: <code>{\"status\": \"dry-run\", \"plugin\": str, ...}</code></li> <li>Error:           <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., source not found, invalid name,   version incompatibility, filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/install/#bijux_cli.commands.plugins.install.install_plugin","title":"<code>install_plugin(path: str = typer.Argument(..., help='Path to plugin directory'), dry_run: bool = typer.Option(False, '--dry-run'), force: bool = typer.Option(False, '--force', '-F'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(False, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Installs a plugin from a local source directory.</p> <p>This function orchestrates the plugin installation process. It validates the source path and plugin name, checks for version compatibility, handles pre-existing plugins via the <code>--force</code> flag, and performs an atomic copy into the plugins directory using a file lock and temporary directory.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Path to plugin directory')</code> )           \u2013            <p>The source path to the plugin directory to install.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>Option(False, '--dry-run')</code> )           \u2013            <p>If True, simulates the installation without making changes.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>Option(False, '--force', '-F')</code> )           \u2013            <p>If True, overwrites an existing plugin of the same name.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in error payloads.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(False, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/install.py</code> <pre><code>def install_plugin(\n    path: str = typer.Argument(..., help=\"Path to plugin directory\"),\n    dry_run: bool = typer.Option(False, \"--dry-run\"),\n    force: bool = typer.Option(False, \"--force\", \"-F\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(False, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Installs a plugin from a local source directory.\n\n    This function orchestrates the plugin installation process. It validates\n    the source path and plugin name, checks for version compatibility, handles\n    pre-existing plugins via the `--force` flag, and performs an atomic copy\n    into the plugins directory using a file lock and temporary directory.\n\n    Args:\n        path (str): The source path to the plugin directory to install.\n        dry_run (bool): If True, simulates the installation without making changes.\n        force (bool): If True, overwrites an existing plugin of the same name.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in error payloads.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    from packaging.specifiers import SpecifierSet\n\n    from bijux_cli.__version__ import version as cli_version\n\n    command = \"plugins install\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n\n    src = Path(path).expanduser()\n    try:\n        src = src.resolve()\n    except (FileNotFoundError, OSError, RuntimeError):\n        src = src.absolute()\n    if not src.exists() or not src.is_dir():\n        emit_error_and_exit(\n            \"Source not found\",\n            code=1,\n            failure=\"source_not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plugin_name = src.name\n\n    if not PLUGIN_NAME_RE.fullmatch(plugin_name) or not plugin_name.isascii():\n        emit_error_and_exit(\n            \"Invalid plugin name: only ASCII letters, digits, dash and underscore are allowed.\",\n            code=1,\n            failure=\"invalid_name\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    dest = plugins_dir / plugin_name\n\n    try:\n        plugins_dir.mkdir(parents=True, exist_ok=True)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Cannot create plugins dir '{plugins_dir}': {exc}\",\n            code=1,\n            failure=\"create_dir_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    lock_file = plugins_dir / \".bijux_install.lock\"\n\n    @contextlib.contextmanager\n    def _lock(fp: Path) -&gt; Iterator[None]:\n        \"\"\"Provides an exclusive, non-blocking file lock.\n\n        This context manager attempts to acquire a lock on the specified file.\n        It is used to ensure atomic filesystem operations within the plugins\n        directory.\n\n        Args:\n            fp (Path): The path to the file to lock.\n\n        Yields:\n            None: Yields control to the `with` block once the lock is acquired.\n        \"\"\"\n        with fp.open(\"w\") as fh:\n            fcntl.flock(fh, fcntl.LOCK_EX)\n            try:\n                yield\n            finally:\n                fcntl.flock(fh, fcntl.LOCK_UN)\n\n    with _lock(lock_file):\n        if plugins_dir.is_symlink():\n            emit_error_and_exit(\n                f\"Refusing to install: plugins dir '{plugins_dir}' is a symlink.\",\n                code=1,\n                failure=\"symlink_dir\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n        if dest.exists():\n            if not force:\n                emit_error_and_exit(\n                    f\"Plugin '{plugin_name}' already installed. Use --force.\",\n                    code=1,\n                    failure=\"already_installed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n            try:\n                if dest.is_dir():\n                    shutil.rmtree(dest)\n                else:\n                    dest.unlink()\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Unable to remove existing '{dest}': {exc}\",\n                    code=1,\n                    failure=\"remove_failed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n        plugin_py = src / \"plugin.py\"\n        if not plugin_py.exists():\n            emit_error_and_exit(\n                \"plugin.py not found in plugin directory\",\n                code=1,\n                failure=\"plugin_py_missing\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        version_spec = parse_required_cli_version(plugin_py)\n        if version_spec:\n            try:\n                spec = SpecifierSet(version_spec)\n                if not spec.contains(cli_version, prereleases=True):\n                    emit_error_and_exit(\n                        f\"Incompatible CLI version: plugin requires '{version_spec}', but you have '{cli_version}'\",\n                        code=1,\n                        failure=\"incompatible_version\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Invalid version specifier in plugin: '{version_spec}'. {exc}\",\n                    code=1,\n                    failure=\"invalid_specifier\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n        if dry_run:\n            payload = {\n                \"status\": \"dry-run\",\n                \"plugin\": plugin_name,\n                \"source\": str(src),\n                \"dest\": str(dest),\n            }\n        else:\n            with tempfile.TemporaryDirectory(dir=plugins_dir) as td:\n                tmp_dst = Path(td) / plugin_name\n                try:\n                    shutil.copytree(\n                        src,\n                        tmp_dst,\n                        symlinks=True,\n                        ignore=ignore_hidden_and_broken_symlinks,\n                    )\n                except OSError as exc:\n                    if exc.errno == errno.ENOSPC or \"No space left on device\" in str(\n                        exc\n                    ):\n                        emit_error_and_exit(\n                            \"Disk full during plugin install\",\n                            code=1,\n                            failure=\"disk_full\",\n                            command=command,\n                            fmt=fmt_lower,\n                            quiet=quiet,\n                            include_runtime=verbose,\n                            debug=debug,\n                        )\n                    if exc.errno == errno.EACCES or \"Permission denied\" in str(exc):\n                        emit_error_and_exit(\n                            \"Permission denied during plugin install\",\n                            code=1,\n                            failure=\"permission_denied\",\n                            command=command,\n                            fmt=fmt_lower,\n                            quiet=quiet,\n                            include_runtime=verbose,\n                            debug=debug,\n                        )\n                    emit_error_and_exit(\n                        f\"OSError during plugin install: {exc!r}\",\n                        code=1,\n                        failure=\"os_error\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n                if not (tmp_dst / \"plugin.py\").is_file():\n                    emit_error_and_exit(\n                        f\"plugin.py not found in '{tmp_dst}'\",\n                        code=1,\n                        failure=\"plugin_py_missing_after_copy\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n                shutil.move(str(tmp_dst), dest)\n            payload = {\"status\": \"installed\", \"plugin\": plugin_name, \"dest\": str(dest)}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/list/","title":"List Command API Reference","text":"<p>This section documents the internals of the <code>list</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/list/#bijux_cli.commands.plugins.list","title":"<code>bijux_cli.commands.plugins.list</code>","text":"<p>Implements the <code>plugins list</code> subcommand for the Bijux CLI.</p> <p>This module provides the primary command for listing all installed CLI plugins. It performs security checks on the plugins directory and then delegates its core logic to the shared <code>handle_list_plugins</code> utility, which scans the filesystem and returns a structured list.</p> Output Contract <ul> <li>Success: <code>{\"plugins\": [str, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An error occurred while accessing the plugins directory (e.g.,   it is a symlink or inaccessible).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/list/#bijux_cli.commands.plugins.list.list_plugin","title":"<code>list_plugin(quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Lists all installed CLI plugins.</p> <p>This command first performs security checks on the plugins directory, such as ensuring it is not a symbolic link. It then delegates to the shared <code>handle_list_plugins</code> utility to perform the filesystem scan and emit the structured output.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/list.py</code> <pre><code>def list_plugin(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all installed CLI plugins.\n\n    This command first performs security checks on the plugins directory, such\n    as ensuring it is not a symbolic link. It then delegates to the shared\n    `handle_list_plugins` utility to perform the filesystem scan and emit the\n    structured output.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins list\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n    handle_list_plugins(command, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/plugins/scaffold/","title":"Scaffold Command API Reference","text":"<p>This section documents the internals of the <code>scaffold</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/scaffold/#bijux_cli.commands.plugins.scaffold","title":"<code>bijux_cli.commands.plugins.scaffold</code>","text":"<p>Implements the <code>plugins scaffold</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for creating a new plugin project from a <code>cookiecutter</code> template. It validates the proposed plugin name, handles the destination directory setup (including forcing overwrites), and invokes <code>cookiecutter</code> to generate the project structure.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"created\", \"plugin\": str, \"dir\": str}</code></li> <li>Error:   <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., cookiecutter not installed, invalid   template, name conflict, filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/scaffold/#bijux_cli.commands.plugins.scaffold.scaffold_plugin","title":"<code>scaffold_plugin(name: str = typer.Argument(..., help='Plugin name'), output_dir: str = typer.Option('.', '--output-dir', '-o'), template: str | None = typer.Option(None, '--template', '-t', help='Path or URL to a cookiecutter template (required)'), force: bool = typer.Option(False, '--force', '-F'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Creates a new plugin project from a cookiecutter template.</p> <p>This function orchestrates the scaffolding process. It performs numerous validations on the plugin name and output directory, handles existing directories with the <code>--force</code> flag, invokes the <code>cookiecutter</code> library to generate the project, and validates the resulting plugin metadata.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name for the new plugin (e.g., 'my-plugin').</p> </li> <li> <code>output_dir</code>               (<code>str</code>, default:                   <code>Option('.', '--output-dir', '-o')</code> )           \u2013            <p>The directory where the new plugin project will be created.</p> </li> <li> <code>template</code>               (<code>str | None</code>, default:                   <code>Option(None, '--template', '-t', help='Path or URL to a cookiecutter template (required)')</code> )           \u2013            <p>The path or URL to the <code>cookiecutter</code> template.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>Option(False, '--force', '-F')</code> )           \u2013            <p>If True, overwrites the output directory if it exists.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in error payloads.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/scaffold.py</code> <pre><code>def scaffold_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    output_dir: str = typer.Option(\".\", \"--output-dir\", \"-o\"),\n    template: str | None = typer.Option(\n        None,\n        \"--template\",\n        \"-t\",\n        help=\"Path or URL to a cookiecutter template (required)\",\n    ),\n    force: bool = typer.Option(False, \"--force\", \"-F\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Creates a new plugin project from a cookiecutter template.\n\n    This function orchestrates the scaffolding process. It performs numerous\n    validations on the plugin name and output directory, handles existing\n    directories with the `--force` flag, invokes the `cookiecutter` library\n    to generate the project, and validates the resulting plugin metadata.\n\n    Args:\n        name (str): The name for the new plugin (e.g., 'my-plugin').\n        output_dir (str): The directory where the new plugin project will be\n            created.\n        template (str | None): The path or URL to the `cookiecutter` template.\n        force (bool): If True, overwrites the output directory if it exists.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in error payloads.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins scaffold\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if name in keyword.kwlist:\n        emit_error_and_exit(\n            f\"Invalid plugin name: '{name}' is a reserved Python keyword.\",\n            code=1,\n            failure=\"reserved_keyword\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not PLUGIN_NAME_RE.fullmatch(name) or not name.isascii():\n        emit_error_and_exit(\n            \"Invalid plugin name: only ASCII letters, digits, dash and underscore are allowed.\",\n            code=1,\n            failure=\"invalid_name\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not template:\n        emit_error_and_exit(\n            \"No plugin template found. Please specify --template (path or URL).\",\n            code=1,\n            failure=\"no_template\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    slug = unicodedata.normalize(\"NFC\", name)\n    parent = Path(output_dir).expanduser().resolve()\n    target = parent / slug\n\n    if not parent.exists():\n        try:\n            parent.mkdir(parents=True, exist_ok=True)\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to create output directory '{parent}': {exc}\",\n                code=1,\n                failure=\"create_dir_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n    elif not parent.is_dir():\n        emit_error_and_exit(\n            f\"Output directory '{parent}' is not a directory.\",\n            code=1,\n            failure=\"not_dir\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    normalized = name.lower()\n    for existing in parent.iterdir():\n        if (\n            (existing.is_dir() or existing.is_symlink())\n            and existing.name.lower() == normalized\n            and existing.resolve() != target.resolve()\n        ):\n            emit_error_and_exit(\n                f\"Plugin name '{name}' conflicts with existing directory '{existing.name}'. \"\n                \"Plugin names must be unique (case-insensitive).\",\n                code=1,\n                failure=\"name_conflict\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    if target.exists() or target.is_symlink():\n        if not force:\n            emit_error_and_exit(\n                f\"Directory '{target}' is not empty \u2013 use --force to overwrite.\",\n                code=1,\n                failure=\"dir_not_empty\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        try:\n            if target.is_symlink():\n                target.unlink()\n            elif target.is_dir():\n                shutil.rmtree(target)\n            else:\n                target.unlink()\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to remove existing '{target}': {exc}\",\n                code=1,\n                failure=\"remove_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    try:\n        from cookiecutter.main import cookiecutter\n\n        cookiecutter(\n            template,\n            no_input=True,\n            output_dir=str(parent),\n            extra_context={\"project_name\": name, \"project_slug\": slug},\n        )\n        if not target.is_dir():\n            raise RuntimeError(\"Template copy failed\")\n    except ModuleNotFoundError:\n        emit_error_and_exit(\n            \"cookiecutter is required but not installed.\",\n            code=1,\n            failure=\"cookiecutter_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        msg = f\"Scaffold failed: {exc} (template not found or invalid)\"\n        emit_error_and_exit(\n            msg,\n            code=1,\n            failure=\"scaffold_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plugin_json = target / \"plugin.json\"\n    if not plugin_json.is_file():\n        emit_error_and_exit(\n            f\"Scaffold failed: plugin.json not found in '{target}'.\",\n            code=1,\n            failure=\"plugin_json_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    try:\n        meta = json.loads(plugin_json.read_text(\"utf-8\"))\n        if not (\n            isinstance(meta, dict)\n            and meta.get(\"name\")\n            and (meta.get(\"desc\") or meta.get(\"description\"))\n        ):\n            raise ValueError(\"Missing required fields\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Scaffold failed: plugin.json invalid: {exc}\",\n            code=1,\n            failure=\"plugin_json_invalid\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    payload = {\"status\": \"created\", \"plugin\": name, \"dir\": str(target)}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/uninstall/","title":"Uninstall Command API Reference","text":"<p>This section documents the internals of the <code>uninstall</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/uninstall/#bijux_cli.commands.plugins.uninstall","title":"<code>bijux_cli.commands.plugins.uninstall</code>","text":"<p>Implements the <code>plugins uninstall</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently removing an installed plugin from the filesystem. The operation locates the plugin directory by its exact name, performs security checks (e.g., refusing to act on symbolic links), and uses a file lock to ensure atomicity before deleting the directory.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"uninstalled\", \"plugin\": str}</code></li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., plugin not found, permission denied,   filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/uninstall/#bijux_cli.commands.plugins.uninstall.uninstall_plugin","title":"<code>uninstall_plugin(name: str = typer.Argument(..., help='Plugin name'), quiet: bool = typer.Option(False, '-q', '--quiet', help=HELP_QUIET), verbose: bool = typer.Option(False, '-v', '--verbose', help=HELP_VERBOSE), fmt: str = typer.Option('json', '-f', '--format', help=HELP_FORMAT), pretty: bool = typer.Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY), debug: bool = typer.Option(False, '-d', '--debug', help=HELP_DEBUG)) -&gt; None</code>","text":"<p>Removes an installed plugin by deleting its directory.</p> <p>This function locates the plugin directory by name, performs several safety checks, acquires a file lock to ensure atomicity, and then permanently removes the plugin from the filesystem.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name of the plugin to uninstall. The match is case-sensitive and Unicode-aware.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in error outputs.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/uninstall.py</code> <pre><code>def uninstall_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes an installed plugin by deleting its directory.\n\n    This function locates the plugin directory by name, performs several safety\n    checks, acquires a file lock to ensure atomicity, and then permanently\n    removes the plugin from the filesystem.\n\n    Args:\n        name (str): The name of the plugin to uninstall. The match is\n            case-sensitive and Unicode-aware.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in error outputs.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins uninstall\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n\n    lock_file = plugins_dir / \".bijux_install.lock\"\n\n    plugin_dirs: list[Path] = []\n    try:\n        plugin_dirs = [\n            p\n            for p in plugins_dir.iterdir()\n            if p.is_dir()\n            and unicodedata.normalize(\"NFC\", p.name)\n            == unicodedata.normalize(\"NFC\", name)\n        ]\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Could not list plugins dir '{plugins_dir}': {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not plugin_dirs:\n        emit_error_and_exit(\n            f\"Plugin '{name}' is not installed.\",\n            code=1,\n            failure=\"not_installed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plug_path = plugin_dirs[0]\n\n    @contextlib.contextmanager\n    def _lock(fp: Path) -&gt; Iterator[None]:\n        \"\"\"Provides an exclusive, non-blocking file lock.\n\n        This context manager attempts to acquire a lock on the specified file.\n        It is used to ensure atomic filesystem operations within the plugins\n        directory.\n\n        Args:\n            fp (Path): The path to the file to lock.\n\n        Yields:\n            None: Yields control to the `with` block once the lock is acquired.\n        \"\"\"\n        fp.parent.mkdir(parents=True, exist_ok=True)\n        with fp.open(\"w\") as fh:\n            fcntl.flock(fh, fcntl.LOCK_EX)\n            try:\n                yield\n            finally:\n                fcntl.flock(fh, fcntl.LOCK_UN)\n\n    with _lock(lock_file):\n        if not plug_path.exists():\n            pass\n        elif plug_path.is_symlink():\n            emit_error_and_exit(\n                f\"Plugin path '{plug_path}' is a symlink. Refusing to uninstall.\",\n                code=1,\n                failure=\"symlink_path\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        elif not plug_path.is_dir():\n            emit_error_and_exit(\n                f\"Plugin path '{plug_path}' is not a directory.\",\n                code=1,\n                failure=\"not_dir\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        else:\n            try:\n                shutil.rmtree(plug_path)\n            except PermissionError:\n                emit_error_and_exit(\n                    f\"Permission denied removing '{plug_path}'\",\n                    code=1,\n                    failure=\"permission_denied\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Failed to remove '{plug_path}': {exc}\",\n                    code=1,\n                    failure=\"remove_failed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n    payload = {\"status\": \"uninstalled\", \"plugin\": name}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/utils/","title":"Utils Command API Reference","text":"<p>This section documents the internals of the <code>utils</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/utils/#bijux_cli.commands.plugins.utils","title":"<code>bijux_cli.commands.plugins.utils</code>","text":"<p>Provides shared utilities for the <code>bijux plugins</code> command group.</p> <p>This module centralizes common logic for managing CLI plugins. It offers helper functions for tasks such as:</p> <ul> <li>Safely traversing plugin directories for copy operations.</li> <li>Parsing metadata from <code>plugin.py</code> files without code execution by     using the Abstract Syntax Tree (AST).</li> <li>Performing security checks, like refusing to operate on directories     that are symbolic links.</li> <li>Validating plugin names against a standard pattern.</li> </ul>"},{"location":"reference/commands/plugins/utils/#bijux_cli.commands.plugins.utils.ignore_hidden_and_broken_symlinks","title":"<code>ignore_hidden_and_broken_symlinks(dirpath: str, names: list[str]) -&gt; list[str]</code>","text":"<p>Creates a list of files and directories to ignore during a copy operation.</p> <p>This function is designed to be used as the <code>ignore</code> callable for <code>shutil.copytree</code>. It skips hidden files (starting with \".\"), the <code>plugin.py</code> file, and any broken symbolic links.</p> <p>Parameters:</p> <ul> <li> <code>dirpath</code>               (<code>str</code>)           \u2013            <p>The path to the directory being scanned.</p> </li> <li> <code>names</code>               (<code>list[str]</code>)           \u2013            <p>A list of names of items within <code>dirpath</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of item names to be ignored by <code>shutil.copytree</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def ignore_hidden_and_broken_symlinks(dirpath: str, names: list[str]) -&gt; list[str]:\n    \"\"\"Creates a list of files and directories to ignore during a copy operation.\n\n    This function is designed to be used as the `ignore` callable for\n    `shutil.copytree`. It skips hidden files (starting with \".\"), the\n    `plugin.py` file, and any broken symbolic links.\n\n    Args:\n        dirpath (str): The path to the directory being scanned.\n        names (list[str]): A list of names of items within `dirpath`.\n\n    Returns:\n        list[str]: A list of item names to be ignored by `shutil.copytree`.\n    \"\"\"\n    skip = []\n    base = Path(dirpath)\n    for name in names:\n        if name == \"plugin.py\":\n            continue\n        if name.startswith(\".\"):\n            skip.append(name)\n            continue\n        entry = base / name\n        if entry.is_symlink():\n            try:\n                entry.resolve(strict=True)\n            except (FileNotFoundError, OSError):\n                skip.append(name)\n    return skip\n</code></pre>"},{"location":"reference/commands/plugins/utils/#bijux_cli.commands.plugins.utils.parse_required_cli_version","title":"<code>parse_required_cli_version(plugin_py: Path) -&gt; str | None</code>","text":"<p>Parses <code>requires_cli_version</code> from a plugin file without executing it.</p> <p>This function safely inspects a Python file using the Abstract Syntax Tree (AST) to find the value of a top-level or class-level variable named <code>requires_cli_version</code>. This avoids the security risks of importing or executing untrusted code.</p> <p>Parameters:</p> <ul> <li> <code>plugin_py</code>               (<code>Path</code>)           \u2013            <p>The path to the <code>plugin.py</code> file to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>str | None: The version specifier string if found, otherwise None.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def parse_required_cli_version(plugin_py: Path) -&gt; str | None:\n    \"\"\"Parses `requires_cli_version` from a plugin file without executing it.\n\n    This function safely inspects a Python file using the Abstract Syntax Tree\n    (AST) to find the value of a top-level or class-level variable named\n    `requires_cli_version`. This avoids the security risks of importing or\n    executing untrusted code.\n\n    Args:\n        plugin_py (Path): The path to the `plugin.py` file to parse.\n\n    Returns:\n        str | None: The version specifier string if found, otherwise None.\n    \"\"\"\n    import ast\n\n    try:\n        with plugin_py.open(\"r\") as f:\n            tree = ast.parse(f.read(), filename=str(plugin_py))\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Assign):\n                for target in node.targets:\n                    if (\n                        (\n                            (\n                                isinstance(target, ast.Attribute)\n                                and target.attr == \"requires_cli_version\"\n                            )\n                            or (\n                                isinstance(target, ast.Name)\n                                and target.id == \"requires_cli_version\"\n                            )\n                        )\n                        and isinstance(node.value, ast.Constant)\n                        and isinstance(node.value.value, str)\n                    ):\n                        return node.value.value\n            if isinstance(node, ast.ClassDef) and node.name == \"Plugin\":\n                for stmt in node.body:\n                    if (\n                        isinstance(stmt, ast.Assign)\n                        and any(\n                            isinstance(t, ast.Name) and t.id == \"requires_cli_version\"\n                            for t in stmt.targets\n                        )\n                        and isinstance(stmt.value, ast.Constant)\n                        and isinstance(stmt.value.value, str)\n                    ):\n                        return stmt.value.value\n\n        return None\n    except (\n        FileNotFoundError,\n        PermissionError,\n        SyntaxError,\n        UnicodeDecodeError,\n        OSError,\n    ):\n        return None\n</code></pre>"},{"location":"reference/commands/plugins/utils/#bijux_cli.commands.plugins.utils.refuse_on_symlink","title":"<code>refuse_on_symlink(directory: Path, command: str, fmt: str, quiet: bool, verbose: bool, debug: bool) -&gt; None</code>","text":"<p>Emits an error and exits if the given directory is a symbolic link.</p> <p>This serves as a security precaution to prevent plugin operations on unexpected filesystem locations.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path</code>)           \u2013            <p>The path to check.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The invoking command name for the error payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format for the error payload.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses output before exiting.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime info in the error payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with code 1 if <code>directory</code> is a symbolic link.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def refuse_on_symlink(\n    directory: Path,\n    command: str,\n    fmt: str,\n    quiet: bool,\n    verbose: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Emits an error and exits if the given directory is a symbolic link.\n\n    This serves as a security precaution to prevent plugin operations on\n    unexpected filesystem locations.\n\n    Args:\n        directory (Path): The path to check.\n        command (str): The invoking command name for the error payload.\n        fmt (str): The requested output format for the error payload.\n        quiet (bool): If True, suppresses output before exiting.\n        verbose (bool): If True, includes runtime info in the error payload.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits the process with code 1 if `directory` is\n            a symbolic link.\n    \"\"\"\n    if directory.is_symlink():\n        from bijux_cli.commands.utilities import emit_error_and_exit\n\n        verb = command.split()[-1]\n        emit_error_and_exit(\n            f\"Refusing to {verb}: plugins dir {directory.name!r} is a symlink.\",\n            code=1,\n            failure=\"symlink_dir\",\n            command=command,\n            fmt=fmt,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/contracts/audit/","title":"Audit Module API Reference","text":"<p>This section documents the internals of the <code>audit</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/audit/#bijux_cli.contracts.audit","title":"<code>bijux_cli.contracts.audit</code>","text":"<p>Defines the contract for the audit logging and diagnostics service.</p> <p>This module specifies the <code>AuditProtocol</code>, a formal interface that any auditing service within the application must implement. This ensures a consistent API for logging command executions and performing system health checks, promoting modularity and testability.</p>"},{"location":"reference/contracts/audit/#bijux_cli.contracts.audit.AuditProtocol","title":"<code>AuditProtocol</code>","text":"<p>               Bases: <code>ProcessPoolProtocol</code>, <code>Protocol</code></p> <p>Defines the contract for audit logging and system diagnostics.</p> <p>This interface specifies the methods required for securely logging command executions, retrieving audit trails, and performing diagnostic checks on the CLI environment. It inherits from <code>ProcessPoolProtocol</code> to manage command execution.</p>"},{"location":"reference/contracts/audit/#bijux_cli.contracts.audit.AuditProtocol.cli_audit","title":"<code>cli_audit() -&gt; None</code>","text":"<p>Performs a CLI-specific audit and status check.</p> <p>This method is the entry point for the <code>bijux audit</code> command. Implementations should gather and log the current audit status without raising exceptions or executing external commands.</p> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Performs a CLI-specific audit and status check.\n\n    This method is the entry point for the `bijux audit` command.\n    Implementations should gather and log the current audit status without\n    raising exceptions or executing external commands.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/audit/#bijux_cli.contracts.audit.AuditProtocol.get_commands","title":"<code>get_commands() -&gt; list[dict[str, Any]]</code>","text":"<p>Returns a copy of all recorded audit commands.</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of dictionaries, where each dictionary represents a logged command execution.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def get_commands(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns a copy of all recorded audit commands.\n\n    Returns:\n        list[dict[str, Any]]: A list of dictionaries, where each dictionary\n            represents a logged command execution.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/audit/#bijux_cli.contracts.audit.AuditProtocol.log","title":"<code>log(cmd: list[str], *, executor: str) -&gt; None</code>","text":"<p>Logs a command execution for auditing purposes.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and its arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name or identifier of the entity that executed the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs a command execution for auditing purposes.\n\n    Args:\n        cmd (list[str]): The command and its arguments to log.\n        executor (str): The name or identifier of the entity that executed\n            the command.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/","title":"Config Module API Reference","text":"<p>This section documents the internals of the <code>config</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config","title":"<code>bijux_cli.contracts.config</code>","text":"<p>Defines the contract for the application configuration service.</p> <p>This module specifies the <code>ConfigProtocol</code>, a formal interface that any configuration management service within the application must implement. This ensures a consistent API for loading, accessing, modifying, and persisting key-value settings, promoting modularity and testability.</p>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol","title":"<code>ConfigProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for application configuration management.</p> <p>This interface specifies the methods for loading, accessing, modifying, and persisting configuration data from various sources (e.g., .env, JSON, or YAML files).</p>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.all","title":"<code>all() -&gt; dict[str, str]</code>","text":"<p>Returns all configuration key-value pairs.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary of all configuration data.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def all(self) -&gt; dict[str, str]:\n    \"\"\"Returns all configuration key-value pairs.\n\n    Returns:\n        dict[str, str]: A dictionary of all configuration data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Clears all configuration data from memory.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all configuration data from memory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Deletes a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to delete.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a configuration key and persists the change.\n\n    Args:\n        key (str): The key to delete.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.export","title":"<code>export(path: str | Path, out_format: str | None = None) -&gt; None</code>","text":"<p>Exports the current configuration to a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the destination file.</p> </li> <li> <code>out_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The desired output format (e.g., 'env'). If None, the format may be inferred from the path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def export(self, path: str | Path, out_format: str | None = None) -&gt; None:\n    \"\"\"Exports the current configuration to a file.\n\n    Args:\n        path (str | Path): The path to the destination file.\n        out_format (str | None): The desired output format (e.g., 'env').\n            If None, the format may be inferred from the path.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Retrieves a configuration value by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The value to return if the key is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The configuration value or the provided default.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieves a configuration value by its key.\n\n    Args:\n        key (str): The key of the value to retrieve.\n        default (Any): The value to return if the key is not found.\n\n    Returns:\n        Any: The configuration value or the provided default.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.list_keys","title":"<code>list_keys() -&gt; list[str]</code>","text":"<p>Returns a list of all configuration keys.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all keys present in the configuration.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def list_keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all configuration keys.\n\n    Returns:\n        list[str]: A list of all keys present in the configuration.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.load","title":"<code>load(path: str | Path | None = None) -&gt; None</code>","text":"<p>Loads configuration from a specified file path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the configuration file. If None, the service may load from a default location.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def load(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Loads configuration from a specified file path.\n\n    Args:\n        path (str | Path | None): The path to the configuration file. If\n            None, the service may load from a default location.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.reload","title":"<code>reload() -&gt; None</code>","text":"<p>Reloads the configuration from its last-known source file.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reloads the configuration from its last-known source file.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.save","title":"<code>save() -&gt; None</code>","text":"<p>Saves the current in-memory configuration state to its source file.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Saves the current in-memory configuration state to its source file.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set or update.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a configuration key and persists the change.\n\n    Args:\n        key (str): The key to set or update.\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config/#bijux_cli.contracts.config.ConfigProtocol.unset","title":"<code>unset(key: str) -&gt; None</code>","text":"<p>Removes a configuration key from the current in-memory session.</p> <p>Unlike <code>delete</code>, this operation may not be immediately persisted to the source file.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to remove from the in-memory configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def unset(self, key: str) -&gt; None:\n    \"\"\"Removes a configuration key from the current in-memory session.\n\n    Unlike `delete`, this operation may not be immediately persisted to the\n    source file.\n\n    Args:\n        key (str): The key to remove from the in-memory configuration.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/","title":"Context Module API Reference","text":"<p>This section documents the internals of the <code>context</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context","title":"<code>bijux_cli.contracts.context</code>","text":"<p>Defines the contract for the request-scoped context service.</p> <p>This module specifies the <code>ContextProtocol</code>, a formal interface for services that manage contextual data associated with a specific operation or request. This pattern allows for state to be carried implicitly through an application's call stack.</p>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol","title":"<code>ContextProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a request-scoped context object.</p> <p>This interface specifies methods for a context that can store arbitrary key-value data and supports both synchronous (<code>with</code>) and asynchronous (<code>async with</code>) context management patterns.</p>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.__aenter__","title":"<code>__aenter__() -&gt; Self</code>  <code>async</code>","text":"<p>Enters the asynchronous context manager.</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The context instance itself.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enters the asynchronous context manager.\n\n    Returns:\n        Self: The context instance itself.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.__aexit__","title":"<code>__aexit__(_exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None</code>  <code>async</code>","text":"<p>Exits the asynchronous context manager.</p> <p>Parameters:</p> <ul> <li> <code>_exc_type</code>               (<code>Any</code>)           \u2013            <p>The exception type, if any.</p> </li> <li> <code>_exc_value</code>               (<code>Any</code>)           \u2013            <p>The exception value, if any.</p> </li> <li> <code>traceback</code>               (<code>Any</code>)           \u2013            <p>The traceback, if any.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>async def __aexit__(self, _exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"Exits the asynchronous context manager.\n\n    Args:\n        _exc_type (Any): The exception type, if any.\n        _exc_value (Any): The exception value, if any.\n        traceback (Any): The traceback, if any.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.__enter__","title":"<code>__enter__() -&gt; Self</code>","text":"<p>Enters the synchronous context manager.</p> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The context instance itself.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Enters the synchronous context manager.\n\n    Returns:\n        Self: The context instance itself.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.__exit__","title":"<code>__exit__(_exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None</code>","text":"<p>Exits the synchronous context manager.</p> <p>Parameters:</p> <ul> <li> <code>_exc_type</code>               (<code>Any</code>)           \u2013            <p>The exception type, if any.</p> </li> <li> <code>_exc_value</code>               (<code>Any</code>)           \u2013            <p>The exception value, if any.</p> </li> <li> <code>traceback</code>               (<code>Any</code>)           \u2013            <p>The traceback, if any.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def __exit__(self, _exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"Exits the synchronous context manager.\n\n    Args:\n        _exc_type (Any): The exception type, if any.\n        _exc_value (Any): The exception value, if any.\n        traceback (Any): The traceback, if any.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Clears all data from the context.</p> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all data from the context.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Retrieves a value by key from the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by key from the context.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context/#bijux_cli.contracts.context.ContextProtocol.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a key-value pair in the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair in the context.\n\n    Args:\n        key (str): The key to set.\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs/","title":"Docs Module API Reference","text":"<p>This section documents the internals of the <code>docs</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/docs/#bijux_cli.contracts.docs","title":"<code>bijux_cli.contracts.docs</code>","text":"<p>Defines the contract for the API specification writing service.</p> <p>This module specifies the <code>DocsProtocol</code>, a formal interface that any service responsible for generating and writing API specification documents (e.g., OpenAPI, JSON Schema) must implement.</p>"},{"location":"reference/contracts/docs/#bijux_cli.contracts.docs.DocsProtocol","title":"<code>DocsProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for writing API specifications.</p> <p>This interface specifies methods for serializing and writing specification documents, such as OpenAPI or JSON Schema, in various formats.</p>"},{"location":"reference/contracts/docs/#bijux_cli.contracts.docs.DocsProtocol.close","title":"<code>close() -&gt; None</code>","text":"<p>Closes the writer and releases any associated resources.</p> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the writer and releases any associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs/#bijux_cli.contracts.docs.DocsProtocol.write","title":"<code>write(spec: dict[str, Any], *, fmt: OutputFormat = OutputFormat.JSON, name: str = 'spec') -&gt; str</code>","text":"<p>Writes a specification to a file.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'spec'</code> )           \u2013            <p>The base name for the output file. Defaults to 'spec'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The path to the written file as a string.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def write(\n    self,\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    name: str = \"spec\",\n) -&gt; str:\n    \"\"\"Writes a specification to a file.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        name (str): The base name for the output file. Defaults to 'spec'.\n\n    Returns:\n        str: The path to the written file as a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs/#bijux_cli.contracts.docs.DocsProtocol.write_sync","title":"<code>write_sync(spec: dict[Any, Any], fmt: OutputFormat, name: str | Path) -&gt; Path</code>","text":"<p>Writes the specification to a file synchronously.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[Any, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The output format (e.g., JSON, YAML).</p> </li> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The path or name for the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>The <code>Path</code> object pointing to the written file.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def write_sync(\n    self, spec: dict[Any, Any], fmt: OutputFormat, name: str | Path\n) -&gt; Path:\n    \"\"\"Writes the specification to a file synchronously.\n\n    Args:\n        spec (dict[Any, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format (e.g., JSON, YAML).\n        name (str | Path): The path or name for the output file.\n\n    Returns:\n        Path: The `Path` object pointing to the written file.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/doctor/","title":"Doctor Module API Reference","text":"<p>This section documents the internals of the <code>doctor</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/doctor/#bijux_cli.contracts.doctor","title":"<code>bijux_cli.contracts.doctor</code>","text":"<p>Defines the contract for the CLI health check and diagnostics service.</p> <p>This module specifies the <code>DoctorProtocol</code>, a formal interface that any service responsible for running diagnostic health checks on the CLI and its environment must implement.</p>"},{"location":"reference/contracts/doctor/#bijux_cli.contracts.doctor.DoctorProtocol","title":"<code>DoctorProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for CLI health checks.</p> <p>This interface specifies the methods for performing system health checks and gathering diagnostic information about the CLI and its environment.</p>"},{"location":"reference/contracts/doctor/#bijux_cli.contracts.doctor.DoctorProtocol.check_health","title":"<code>check_health() -&gt; str</code>","text":"<p>Performs health checks and returns a status string.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string describing the overall health status of the CLI.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/doctor.py</code> <pre><code>def check_health(self) -&gt; str:\n    \"\"\"Performs health checks and returns a status string.\n\n    Returns:\n        str: A string describing the overall health status of the CLI.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/emitter/","title":"Emitter Module API Reference","text":"<p>This section documents the internals of the <code>emitter</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/emitter/#bijux_cli.contracts.emitter","title":"<code>bijux_cli.contracts.emitter</code>","text":"<p>Defines the contract for the structured output emission service.</p> <p>This module specifies the <code>EmitterProtocol</code>, a formal interface that any service responsible for serializing data payloads (e.g., to JSON or YAML) and emitting them to an output stream must implement.</p>"},{"location":"reference/contracts/emitter/#bijux_cli.contracts.emitter.EmitterProtocol","title":"<code>EmitterProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for emitting structured output.</p> <p>This interface specifies the methods for serializing and emitting data in various formats, often integrating with a logging or telemetry system.</p>"},{"location":"reference/contracts/emitter/#bijux_cli.contracts.emitter.EmitterProtocol.emit","title":"<code>emit(payload: Any, *, fmt: OutputFormat | None = None, pretty: bool = False, level: str = 'info', message: str = 'Emitting output', output: str | None = None, **context: Any) -&gt; None</code>","text":"<p>Serializes and emits a structured data payload.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Any</code>)           \u2013            <p>The data payload to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format for serialization.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, pretty-prints the output with indentation.</p> </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'info'</code> )           \u2013            <p>The log level for any accompanying message.</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>'Emitting output'</code> )           \u2013            <p>A descriptive message for logging.</p> </li> <li> <code>output</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional pre-formatted string to emit instead of serializing the payload.</p> </li> <li> <code>**context</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key-value pairs for structured logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/emitter.py</code> <pre><code>def emit(\n    self,\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None:\n    \"\"\"Serializes and emits a structured data payload.\n\n    Args:\n        payload (Any): The data payload to serialize and emit.\n        fmt (OutputFormat | None): The output format for serialization.\n        pretty (bool): If True, pretty-prints the output with indentation.\n        level (str): The log level for any accompanying message.\n        message (str): A descriptive message for logging.\n        output (str | None): An optional pre-formatted string to emit\n            instead of serializing the payload.\n        **context (Any): Additional key-value pairs for structured logging.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/emitter/#bijux_cli.contracts.emitter.EmitterProtocol.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Flushes any buffered output to its destination stream.</p> Source code in <code>src/bijux_cli/contracts/emitter.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered output to its destination stream.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/","title":"History Module API Reference","text":"<p>This section documents the internals of the <code>history</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history","title":"<code>bijux_cli.contracts.history</code>","text":"<p>Defines the contract for the command history management service.</p> <p>This module specifies the <code>HistoryProtocol</code>, a formal interface that any service responsible for recording, retrieving, and managing CLI command history events must implement.</p>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol","title":"<code>HistoryProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for command history management.</p> <p>This interface specifies the methods for recording, retrieving, and managing command history events, including persistence and import/export functionality.</p>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.add","title":"<code>add(command: str, *, params: Sequence[str] | None = None, success: bool | None = True, return_code: int | None = 0, duration_ms: float | None = None) -&gt; None</code>","text":"<p>Records a command execution event.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command string (e.g., \"status --verbose\").</p> </li> <li> <code>params</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The raw argument vector as executed.</p> </li> <li> <code>success</code>               (<code>bool | None</code>, default:                   <code>True</code> )           \u2013            <p>True if the command was successful.</p> </li> <li> <code>return_code</code>               (<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>The integer exit code of the command.</p> </li> <li> <code>duration_ms</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Total execution time in milliseconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def add(\n    self,\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None:\n    \"\"\"Records a command execution event.\n\n    Args:\n        command (str): The full command string (e.g., \"status --verbose\").\n        params (Sequence[str] | None): The raw argument vector as executed.\n        success (bool | None): True if the command was successful.\n        return_code (int | None): The integer exit code of the command.\n        duration_ms (float | None): Total execution time in milliseconds.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Erases all command history events from the store.</p> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Erases all command history events from the store.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.export","title":"<code>export(path: Path) -&gt; None</code>","text":"<p>Exports all history entries to a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The target file path, which will be overwritten.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def export(self, path: Path) -&gt; None:\n    \"\"\"Exports all history entries to a file.\n\n    Args:\n        path (Path): The target file path, which will be overwritten.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Persists any in-memory history data to permanent storage.</p> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Persists any in-memory history data to permanent storage.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.import_","title":"<code>import_(path: Path) -&gt; None</code>","text":"<p>Imports history entries from a file, replacing existing entries.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The source file path containing history data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def import_(self, path: Path) -&gt; None:\n    \"\"\"Imports history entries from a file, replacing existing entries.\n\n    Args:\n        path (Path): The source file path containing history data.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history/#bijux_cli.contracts.history.HistoryProtocol.list","title":"<code>list(*, limit: int | None = 20, group_by: str | None = None, filter_cmd: str | None = None, sort: str | None = None) -&gt; list[dict[str, Any]]</code>","text":"<p>Retrieves command history events.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>20</code> )           \u2013            <p>The maximum number of events to return.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A field name to group events by.</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A substring to filter commands by.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A field name to sort the results by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of history event dictionaries.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Retrieves command history events.\n\n    Args:\n        limit (int | None): The maximum number of events to return.\n        group_by (str | None): A field name to group events by.\n        filter_cmd (str | None): A substring to filter commands by.\n        sort (str | None): A field name to sort the results by.\n\n    Returns:\n        list[dict[str, Any]]: A list of history event dictionaries.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory/","title":"Memory Module API Reference","text":"<p>This section documents the internals of the <code>memory</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory","title":"<code>bijux_cli.contracts.memory</code>","text":"<p>Defines the contract for the transient in-memory key-value service.</p> <p>This module specifies the <code>MemoryProtocol</code>, a formal interface that any service providing a non-persistent, in-memory key-value store must implement. This is used for managing ephemeral state within the CLI.</p>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol","title":"<code>MemoryProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a simple in-memory key-value store.</p> <p>This interface specifies the essential methods for a basic key-value data storage service. It is used for managing ephemeral state within the CLI that does not need to persist across sessions.</p>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Removes all key-value pairs from the store.</p> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all key-value pairs from the store.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Deletes a key-value pair by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a key-value pair by its key.\n\n    Args:\n        key (str): The key of the value to delete.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Retrieves a value by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by its key.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol.keys","title":"<code>keys() -&gt; list[str]</code>","text":"<p>Returns a list of all keys currently in the store.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all string keys.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all keys currently in the store.\n\n    Returns:\n        list[str]: A list of all string keys.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory/#bijux_cli.contracts.memory.MemoryProtocol.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a key-value pair in the store.</p> <p>If the key already exists, its value will be overwritten.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value being set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair in the store.\n\n    If the key already exists, its value will be overwritten.\n\n    Args:\n        key (str): The key for the value being set.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/","title":"Observability Module API Reference","text":"<p>This section documents the internals of the <code>observability</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability","title":"<code>bijux_cli.contracts.observability</code>","text":"<p>Defines the contract for the structured logging and observability service.</p> <p>This module specifies the <code>ObservabilityProtocol</code>, a formal interface that any service providing structured logging capabilities must implement. It ensures a consistent API for configuring loggers, binding contextual data, and emitting log messages throughout the application.</p>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol","title":"<code>ObservabilityProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a structured logging facade.</p> <p>This interface specifies methods for configuring logging, binding contextual data, and emitting log messages in a structured format.</p>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.bind","title":"<code>bind(**_kv: Any) -&gt; Self</code>","text":"<p>Binds context key-value pairs to the logger for future log entries.</p> <p>Parameters:</p> <ul> <li> <code>**_kv</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Key-value pairs to bind to the logging context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def bind(self, **_kv: Any) -&gt; Self:\n    \"\"\"Binds context key-value pairs to the logger for future log entries.\n\n    Args:\n        **_kv (Any): Key-value pairs to bind to the logging context.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.close","title":"<code>close() -&gt; None</code>","text":"<p>Closes the logger and releases any associated resources.</p> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the logger and releases any associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.get_logger","title":"<code>get_logger() -&gt; FilteringBoundLogger | None</code>","text":"<p>Returns the underlying logger instance.</p> <p>Returns:</p> <ul> <li> <code>FilteringBoundLogger | None</code>           \u2013            <p>FilteringBoundLogger | None: The logger instance (e.g., from <code>structlog</code>) or None if it has not been configured.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def get_logger(self) -&gt; FilteringBoundLogger | None:\n    \"\"\"Returns the underlying logger instance.\n\n    Returns:\n        FilteringBoundLogger | None: The logger instance (e.g., from\n            `structlog`) or None if it has not been configured.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.log","title":"<code>log(level: str, msg: str, *, extra: dict[str, Any] | None = None) -&gt; Self</code>","text":"<p>Logs a message with the specified level and context.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The log level (e.g., 'debug', 'info', 'error').</p> </li> <li> <code>msg</code>               (<code>str</code>)           \u2013            <p>The message to log.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional dictionary of additional context to include in the log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def log(\n    self,\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Logs a message with the specified level and context.\n\n    Args:\n        level (str): The log level (e.g., 'debug', 'info', 'error').\n        msg (str): The message to log.\n        extra (dict[str, Any] | None): An optional dictionary of\n            additional context to include in the log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.set_telemetry","title":"<code>set_telemetry(telemetry: TelemetryProtocol) -&gt; Self</code>","text":"<p>Sets the telemetry service instance for integration.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>An instance of the telemetry service.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def set_telemetry(self, telemetry: TelemetryProtocol) -&gt; Self:\n    \"\"\"Sets the telemetry service instance for integration.\n\n    Args:\n        telemetry (TelemetryProtocol): An instance of the telemetry service.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability/#bijux_cli.contracts.observability.ObservabilityProtocol.setup","title":"<code>setup(*, debug: bool = False) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Creates and configures a new instance of the observability service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, configures the logger for debug-level output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>A new, configured instance of the service.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>@classmethod\ndef setup(cls, *, debug: bool = False) -&gt; Self:\n    \"\"\"Creates and configures a new instance of the observability service.\n\n    Args:\n        debug (bool): If True, configures the logger for debug-level output.\n\n    Returns:\n        Self: A new, configured instance of the service.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process/","title":"Process Module API Reference","text":"<p>This section documents the internals of the <code>process</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/process/#bijux_cli.contracts.process","title":"<code>bijux_cli.contracts.process</code>","text":"<p>Defines the contract for a worker process pool service.</p> <p>This module specifies the <code>ProcessPoolProtocol</code>, a formal interface that any service managing a pool of worker processes for command execution must implement. This allows for abstracting the details of subprocess management.</p>"},{"location":"reference/contracts/process/#bijux_cli.contracts.process.ProcessPoolProtocol","title":"<code>ProcessPoolProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a worker process pool.</p> <p>This interface specifies the methods for running commands in isolated worker processes and managing the lifecycle of the pool.</p>"},{"location":"reference/contracts/process/#bijux_cli.contracts.process.ProcessPoolProtocol.get_status","title":"<code>get_status() -&gt; dict[str, Any]</code>","text":"<p>Returns the current status of the process pool.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary containing status information, such as the number of active workers, queue size, etc.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def get_status(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the current status of the process pool.\n\n    Returns:\n        dict[str, Any]: A dictionary containing status information, such as\n            the number of active workers, queue size, etc.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process/#bijux_cli.contracts.process.ProcessPoolProtocol.run","title":"<code>run(cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]</code>","text":"<p>Executes a command in a worker process.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>A list of command arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name or identifier of the executor to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the return code, standard output (stdout), and standard error (stderr) as bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Executes a command in a worker process.\n\n    Args:\n        cmd (list[str]): A list of command arguments to execute.\n        executor (str): The name or identifier of the executor to use.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the return code,\n            standard output (stdout), and standard error (stderr) as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process/#bijux_cli.contracts.process.ProcessPoolProtocol.shutdown","title":"<code>shutdown() -&gt; None</code>","text":"<p>Shuts down the process pool and releases all associated resources.</p> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shuts down the process pool and releases all associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/","title":"Registry Module API Reference","text":"<p>This section documents the internals of the <code>registry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry","title":"<code>bijux_cli.contracts.registry</code>","text":"<p>Defines the contract for the plugin registry service.</p> <p>This module specifies the <code>RegistryProtocol</code>, a formal interface that any service responsible for managing the lifecycle of CLI plugins must implement. This includes registering, retrieving, and invoking hooks on plugins.</p>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol","title":"<code>RegistryProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for plugin management.</p> <p>This interface specifies the methods for registering, deregistering, and interacting with plugins, as well as for invoking plugin hooks.</p>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.call_hook","title":"<code>call_hook(hook: str, *args: Any, **kwargs: Any) -&gt; Any</code>  <code>async</code>","text":"<p>Invokes a hook on all registered plugins that implement it.</p> <p>Parameters:</p> <ul> <li> <code>hook</code>               (<code>str</code>)           \u2013            <p>The name of the hook to invoke.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the hook.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the hook.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the hook invocation. The exact return type depends on the specific hook's definition and implementation.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>async def call_hook(self, hook: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Invokes a hook on all registered plugins that implement it.\n\n    Args:\n        hook (str): The name of the hook to invoke.\n        *args (Any): Positional arguments to pass to the hook.\n        **kwargs (Any): Keyword arguments to pass to the hook.\n\n    Returns:\n        Any: The result of the hook invocation. The exact return type\n            depends on the specific hook's definition and implementation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.deregister","title":"<code>deregister(name: str) -&gt; None</code>","text":"<p>Deregisters a plugin from the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to deregister.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def deregister(self, name: str) -&gt; None:\n    \"\"\"Deregisters a plugin from the registry.\n\n    Args:\n        name (str): The name or alias of the plugin to deregister.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.get","title":"<code>get(name: str) -&gt; object</code>","text":"<p>Retrieves a plugin by its name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>object</code> (              <code>object</code> )          \u2013            <p>The registered plugin object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no plugin with the given name or alias is registered.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def get(self, name: str) -&gt; object:\n    \"\"\"Retrieves a plugin by its name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        object: The registered plugin object.\n\n    Raises:\n        KeyError: If no plugin with the given name or alias is registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.has","title":"<code>has(name: str) -&gt; bool</code>","text":"<p>Checks if a plugin exists in the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the plugin is registered, False otherwise.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def has(self, name: str) -&gt; bool:\n    \"\"\"Checks if a plugin exists in the registry.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        bool: True if the plugin is registered, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.meta","title":"<code>meta(name: str) -&gt; dict[str, str]</code>","text":"<p>Returns metadata for a specific plugin.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary containing the plugin's metadata, such as its version and alias.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def meta(self, name: str) -&gt; dict[str, str]:\n    \"\"\"Returns metadata for a specific plugin.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        dict[str, str]: A dictionary containing the plugin's metadata, such\n            as its version and alias.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.names","title":"<code>names() -&gt; list[str]</code>","text":"<p>Returns all registered plugin names.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of the primary names of all registered plugins.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def names(self) -&gt; list[str]:\n    \"\"\"Returns all registered plugin names.\n\n    Returns:\n        list[str]: A list of the primary names of all registered plugins.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry/#bijux_cli.contracts.registry.RegistryProtocol.register","title":"<code>register(name: str, plugin: object, *, alias: str | None = None, version: str | None = None) -&gt; None</code>","text":"<p>Registers a plugin with the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The primary name of the plugin.</p> </li> <li> <code>plugin</code>               (<code>object</code>)           \u2013            <p>The plugin object to register.</p> </li> <li> <code>alias</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional alias for the plugin.</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def register(\n    self,\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a plugin with the registry.\n\n    Args:\n        name (str): The primary name of the plugin.\n        plugin (object): The plugin object to register.\n        alias (str | None): An optional alias for the plugin.\n        version (str | None): An optional version string for the plugin.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/retry/","title":"Retry Module API Reference","text":"<p>This section documents the internals of the <code>retry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/retry/#bijux_cli.contracts.retry","title":"<code>bijux_cli.contracts.retry</code>","text":"<p>Defines the contract for operation retry policies.</p> <p>This module specifies the <code>RetryPolicyProtocol</code>, a formal interface that any service providing retry logic for potentially failing operations must implement. This is particularly useful for handling transient errors in network requests or other I/O-bound tasks.</p>"},{"location":"reference/contracts/retry/#bijux_cli.contracts.retry.RetryPolicyProtocol","title":"<code>RetryPolicyProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for retry policies in asynchronous operations.</p> <p>This interface specifies the methods for executing an operation with retry logic (e.g., exponential backoff) and for resetting the policy's internal state.</p>"},{"location":"reference/contracts/retry/#bijux_cli.contracts.retry.RetryPolicyProtocol.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets the internal state of the retry policy.</p> <p>This is useful for reusing a policy instance for a new, independent operation.</p> Source code in <code>src/bijux_cli/contracts/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the internal state of the retry policy.\n\n    This is useful for reusing a policy instance for a new, independent\n    operation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/retry/#bijux_cli.contracts.retry.RetryPolicyProtocol.run","title":"<code>run(supplier: Callable[[], Awaitable[T]], seconds: float = 1.0) -&gt; T</code>  <code>async</code>","text":"<p>Runs an asynchronous operation with a retry policy.</p> <p>Implementations of this method will repeatedly call the <code>supplier</code> until it succeeds or the retry policy is exhausted.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>A no-argument function that returns an awaitable (e.g., a coroutine).</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout for each attempt in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The successful result of the operation.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/retry.py</code> <pre><code>async def run(\n    self, supplier: Callable[[], Awaitable[T]], seconds: float = 1.0\n) -&gt; T:\n    \"\"\"Runs an asynchronous operation with a retry policy.\n\n    Implementations of this method will repeatedly call the `supplier`\n    until it succeeds or the retry policy is exhausted.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): A no-argument function that\n            returns an awaitable (e.g., a coroutine).\n        seconds (float): The timeout for each attempt in seconds.\n\n    Returns:\n        T: The successful result of the operation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer/","title":"Serializer Module API Reference","text":"<p>This section documents the internals of the <code>serializer</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer","title":"<code>bijux_cli.contracts.serializer</code>","text":"<p>Defines the contract for the object serialization service.</p> <p>This module specifies the <code>SerializerProtocol</code>, a formal interface that any service responsible for serializing objects to strings or bytes (e.g., in JSON or YAML format) and deserializing them back must implement.</p>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer.SerializerProtocol","title":"<code>SerializerProtocol</code>","text":"<p>               Bases: <code>Protocol[T]</code></p> <p>Defines the contract for stateless, thread-safe object serialization.</p> <p>This interface specifies methods for serializing and deserializing objects to and from strings or bytes in various formats, such as JSON or YAML.</p>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer.SerializerProtocol.dumps","title":"<code>dumps(obj: T, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; str</code>","text":"<p>Serializes an object to a string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>T</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized object as a string.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: T,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a string.\n\n    Args:\n        obj (T): The object to serialize.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        str: The serialized object as a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer.SerializerProtocol.dumps_bytes","title":"<code>dumps_bytes(obj: T, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; bytes</code>","text":"<p>Serializes an object to bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>T</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized object as bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: T,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to bytes.\n\n    Args:\n        obj (T): The object to serialize.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        bytes: The serialized object as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer.SerializerProtocol.emit","title":"<code>emit(payload: T, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; None</code>","text":"<p>Serializes and emits a payload to standard output.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>T</code>)           \u2013            <p>The object to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def emit(\n    self, payload: T, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False\n) -&gt; None:\n    \"\"\"Serializes and emits a payload to standard output.\n\n    Args:\n        payload (T): The object to serialize and emit.\n        fmt (OutputFormat): The output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer/#bijux_cli.contracts.serializer.SerializerProtocol.loads","title":"<code>loads(data: str | bytes, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; T</code>","text":"<p>Deserializes data from a string or bytes into an object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The format of the input data. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing, though often unused during deserialization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; T:\n    \"\"\"Deserializes data from a string or bytes into an object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input data. Defaults to\n            `OutputFormat.JSON`.\n        pretty (bool): A hint that may affect parsing, though often unused\n            during deserialization.\n\n    Returns:\n        T: The deserialized object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry/","title":"Telemetry Module API Reference","text":"<p>This section documents the internals of the <code>telemetry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/telemetry/#bijux_cli.contracts.telemetry","title":"<code>bijux_cli.contracts.telemetry</code>","text":"<p>Defines the contract for the fire-and-forget telemetry service.</p> <p>This module specifies the <code>TelemetryProtocol</code>, a formal interface that any service responsible for collecting and managing \"fire-and-forget\" telemetry or analytics events must implement.</p>"},{"location":"reference/contracts/telemetry/#bijux_cli.contracts.telemetry.TelemetryProtocol","title":"<code>TelemetryProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for fire-and-forget analytics collection.</p> <p>This interface specifies the methods for recording telemetry events and managing the lifecycle of the telemetry service.</p>"},{"location":"reference/contracts/telemetry/#bijux_cli.contracts.telemetry.TelemetryProtocol.enable","title":"<code>enable() -&gt; None</code>","text":"<p>Enables the collection of telemetry data.</p> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Enables the collection of telemetry data.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry/#bijux_cli.contracts.telemetry.TelemetryProtocol.event","title":"<code>event(name: str, payload: dict[str, Any]) -&gt; None | Coroutine[Any, Any, None]</code>","text":"<p>Records a telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the event (e.g., \"COMMAND_START\").</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary of key-value pairs containing the event data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | Coroutine[Any, Any, None]</code>           \u2013            <p>Either None (sync) or an awaitable resolving to None (async).</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def event(\n    self, name: str, payload: dict[str, Any]\n) -&gt; None | Coroutine[Any, Any, None]:\n    \"\"\"Records a telemetry event.\n\n    Args:\n        name (str): The name of the event (e.g., \"COMMAND_START\").\n        payload (dict[str, Any]): A dictionary of key-value pairs\n            containing the event data.\n\n    Returns:\n        Either None (sync) or an awaitable resolving to None (async).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry/#bijux_cli.contracts.telemetry.TelemetryProtocol.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Flushes any buffered telemetry events to their destination.</p> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered telemetry events to their destination.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/constants/","title":"Constants Module API Reference","text":"<p>This section documents the internals of the <code>constants</code> module in Bijux CLI. </p>"},{"location":"reference/core/constants/#bijux_cli.core.constants","title":"<code>bijux_cli.core.constants</code>","text":"<p>Defines shared constants and help text for the Bijux CLI.</p> <p>This module centralizes constant values used throughout the application, such as default timeouts and standardized help messages for common CLI flags. This practice avoids magic strings and numbers, improving maintainability and ensuring consistency across all commands.</p>"},{"location":"reference/core/context/","title":"Context Module API Reference","text":"<p>This section documents the internals of the <code>context</code> module in Bijux CLI. </p>"},{"location":"reference/core/context/#bijux_cli.core.context","title":"<code>bijux_cli.core.context</code>","text":"<p>Provides a concrete implementation for request-scoped context management.</p> <p>This module defines the <code>Context</code> class, which implements the <code>ContextProtocol</code>. It uses Python's <code>contextvars</code> to provide a thread-safe and async-safe mechanism for storing and retrieving key-value data associated with a specific command execution or request. This allows state to be passed through the application's call stack without explicit argument passing.</p>"},{"location":"reference/core/context/#bijux_cli.core.context.Context","title":"<code>Context(di: DIContainer)</code>","text":"<p>               Bases: <code>ContextProtocol</code></p> <p>Provides thread-safe, request-scoped storage for CLI commands.</p> <p>This class uses <code>contextvars</code> to manage a dictionary of data that is isolated to the current task or thread. It is intended to be used as both a synchronous and asynchronous context manager.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary storing the context's data.</p> </li> <li> <code>_token</code>               (<code>Token | None</code>)           \u2013            <p>The token for resetting the <code>ContextVar</code>.</p> </li> </ul> <p>Initializes a new Context instance.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container used to resolve the logging service.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@inject\ndef __init__(self, di: DIContainer) -&gt; None:\n    \"\"\"Initializes a new Context instance.\n\n    Args:\n        di (DIContainer): The dependency injection container used to\n            resolve the logging service.\n    \"\"\"\n    self._di = di\n    self._log: ObservabilityProtocol = di.resolve(ObservabilityProtocol)\n    self._data: dict[str, Any] = {}\n    self._token: Token[dict[str, Any] | None] | None = None\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context initialized\", extra={})\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.__aenter__","title":"<code>__aenter__() -&gt; Context</code>  <code>async</code>","text":"<p>Enters the context as an asynchronous manager.</p> <p>This sets the current <code>contextvar</code> to this instance's data dictionary.</p> <p>Returns:</p> <ul> <li> <code>Context</code> (              <code>Context</code> )          \u2013            <p>The context instance itself.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>async def __aenter__(self) -&gt; Context:\n    \"\"\"Enters the context as an asynchronous manager.\n\n    This sets the current `contextvar` to this instance's data dictionary.\n\n    Returns:\n        Context: The context instance itself.\n    \"\"\"\n    self._token = _current_context.set(self._data)\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Async context entered\", extra={})\n    return self\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.__aexit__","title":"<code>__aexit__(_exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None</code>  <code>async</code>","text":"<p>Exits the asynchronous context manager.</p> <p>This resets the <code>contextvar</code> to its previous state.</p> <p>Parameters:</p> <ul> <li> <code>_exc_type</code>               (<code>Any</code>)           \u2013            <p>Exception type, if any (unused).</p> </li> <li> <code>_exc_value</code>               (<code>Any</code>)           \u2013            <p>Exception value, if any (unused).</p> </li> <li> <code>traceback</code>               (<code>Any</code>)           \u2013            <p>Traceback, if any (unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>async def __aexit__(self, _exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"Exits the asynchronous context manager.\n\n    This resets the `contextvar` to its previous state.\n\n    Args:\n        _exc_type (Any): Exception type, if any (unused).\n        _exc_value (Any): Exception value, if any (unused).\n        traceback (Any): Traceback, if any (unused).\n\n    Returns:\n        None:\n    \"\"\"\n    if self._token:\n        _current_context.reset(self._token)\n        self._token = None\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Async context exited\", extra={})\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.__enter__","title":"<code>__enter__() -&gt; Context</code>","text":"<p>Enters the context as a synchronous manager.</p> <p>This sets the current <code>contextvar</code> to this instance's data dictionary.</p> <p>Returns:</p> <ul> <li> <code>Context</code> (              <code>Context</code> )          \u2013            <p>The context instance itself.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def __enter__(self) -&gt; Context:\n    \"\"\"Enters the context as a synchronous manager.\n\n    This sets the current `contextvar` to this instance's data dictionary.\n\n    Returns:\n        Context: The context instance itself.\n    \"\"\"\n    self._token = _current_context.set(self._data)\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context entered\", extra={})\n    return self\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.__exit__","title":"<code>__exit__(_exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None</code>","text":"<p>Exits the synchronous context manager.</p> <p>This resets the <code>contextvar</code> to its previous state.</p> <p>Parameters:</p> <ul> <li> <code>_exc_type</code>               (<code>Any</code>)           \u2013            <p>Exception type, if any (unused).</p> </li> <li> <code>_exc_value</code>               (<code>Any</code>)           \u2013            <p>Exception value, if any (unused).</p> </li> <li> <code>traceback</code>               (<code>Any</code>)           \u2013            <p>Traceback, if any (unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def __exit__(self, _exc_type: Any, _exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"Exits the synchronous context manager.\n\n    This resets the `contextvar` to its previous state.\n\n    Args:\n        _exc_type (Any): Exception type, if any (unused).\n        _exc_value (Any): Exception value, if any (unused).\n        traceback (Any): Traceback, if any (unused).\n\n    Returns:\n        None:\n    \"\"\"\n    if self._token:\n        _current_context.reset(self._token)\n        self._token = None\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context exited\", extra={})\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Removes all values from the context's data.</p> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all values from the context's data.\"\"\"\n    self._data.clear()\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context cleared\", extra={})\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.current_data","title":"<code>current_data() -&gt; dict[str, Any]</code>  <code>classmethod</code>","text":"<p>Returns the dictionary for the currently active CLI context.</p> <p>This provides direct access to the data stored in the underlying <code>contextvar</code> for the current execution scope.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: The active context data dictionary.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\ndef current_data(cls) -&gt; dict[str, Any]:\n    \"\"\"Returns the dictionary for the currently active CLI context.\n\n    This provides direct access to the data stored in the underlying\n    `contextvar` for the current execution scope.\n\n    Returns:\n        dict[str, Any]: The active context data dictionary.\n    \"\"\"\n    data = _current_context.get()\n    if data is None:\n        data = {}\n        _current_context.set(data)\n    return data\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Gets a value from the current context's data.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key is not found in the context.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Gets a value from the current context's data.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key is not found in the context.\n    \"\"\"\n    if key not in self._data:\n        if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n            self._log.log(\"warning\", \"Context key not found\", extra={\"key\": key})\n        raise KeyError(f\"Key '{key}' not found in context\")\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\n            \"debug\",\n            \"Context get\",\n            extra={\"key\": key, \"value\": str(self._data[key])},\n        )\n    return self._data[key]\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a value in the current context's data.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a value in the current context's data.\n\n    Args:\n        key (str): The key for the value.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    self._data[key] = value\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\n            \"debug\", \"Context set\", extra={\"key\": key, \"value\": str(value)}\n        )\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.set_current_data","title":"<code>set_current_data(data: dict[str, Any]) -&gt; None</code>  <code>classmethod</code>","text":"<p>Sets the dictionary for the currently active CLI context.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The data to use for the active context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\ndef set_current_data(cls, data: dict[str, Any]) -&gt; None:\n    \"\"\"Sets the dictionary for the currently active CLI context.\n\n    Args:\n        data (dict[str, Any]): The data to use for the active context.\n\n    Returns:\n        None:\n    \"\"\"\n    _current_context.set(data)\n</code></pre>"},{"location":"reference/core/context/#bijux_cli.core.context.Context.use_context","title":"<code>use_context(data: dict[str, Any]) -&gt; Iterator[None]</code>  <code>classmethod</code>","text":"<p>Temporarily replaces the current context data within a <code>with</code> block.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary to use as the context for the duration of the <code>with</code> block.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\n@contextmanager\ndef use_context(cls, data: dict[str, Any]) -&gt; Iterator[None]:\n    \"\"\"Temporarily replaces the current context data within a `with` block.\n\n    Args:\n        data (dict[str, Any]): The dictionary to use as the context for\n            the duration of the `with` block.\n\n    Yields:\n        None:\n    \"\"\"\n    token = _current_context.set(data)\n    try:\n        yield\n    finally:\n        _current_context.reset(token)\n</code></pre>"},{"location":"reference/core/di/","title":"Di Module API Reference","text":"<p>This section documents the internals of the <code>di</code> module in Bijux CLI. </p>"},{"location":"reference/core/di/#bijux_cli.core.di","title":"<code>bijux_cli.core.di</code>","text":"<p>Provides the central dependency injection container for the Bijux CLI.</p> <p>This module defines the <code>DIContainer</code> class, a thread-safe singleton that manages the registration, resolution, and lifecycle of all services within the application. It allows components to be loosely coupled by requesting dependencies based on abstract protocols rather than concrete classes.</p> Key features include <ul> <li>Singleton pattern for global access via <code>DIContainer.current()</code>.</li> <li>Thread-safe operations for concurrent environments.</li> <li>Lazy instantiation of services upon first request.</li> <li>Support for named registrations to allow multiple implementations of the     same protocol.</li> <li>Both synchronous (<code>resolve</code>) and asynchronous (<code>resolve_async</code>) service     resolution.</li> <li>Circular dependency detection.</li> </ul>"},{"location":"reference/core/di/#bijux_cli.core.di.AppConfigModule","title":"<code>AppConfigModule</code>","text":"<p>               Bases: <code>Module</code></p> <p>An <code>injector</code> module for configuring core CLI dependencies.</p>"},{"location":"reference/core/di/#bijux_cli.core.di.AppConfigModule.configure","title":"<code>configure(binder: Binder) -&gt; None</code>","text":"<p>Binds the <code>ConfigProtocol</code> to its default <code>Config</code> implementation.</p> <p>Parameters:</p> <ul> <li> <code>binder</code>               (<code>Binder</code>)           \u2013            <p>The <code>injector</code> binder instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def configure(self, binder: Binder) -&gt; None:\n    \"\"\"Binds the `ConfigProtocol` to its default `Config` implementation.\n\n    Args:\n        binder (Binder): The `injector` binder instance.\n\n    Returns:\n        None:\n    \"\"\"\n    binder.bind(ConfigProtocol, to=Config, scope=singleton)\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer","title":"<code>DIContainer()</code>","text":"<p>A thread-safe, singleton dependency injection container.</p> <p>This class manages the lifecycle of services, including registration of factories, lazy instantiation, and resolution. It integrates with an underlying <code>injector</code> for basic services and handles custom named registrations and circular dependency detection.</p> <p>Attributes:</p> <ul> <li> <code>_instance</code>               (<code>DIContainer | None</code>)           \u2013            <p>The singleton instance of the container.</p> </li> <li> <code>_lock</code>               (<code>RLock</code>)           \u2013            <p>A reentrant lock to ensure thread safety.</p> </li> <li> <code>_resolving</code>               (<code>ContextVar</code>)           \u2013            <p>A context variable to track services currently being resolved, used for circular dependency detection.</p> </li> <li> <code>_obs</code>               (<code>ObservabilityProtocol | None</code>)           \u2013            <p>A cached reference to the logging service for internal use.</p> </li> <li> <code>_injector</code>               (<code>Injector</code>)           \u2013            <p>The underlying <code>injector</code> library instance.</p> </li> <li> <code>_store</code>               (<code>dict</code>)           \u2013            <p>A mapping of (key, name) tuples to registered factories or values.</p> </li> <li> <code>_services</code>               (<code>dict</code>)           \u2013            <p>A cache of resolved service instances.</p> </li> </ul> <p>Initializes the container's internal stores.</p> <p>This method is idempotent; it does nothing if the container has already been initialized.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the container's internal stores.\n\n    This method is idempotent; it does nothing if the container has already\n    been initialized.\n    \"\"\"\n    if getattr(self, \"_initialised\", False):\n        return\n    self._injector = Injector(AppConfigModule())\n    self._store: dict[\n        tuple[type[Any] | str, str | None], Callable[[], Any | Awaitable[Any]] | Any\n    ] = {}\n    self._services: dict[tuple[type[Any] | str, str | None], Any] = {}\n    self._obs: ObservabilityProtocol | None = None\n    self._initialised = True\n    self._log_static(logging.INFO, \"DIContainer initialised\")\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.__new__","title":"<code>__new__() -&gt; DIContainer</code>","text":"<p>Creates or returns the singleton instance of the container.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def __new__(cls) -&gt; DIContainer:\n    \"\"\"Creates or returns the singleton instance of the container.\"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.current","title":"<code>current() -&gt; DIContainer</code>  <code>classmethod</code>","text":"<p>Returns the active singleton instance of the <code>DIContainer</code>.</p> <p>Returns:</p> <ul> <li> <code>DIContainer</code> (              <code>DIContainer</code> )          \u2013            <p>The singleton instance.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\ndef current(cls) -&gt; DIContainer:\n    \"\"\"Returns the active singleton instance of the `DIContainer`.\n\n    Returns:\n        DIContainer: The singleton instance.\n    \"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = cls()\n            cls._log_static(\n                logging.WARNING, \"DIContainer.current auto-initialized singleton\"\n            )\n        return cls._instance\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.factories","title":"<code>factories() -&gt; Sequence[tuple[type[Any] | str, str | None]]</code>","text":"<p>Returns a list of all registered factory keys.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple[type[Any] | str, str | None]]</code>           \u2013            <p>Sequence[tuple[type[Any] | str, str | None]]: A sequence of (key, name) tuples for all registered factories.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def factories(self) -&gt; Sequence[tuple[type[Any] | str, str | None]]:\n    \"\"\"Returns a list of all registered factory keys.\n\n    Returns:\n        Sequence[tuple[type[Any] | str, str | None]]: A sequence of\n            (key, name) tuples for all registered factories.\n    \"\"\"\n    with self._lock:\n        return list(self._store.keys())\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.override","title":"<code>override(key: type[T] | str, factory_or_value: Callable[[], T | Awaitable[T]] | T, name: str | None = None) -&gt; Iterator[None]</code>","text":"<p>Temporarily overrides a service registration within a context block.</p> <p>This is primarily useful for testing, allowing a service to be replaced with a mock or stub. The original registration is restored upon exiting the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to override.</p> </li> <li> <code>factory_or_value</code>               (<code>Callable[[], T | Awaitable[T]] | T</code>)           \u2013            <p>The temporary factory or value.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@contextmanager\ndef override(\n    self,\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; Iterator[None]:\n    \"\"\"Temporarily overrides a service registration within a context block.\n\n    This is primarily useful for testing, allowing a service to be replaced\n    with a mock or stub. The original registration is restored upon exiting\n    the context.\n\n    Args:\n        key (type[T] | str): The service key to override.\n        factory_or_value: The temporary factory or value.\n        name (str | None): An optional name for the registration.\n\n    Yields:\n        None:\n    \"\"\"\n    with self._lock:\n        store_key = (key, name)\n        original_factory = self._store.get(store_key)\n        original_instance = self._services.get(store_key)\n        self.register(key, factory_or_value, name)\n        if store_key in self._services:\n            del self._services[store_key]\n        self._log(\n            logging.DEBUG,\n            \"Overriding service\",\n            extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n        )\n    try:\n        yield\n    finally:\n        with self._lock:\n            if original_factory is not None:\n                self._store[store_key] = original_factory\n                if original_instance is not None:\n                    self._services[store_key] = original_instance\n                else:\n                    self._services.pop(store_key, None)\n                self._log(\n                    logging.DEBUG,\n                    \"Restored service\",\n                    extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n                )\n            else:\n                self.unregister(key, name)\n                self._log(\n                    logging.DEBUG,\n                    \"Removed service override\",\n                    extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n                )\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.register","title":"<code>register(key: type[T] | str, factory_or_value: Callable[[], T | Awaitable[T]] | T, name: str | None = None) -&gt; None</code>","text":"<p>Registers a factory or a pre-resolved value for a given service key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key, which can be a protocol type or a unique string identifier.</p> </li> <li> <code>factory_or_value</code>               (<code>Callable[[], T | Awaitable[T]] | T</code>)           \u2013            <p>The factory function that creates the service, or the service instance itself.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration, allowing multiple implementations of the same key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the registration key is invalid or conflicts with an existing registration.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def register(\n    self,\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a factory or a pre-resolved value for a given service key.\n\n    Args:\n        key (type[T] | str): The service key, which can be a protocol type\n            or a unique string identifier.\n        factory_or_value: The factory function that creates the service,\n            or the service instance itself.\n        name (str | None): An optional name for the registration, allowing\n            multiple implementations of the same key.\n\n    Returns:\n        None:\n\n    Raises:\n        BijuxError: If the registration key is invalid or conflicts with an\n            existing registration.\n    \"\"\"\n    if not (isinstance(key, str) or inspect.isclass(key)):\n        raise BijuxError(\"Service key must be a type or str\", http_status=400)\n    try:\n        store_key = (key, name)\n        if isinstance(key, str) and any(\n            isinstance(k, type) and k.__name__ == key for k, _ in self._store\n        ):\n            raise BijuxError(\n                f\"Key {key} conflicts with existing type name\", http_status=400\n            )\n        if isinstance(key, type) and any(k == key.__name__ for k, _ in self._store):\n            raise BijuxError(\n                f\"Type {key.__name__} conflicts with existing string key\",\n                http_status=400,\n            )\n        self._store[store_key] = factory_or_value\n        if isinstance(factory_or_value, ObservabilityProtocol) and not isinstance(\n            factory_or_value, type\n        ):\n            self._obs = factory_or_value\n        self._log(\n            logging.DEBUG,\n            \"Registered service\",\n            extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n        )\n    except (TypeError, KeyError) as exc:\n        self._log(\n            logging.ERROR,\n            f\"Failed to register service: {exc}\",\n            extra={\"service_name\": _key_name(key), \"name\": name},\n        )\n        raise BijuxError(\n            f\"Failed to register service {_key_name(key)}: {exc}\", http_status=400\n        ) from exc\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.reset","title":"<code>reset() -&gt; None</code>  <code>classmethod</code>","text":"<p>Resets the singleton instance, shutting down all services.</p> <p>This method is intended for use in testing environments to ensure a clean state between tests. It clears all registered services and factories.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Resets the singleton instance, shutting down all services.\n\n    This method is intended for use in testing environments to ensure a\n    clean state between tests. It clears all registered services and\n    factories.\n    \"\"\"\n    inst = None\n    with cls._lock:\n        inst = cls._instance\n        cls._instance = None\n        cls._obs = None\n    if inst is None:\n        cls._log_static(logging.DEBUG, \"DIContainer reset (no instance)\")\n        return\n    try:\n        asyncio.run(inst.shutdown())\n    except Exception as exc:\n        cls._log_static(logging.ERROR, f\"Error during shutdown: {exc}\")\n    inst._services.clear()\n    inst._store.clear()\n    inst._obs = None\n    cls._log_static(logging.DEBUG, \"DIContainer reset\")\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.reset_async","title":"<code>reset_async() -&gt; None</code>  <code>async</code> <code>classmethod</code>","text":"<p>Asynchronously resets the singleton instance.</p> <p>This method is intended for use in testing environments. All services and factories are cleared.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\nasync def reset_async(cls) -&gt; None:\n    \"\"\"Asynchronously resets the singleton instance.\n\n    This method is intended for use in testing environments. All services\n    and factories are cleared.\n    \"\"\"\n    instance = None\n    with cls._lock:\n        if cls._instance is not None:\n            instance = cls._instance\n            cls._instance = None\n            cls._obs = None\n    if instance is not None:\n        await instance.shutdown()\n        instance._services.clear()\n        instance._store.clear()\n        instance._obs = None\n    cls._log_static(logging.DEBUG, \"DIContainer reset\")\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.resolve","title":"<code>resolve(key: type[T] | str, name: str | None = None) -&gt; T</code>","text":"<p>Resolves and returns a service instance synchronously.</p> <p>If the service factory is asynchronous, this method will run the async factory to completion.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to resolve.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The resolved service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the service is not registered.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the factory fails, returns None, or a circular dependency is detected.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def resolve(self, key: type[T] | str, name: str | None = None) -&gt; T:\n    \"\"\"Resolves and returns a service instance synchronously.\n\n    If the service factory is asynchronous, this method will run the\n    async factory to completion.\n\n    Args:\n        key (type[T] | str): The service key to resolve.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        T: The resolved service instance.\n\n    Raises:\n        KeyError: If the service is not registered.\n        BijuxError: If the factory fails, returns None, or a circular\n            dependency is detected.\n    \"\"\"\n    return self._resolve_common(key, name, async_mode=False)\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.resolve_async","title":"<code>resolve_async(key: type[T] | str, name: str | None = None) -&gt; T</code>  <code>async</code>","text":"<p>Resolves and returns a service instance asynchronously.</p> <p>This method should be used when the caller is in an async context. It can resolve both synchronous and asynchronous factories.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to resolve.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The resolved service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the service is not registered.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the factory fails, returns None, or a circular dependency is detected.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>async def resolve_async(self, key: type[T] | str, name: str | None = None) -&gt; T:\n    \"\"\"Resolves and returns a service instance asynchronously.\n\n    This method should be used when the caller is in an async context. It\n    can resolve both synchronous and asynchronous factories.\n\n    Args:\n        key (type[T] | str): The service key to resolve.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        T: The resolved service instance.\n\n    Raises:\n        KeyError: If the service is not registered.\n        BijuxError: If the factory fails, returns None, or a circular\n            dependency is detected.\n    \"\"\"\n    result = self._resolve_common(key, name, async_mode=True)\n    if asyncio.iscoroutine(result):\n        return await cast(Awaitable[T], result)\n    else:\n        return cast(T, result)\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.services","title":"<code>services() -&gt; Sequence[tuple[type[Any] | str, str | None]]</code>","text":"<p>Returns a list of all resolved and cached service keys.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple[type[Any] | str, str | None]]</code>           \u2013            <p>Sequence[tuple[type[Any] | str, str | None]]: A sequence of (key, name) tuples for all currently resolved services.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def services(self) -&gt; Sequence[tuple[type[Any] | str, str | None]]:\n    \"\"\"Returns a list of all resolved and cached service keys.\n\n    Returns:\n        Sequence[tuple[type[Any] | str, str | None]]: A sequence of\n            (key, name) tuples for all currently resolved services.\n    \"\"\"\n    with self._lock:\n        return list(self._services.keys())\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.shutdown","title":"<code>shutdown() -&gt; None</code>  <code>async</code>","text":"<p>Shuts down all resolved services that have a cleanup method.</p> <p>Iterates through all cached services and calls a <code>shutdown()</code> or <code>close()</code> method if one exists, handling both sync and async methods.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shuts down all resolved services that have a cleanup method.\n\n    Iterates through all cached services and calls a `shutdown()` or\n    `close()` method if one exists, handling both sync and async methods.\n    \"\"\"\n    services = []\n    with self._lock:\n        services = list(self._services.items())\n        obs_ref = self._obs\n        self._services.clear()\n        self._store.clear()\n        self._obs = None\n    for key, instance in services:\n        try:\n            shutdown_func = getattr(instance, \"shutdown\", None)\n            if shutdown_func and callable(shutdown_func):\n                is_async_shutdown = asyncio.iscoroutinefunction(shutdown_func)\n                if is_async_shutdown:\n                    await asyncio.wait_for(shutdown_func(), timeout=5.0)\n                else:\n                    shutdown_func()\n                self._log(\n                    logging.DEBUG,\n                    \"Shutting down service\",\n                    extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n                )\n            elif isinstance(instance, ObservabilityProtocol) and not isinstance(\n                instance, type\n            ):\n                instance.close()\n                self._log(\n                    logging.DEBUG,\n                    \"Closing observability service\",\n                    extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n                )\n        except (RuntimeError, TypeError, TimeoutError) as exc:\n            self._log(\n                logging.ERROR,\n                f\"Shutdown failed: {exc}\",\n                extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n            )\n    if obs_ref and hasattr(obs_ref, \"close\"):\n        with suppress(Exception):\n            obs_ref.close()\n    self._log(logging.INFO, \"DIContainer shutdown\", extra={})\n</code></pre>"},{"location":"reference/core/di/#bijux_cli.core.di.DIContainer.unregister","title":"<code>unregister(key: type[Any] | str, name: str | None = None) -&gt; bool</code>","text":"<p>Unregisters a service factory and removes any cached instance.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[Any] | str</code>)           \u2013            <p>The service key to unregister.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a service was found and unregistered, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def unregister(self, key: type[Any] | str, name: str | None = None) -&gt; bool:\n    \"\"\"Unregisters a service factory and removes any cached instance.\n\n    Args:\n        key (type[Any] | str): The service key to unregister.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        bool: True if a service was found and unregistered, otherwise False.\n    \"\"\"\n    with self._lock:\n        store_key = (key, name)\n        removed = self._store.pop(store_key, None) is not None\n        if store_key in self._services and isinstance(\n            self._services[store_key], ObservabilityProtocol\n        ):\n            self._obs = None\n        self._services.pop(store_key, None)\n        if removed:\n            self._log(\n                logging.INFO,\n                \"Unregistered service\",\n                extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n            )\n        return removed\n</code></pre>"},{"location":"reference/core/engine/","title":"Engine Module API Reference","text":"<p>This section documents the internals of the <code>engine</code> module in Bijux CLI. </p>"},{"location":"reference/core/engine/#bijux_cli.core.engine","title":"<code>bijux_cli.core.engine</code>","text":"<p>Provides the core runtime engine for the Bijux CLI.</p> <p>This module defines the <code>Engine</code> class, which is responsible for orchestrating the application's runtime environment after initial setup. Its key responsibilities include:</p> <pre><code>* Initializing and registering all default services with the Dependency\n    Injection (DI) container.\n* Discovering, loading, and registering all external plugins.\n* Providing a central method for dispatching commands to plugins.\n* Managing the graceful shutdown of services.\n</code></pre> <p>The engine acts as the bridge between the CLI command layer and the underlying services and plugins.</p>"},{"location":"reference/core/engine/#bijux_cli.core.engine.Engine","title":"<code>Engine(di: Any = None, *, debug: bool = False, fmt: OutputFormat = OutputFormat.JSON, quiet: bool = False)</code>","text":"<p>Orchestrates the CLI's runtime services and plugin lifecycle.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_debug</code>               (<code>bool</code>)           \u2013            <p>The debug mode flag.</p> </li> <li> <code>_format</code>               (<code>OutputFormat</code>)           \u2013            <p>The default output format.</p> </li> <li> <code>_quiet</code>               (<code>bool</code>)           \u2013            <p>The quiet mode flag.</p> </li> <li> <code>_registry</code>               (<code>RegistryProtocol</code>)           \u2013            <p>The plugin registry service.</p> </li> </ul> <p>Initializes the engine and its core services.</p> <p>This sets up the DI container, registers default services, and loads all discoverable plugins.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>An existing dependency injection container. If None, the global singleton instance is used. Defaults to None.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode for services.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The default output format for services.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output from services.</p> </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>def __init__(\n    self,\n    di: Any = None,\n    *,\n    debug: bool = False,\n    fmt: OutputFormat = OutputFormat.JSON,\n    quiet: bool = False,\n) -&gt; None:\n    \"\"\"Initializes the engine and its core services.\n\n    This sets up the DI container, registers default services, and loads\n    all discoverable plugins.\n\n    Args:\n        di (Any, optional): An existing dependency injection container. If\n            None, the global singleton instance is used. Defaults to None.\n        debug (bool): If True, enables debug mode for services.\n        fmt (OutputFormat): The default output format for services.\n        quiet (bool): If True, suppresses output from services.\n    \"\"\"\n    from bijux_cli.core.di import DIContainer\n\n    self._di = di or DIContainer.current()\n    self._debug = debug\n    self._format = fmt\n    self._quiet = quiet\n    self._di.register(Observability, lambda: Observability(debug=debug))\n    register_default_services(self._di, debug=debug, output_format=fmt, quiet=quiet)\n    self._di.register(Engine, self)\n    self._registry: RegistryProtocol = self._di.resolve(RegistryProtocol)\n    self._register_plugins()\n</code></pre>"},{"location":"reference/core/engine/#bijux_cli.core.engine.Engine.di","title":"<code>di: DIContainer</code>  <code>property</code>","text":"<p>Read-only access to the DI container.</p>"},{"location":"reference/core/engine/#bijux_cli.core.engine.Engine.run_command","title":"<code>run_command(name: str, *args: Any, **kwargs: Any) -&gt; Any</code>  <code>async</code>","text":"<p>Executes a plugin's command with a configured timeout.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command or plugin to run.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the plugin's <code>execute</code> method.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the plugin's <code>execute</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the plugin is not found, its <code>execute</code> method is invalid, or if it fails during execution.</p> </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def run_command(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Executes a plugin's command with a configured timeout.\n\n    Args:\n        name (str): The name of the command or plugin to run.\n        *args (Any): Positional arguments to pass to the plugin's `execute`\n            method.\n        **kwargs (Any): Keyword arguments to pass to the plugin's `execute`\n            method.\n\n    Returns:\n        Any: The result of the command's execution.\n\n    Raises:\n        CommandError: If the plugin is not found, its `execute` method\n            is invalid, or if it fails during execution.\n    \"\"\"\n    plugin = self._registry.get(name)\n    execute = getattr(plugin, \"execute\", None)\n    if not callable(execute):\n        raise CommandError(\n            f\"Plugin '{name}' has no callable 'execute' method.\", http_status=404\n        )\n    if not inspect.iscoroutinefunction(execute):\n        raise CommandError(\n            f\"Plugin '{name}' 'execute' is not async/coroutine.\", http_status=400\n        )\n    try:\n        return await asyncio.wait_for(execute(*args, **kwargs), self._timeout())\n    except Exception as exc:  # pragma: no cover\n        raise CommandError(f\"Failed to run plugin '{name}': {exc}\") from exc\n</code></pre>"},{"location":"reference/core/engine/#bijux_cli.core.engine.Engine.run_repl","title":"<code>run_repl() -&gt; None</code>  <code>async</code>","text":"<p>Runs the interactive shell (REPL).</p> <p>Note: This is a placeholder for future REPL integration.</p> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def run_repl(self) -&gt; None:\n    \"\"\"Runs the interactive shell (REPL).\n\n    Note: This is a placeholder for future REPL integration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/engine/#bijux_cli.core.engine.Engine.shutdown","title":"<code>shutdown() -&gt; None</code>  <code>async</code>","text":"<p>Gracefully shuts down the engine and all resolved services.</p> <p>This method orchestrates the termination sequence for the application's runtime. It first attempts to flush any buffered command history to disk and then proceeds to shut down the main dependency injection container, which in turn cleans up all resolved services.</p> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Gracefully shuts down the engine and all resolved services.\n\n    This method orchestrates the termination sequence for the application's\n    runtime. It first attempts to flush any buffered command history to\n    disk and then proceeds to shut down the main dependency injection\n    container, which in turn cleans up all resolved services.\n\n    Returns:\n        None:\n    \"\"\"\n    try:\n        self._di.resolve(History).flush()\n    except KeyError:\n        pass\n    finally:\n        await self._di.shutdown()\n</code></pre>"},{"location":"reference/core/enums/","title":"Enums Module API Reference","text":"<p>This section documents the internals of the <code>enums</code> module in Bijux CLI. </p>"},{"location":"reference/core/enums/#bijux_cli.core.enums","title":"<code>bijux_cli.core.enums</code>","text":"<p>Defines the output format enumeration for the Bijux CLI.</p> <p>This module provides the <code>OutputFormat</code> enum, which represents the supported structured output formats (JSON and YAML). Using an enum ensures type safety and provides a single source of truth for format names. It also includes a mechanism for case-insensitive matching.</p>"},{"location":"reference/core/enums/#bijux_cli.core.enums.OutputFormat","title":"<code>OutputFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Specifies the supported structured output formats for CLI responses.</p> <p>This enum supports case-insensitive matching, so <code>OutputFormat(\"JSON\")</code> and <code>OutputFormat(\"yaml\")</code> are both valid.</p>"},{"location":"reference/core/exceptions/","title":"Exceptions Module API Reference","text":"<p>This section documents the internals of the <code>exceptions</code> module in Bijux CLI. </p>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions","title":"<code>bijux_cli.core.exceptions</code>","text":"<p>Defines the custom exception hierarchy for the Bijux CLI.</p> <p>This module provides a set of custom exception classes that inherit from the base <code>BijuxError</code>. This hierarchy allows for more specific error handling and helps standardize error reporting throughout the application. Each exception can carry contextual information, such as the command that was running when the error occurred.</p>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.BijuxError","title":"<code>BijuxError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all custom errors in the Bijux CLI.</p> <p>Attributes:</p> <ul> <li> <code>command</code>               (<code>str | None</code>)           \u2013            <p>The name of the command being executed when the error occurred.</p> </li> <li> <code>http_status</code>               (<code>int</code>)           \u2013            <p>An HTTP-like status code used to derive the final CLI exit code.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code.</p> </li> </ul> <p>Initialize the base BijuxError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the base BijuxError exception.\"\"\"\n    self.command = command\n    self.http_status = http_status if http_status is not None else 500\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.CliTimeoutError","title":"<code>CliTimeoutError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>BijuxError</code></p> <p>Raised for timeout errors (deprecated).</p> Note <p>This exception is deprecated. Use <code>CommandError</code> or Python's built-in <code>TimeoutError</code> for new code.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 504.</p> </li> </ul> <p>Initialize the CliTimeoutError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the CliTimeoutError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 504,\n    )\n</code></pre>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.CommandError","title":"<code>CommandError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>BijuxError</code></p> <p>Raised for command execution failures.</p> <p>This exception is used for command-specific errors, such as invalid arguments or missing resources, that represent a client-side error.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the CommandError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the CommandError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.ConfigError","title":"<code>ConfigError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>BijuxError</code></p> <p>Raised for configuration loading or parsing failures.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the ConfigError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ConfigError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.ServiceError","title":"<code>ServiceError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>BijuxError</code></p> <p>Raised for service-related failures.</p> <p>This exception is used for errors originating from core services like Observability, Telemetry, or the Registry.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 500.</p> </li> </ul> <p>Initialize the ServiceError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ServiceError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 500,\n    )\n</code></pre>"},{"location":"reference/core/exceptions/#bijux_cli.core.exceptions.ValidationError","title":"<code>ValidationError(message: str, *, command: str | None = None, http_status: int | None = None)</code>","text":"<p>               Bases: <code>BijuxError</code></p> <p>Raised for validation failures (deprecated).</p> Note <p>This exception is deprecated. Use <code>CommandError</code> for new code.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the ValidationError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ValidationError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/paths/","title":"Paths Module API Reference","text":"<p>This section documents the internals of the <code>paths</code> module in Bijux CLI. </p>"},{"location":"reference/core/paths/#bijux_cli.core.paths","title":"<code>bijux_cli.core.paths</code>","text":"<p>Defines core paths for the Bijux CLI's persistent files.</p> <p>This module centralizes the default filesystem locations for all user-specific data, such as configuration, command history, and plugins. This provides a single source of truth for file paths and simplifies management of persistent state. All paths are relative to the user's home directory within a <code>.bijux</code> folder.</p>"},{"location":"reference/infra/emitter/","title":"Emitter Module API Reference","text":"<p>This section documents the internals of the <code>emitter</code> module in Bijux CLI. </p>"},{"location":"reference/infra/emitter/#bijux_cli.infra.emitter","title":"<code>bijux_cli.infra.emitter</code>","text":"<p>Provides the concrete implementation of the structured output emitter service.</p> <p>This module defines the <code>Emitter</code> class, which implements the <code>EmitterProtocol</code>. It is responsible for serializing data payloads into structured formats like JSON or YAML and writing them to standard output or a specified file. The service also integrates with telemetry to log emission events.</p>"},{"location":"reference/infra/emitter/#bijux_cli.infra.emitter.Emitter","title":"<code>Emitter(telemetry: TelemetryProtocol, output_format: OutputFormat = OutputFormat.JSON, debug: bool = False, quiet: bool = False, **kwargs: Any)</code>","text":"<p>               Bases: <code>EmitterProtocol</code></p> <p>A service for serializing and emitting structured output.</p> <p>This class implements the <code>EmitterProtocol</code>. It handles the serialization of data payloads and writes the result to standard output or a file, while also tracking events with a telemetry service.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>_default_format</code>               (<code>OutputFormat</code>)           \u2013            <p>The default format for serialization.</p> </li> <li> <code>_debug</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if debug mode is enabled.</p> </li> <li> <code>_quiet</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if normal output should be suppressed.</p> </li> <li> <code>_logger</code>           \u2013            <p>A configured <code>structlog</code> logger instance.</p> </li> </ul> <p>Initializes the Emitter service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>output_format</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The default output format for emissions.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug logging.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses all non-error output.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (unused).</p> </li> </ul> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    telemetry: TelemetryProtocol,\n    output_format: OutputFormat = OutputFormat.JSON,\n    debug: bool = False,\n    quiet: bool = False,\n    **kwargs: Any,\n):\n    \"\"\"Initializes the Emitter service.\n\n    Args:\n        telemetry (TelemetryProtocol): The telemetry service for event tracking.\n        output_format (OutputFormat): The default output format for emissions.\n        debug (bool): If True, enables debug logging.\n        quiet (bool): If True, suppresses all non-error output.\n        **kwargs: Additional keyword arguments (unused).\n    \"\"\"\n    self._telemetry = telemetry\n    self._default_format = output_format\n    self._debug = debug\n    self._quiet = quiet\n    self._logger = structlog.get_logger(__name__)\n</code></pre>"},{"location":"reference/infra/emitter/#bijux_cli.infra.emitter.Emitter.emit","title":"<code>emit(payload: Any, *, fmt: OutputFormat | None = None, pretty: bool = False, level: str = 'info', message: str = 'Emitting output', output: str | None = None, **context: Any) -&gt; None</code>","text":"<p>Serializes and emits a structured data payload.</p> <p>The payload is serialized to the specified format and written to stdout or a file path if provided. The operation is suppressed if the emitter is in quiet mode and the log level is not critical.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Any</code>)           \u2013            <p>The data payload to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format. If None, the service's default format is used.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'info'</code> )           \u2013            <p>The log level for any accompanying message (e.g., \"info\", \"debug\", \"error\").</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>'Emitting output'</code> )           \u2013            <p>A descriptive message for logging purposes.</p> </li> <li> <code>output</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional file path to write the output to. If None, output is written to <code>sys.stdout</code>.</p> </li> <li> <code>**context</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key-value pairs for structured logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the payload cannot be serialized.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>def emit(\n    self,\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None:\n    \"\"\"Serializes and emits a structured data payload.\n\n    The payload is serialized to the specified format and written to stdout\n    or a file path if provided. The operation is suppressed if the emitter\n    is in quiet mode and the log level is not critical.\n\n    Args:\n        payload (Any): The data payload to serialize and emit.\n        fmt (OutputFormat | None): The output format. If None, the service's\n            default format is used.\n        pretty (bool): If True, formats the output for human readability.\n        level (str): The log level for any accompanying message (e.g.,\n            \"info\", \"debug\", \"error\").\n        message (str): A descriptive message for logging purposes.\n        output (str | None): An optional file path to write the output to.\n            If None, output is written to `sys.stdout`.\n        **context (Any): Additional key-value pairs for structured logging.\n\n    Returns:\n        None:\n\n    Raises:\n        CommandError: If the payload cannot be serialized.\n    \"\"\"\n    if self._quiet and level not in [\"error\", \"critical\"]:\n        return\n\n    output_format = fmt or self._default_format\n    serializer = serializer_for(output_format, self._telemetry)\n    try:\n        output_str = serializer.dumps(payload, fmt=output_format, pretty=pretty)\n    except Exception as error:\n        self._logger.error(\"Serialization failed\", error=str(error), **context)\n        raise CommandError(\n            f\"Serialization failed: {error}\", http_status=500\n        ) from error\n\n    stripped = output_str.rstrip(\"\\n\")\n\n    if output:\n        with open(output, \"w\", encoding=\"utf-8\") as f:\n            f.write(stripped)\n    else:\n        print(stripped, file=sys.stdout, flush=True)\n\n    if self._debug:\n        print(\"Diagnostics: emitted payload\", file=sys.stderr)\n        log = getattr(self._logger, level)\n        log(message, output=stripped, **context)\n\n    try:\n        self._telemetry.event(\n            \"output_emitted\",\n            {\"format\": output_format.value, \"size_chars\": len(stripped)},\n        )\n    except Exception as tel_err:\n        if self._debug:\n            self._logger.error(\"Telemetry failed\", error=str(tel_err), **context)\n</code></pre>"},{"location":"reference/infra/emitter/#bijux_cli.infra.emitter.Emitter.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Flushes any buffered output to standard output.</p> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered output to standard output.\"\"\"\n    sys.stdout.flush()\n</code></pre>"},{"location":"reference/infra/observability/","title":"Observability Module API Reference","text":"<p>This section documents the internals of the <code>observability</code> module in Bijux CLI. </p>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability","title":"<code>bijux_cli.infra.observability</code>","text":"<p>Provides the concrete implementation of the observability and logging service.</p> <p>This module defines the <code>Observability</code> class, which implements the <code>ObservabilityProtocol</code>. It serves as the primary interface for structured logging throughout the application, using <code>structlog</code> as its underlying engine. It can also be configured to forward log entries to a telemetry backend, unifying logging and event tracking.</p>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability","title":"<code>Observability(*, debug: bool = False)</code>","text":"<p>               Bases: <code>ObservabilityProtocol</code></p> <p>A structured logging service integrating <code>structlog</code> and telemetry.</p> <p>This class wraps a <code>structlog</code> logger to produce structured log entries. If configured with a telemetry backend, it also forwards these events for analytics and monitoring.</p> <p>Attributes:</p> <ul> <li> <code>_logger</code>               (<code>FilteringBoundLogger</code>)           \u2013            <p>The underlying <code>structlog</code> logger instance.</p> </li> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event forwarding. Defaults to a <code>NullTelemetry</code> instance that does nothing.</p> </li> </ul> <p>Initializes the observability service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, configures the service for debug-level logging.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>@inject\ndef __init__(self, *, debug: bool = False) -&gt; None:\n    \"\"\"Initializes the observability service.\n\n    Args:\n        debug (bool): If True, configures the service for debug-level\n            logging.\n    \"\"\"\n    self._logger: FilteringBoundLogger = structlog.get_logger(\"bijux_cli\")\n    self._telemetry: TelemetryProtocol = NullTelemetry()\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.bind","title":"<code>bind(**kwargs: Any) -&gt; Self</code>","text":"<p>Binds context key-value pairs to all subsequent log entries.</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Context values to include in each log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def bind(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Binds context key-value pairs to all subsequent log entries.\n\n    Args:\n        **kwargs (Any): Context values to include in each log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    self._logger = self._logger.bind(**kwargs)\n    return self\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.close","title":"<code>close() -&gt; None</code>","text":"<p>Logs the shutdown of the observability service.</p> Note <p>In this implementation, this method only logs a debug message and does not perform resource cleanup like flushing. Flushing is handled by the telemetry service's own lifecycle methods.</p> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Logs the shutdown of the observability service.\n\n    Note:\n        In this implementation, this method only logs a debug message and\n        does not perform resource cleanup like flushing. Flushing is\n        handled by the telemetry service's own lifecycle methods.\n    \"\"\"\n    self._logger.debug(\"Observability shutdown\")\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.get_logger","title":"<code>get_logger() -&gt; FilteringBoundLogger</code>","text":"<p>Retrieves the underlying <code>structlog</code> logger instance.</p> <p>Returns:</p> <ul> <li> <code>FilteringBoundLogger</code> (              <code>FilteringBoundLogger</code> )          \u2013            <p>The <code>structlog</code> logger, which can be used directly if needed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def get_logger(self) -&gt; FilteringBoundLogger:\n    \"\"\"Retrieves the underlying `structlog` logger instance.\n\n    Returns:\n        FilteringBoundLogger: The `structlog` logger, which can be used\n            directly if needed.\n    \"\"\"\n    return self._logger\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.log","title":"<code>log(level: str, msg: str, *, extra: dict[str, Any] | None = None) -&gt; Self</code>","text":"<p>Logs a structured message and emits a corresponding telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The severity level of the log (e.g., 'debug', 'info', 'warning', 'error', 'critical').</p> </li> <li> <code>msg</code>               (<code>str</code>)           \u2013            <p>The log message.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional context to include in the log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If <code>level</code> is not a valid log level name.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def log(\n    self,\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Logs a structured message and emits a corresponding telemetry event.\n\n    Args:\n        level (str): The severity level of the log (e.g., 'debug', 'info',\n            'warning', 'error', 'critical').\n        msg (str): The log message.\n        extra (dict[str, Any] | None): Additional context to include in the\n            log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n\n    Raises:\n        ServiceError: If `level` is not a valid log level name.\n    \"\"\"\n    log_func = getattr(self._logger, level.lower(), None)\n    if not callable(log_func):\n        raise ServiceError(f\"Invalid log level: {level}\")\n\n    log_context = extra or {}\n    if log_context:\n        log_func(msg, **log_context)\n    else:\n        log_func(msg)\n\n    if not isinstance(self._telemetry, NullTelemetry):\n        telemetry_payload = {\"level\": level, \"message\": msg}\n        telemetry_payload.update(log_context)\n        self._telemetry.event(\"LOG_EMITTED\", telemetry_payload)\n\n    return self\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.set_telemetry","title":"<code>set_telemetry(telemetry: TelemetryProtocol) -&gt; Self</code>","text":"<p>Attaches a telemetry backend for forwarding log events.</p> <p>This allows the service to be \"upgraded\" from a simple logger to a full observability tool after its initial creation.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service to receive events.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def set_telemetry(self, telemetry: TelemetryProtocol) -&gt; Self:\n    \"\"\"Attaches a telemetry backend for forwarding log events.\n\n    This allows the service to be \"upgraded\" from a simple logger to a full\n    observability tool after its initial creation.\n\n    Args:\n        telemetry (TelemetryProtocol): The telemetry service to receive events.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    self._telemetry = telemetry\n    return self\n</code></pre>"},{"location":"reference/infra/observability/#bijux_cli.infra.observability.Observability.setup","title":"<code>setup(*, debug: bool = False) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Instantiates and configures an <code>Observability</code> service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug-level logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>A new, configured <code>Observability</code> instance.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>@classmethod\ndef setup(cls, *, debug: bool = False) -&gt; Self:\n    \"\"\"Instantiates and configures an `Observability` service.\n\n    Args:\n        debug (bool): If True, enables debug-level logging.\n\n    Returns:\n        Self: A new, configured `Observability` instance.\n    \"\"\"\n    return cls(debug=debug)\n</code></pre>"},{"location":"reference/infra/process/","title":"Process Module API Reference","text":"<p>This section documents the internals of the <code>process</code> module in Bijux CLI. </p>"},{"location":"reference/infra/process/#bijux_cli.infra.process","title":"<code>bijux_cli.infra.process</code>","text":"<p>Provides a process pool service for executing external commands.</p> <p>This module defines the <code>ProcessPool</code> class, a concrete implementation of the <code>ProcessPoolProtocol</code>. It is designed to run shell commands in isolated subprocesses using a managed pool of workers. Key features include command validation to prevent shell injection and an in-memory LRU cache to return results for repeated commands without re-execution.</p>"},{"location":"reference/infra/process/#bijux_cli.infra.process.ProcessPool","title":"<code>ProcessPool(observability: ObservabilityProtocol, telemetry: TelemetryProtocol, max_workers: int = 4)</code>","text":"<p>               Bases: <code>ProcessPoolProtocol</code></p> <p>Executes validated commands in a worker pool with an LRU cache.</p> <p>This class manages a <code>ProcessPoolExecutor</code> to run commands in separate processes. It maintains a cache of recent command results to avoid unnecessary re-execution.</p> <p>Attributes:</p> <ul> <li> <code>_MAX_CACHE</code>               (<code>int</code>)           \u2013            <p>The maximum number of command results to store in the LRU cache.</p> </li> <li> <code>_exec</code>               (<code>ProcessPoolExecutor</code>)           \u2013            <p>The underlying executor for running tasks.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service.</p> </li> <li> <code>_cache</code>               (<code>OrderedDict</code>)           \u2013            <p>An LRU cache storing tuples of command arguments to their results <code>(returncode, stdout, stderr)</code>.</p> </li> </ul> <p>Initializes the <code>ProcessPool</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker processes. This can be overridden by the <code>BIJUXCLI_MAX_WORKERS</code> environment variable.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    max_workers: int = 4,\n) -&gt; None:\n    \"\"\"Initializes the `ProcessPool` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        max_workers (int): The maximum number of worker processes. This can\n            be overridden by the `BIJUXCLI_MAX_WORKERS` environment variable.\n    \"\"\"\n    max_workers = int(os.getenv(\"BIJUXCLI_MAX_WORKERS\", str(max_workers)))\n    self._exec = ProcessPoolExecutor(max_workers=max_workers)\n    self._log = observability\n    self._tel = telemetry\n    self._cache: OrderedDict[tuple[str, ...], tuple[int, bytes, bytes]] = (\n        OrderedDict()\n    )\n</code></pre>"},{"location":"reference/infra/process/#bijux_cli.infra.process.ProcessPool.get_status","title":"<code>get_status() -&gt; dict[str, Any]</code>","text":"<p>Returns the current status of the process pool.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary containing status information, such as the number of commands processed (and cached).</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def get_status(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the current status of the process pool.\n\n    Returns:\n        dict[str, Any]: A dictionary containing status information, such as\n            the number of commands processed (and cached).\n    \"\"\"\n    return {\"commands_processed\": len(self._cache)}\n</code></pre>"},{"location":"reference/infra/process/#bijux_cli.infra.process.ProcessPool.run","title":"<code>run(cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]</code>","text":"<p>Executes a command in the process pool, using a cache.</p> <p>The command is first looked up in the LRU cache. If not found, it is validated and then executed in a subprocess. The result is then stored in the cache.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and its arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity requesting the execution, used for telemetry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the command's return code, standard output, and standard error.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If command validation fails or if an unexpected error occurs during subprocess execution.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Executes a command in the process pool, using a cache.\n\n    The command is first looked up in the LRU cache. If not found, it is\n    validated and then executed in a subprocess. The result is then stored\n    in the cache.\n\n    Args:\n        cmd (list[str]): The command and its arguments to execute.\n        executor (str): The name of the entity requesting the execution,\n            used for telemetry.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the command's return\n            code, standard output, and standard error.\n\n    Raises:\n        BijuxError: If command validation fails or if an unexpected error\n            occurs during subprocess execution.\n    \"\"\"\n    from bijux_cli.services.utils import validate_command\n\n    key = tuple(cmd)\n    if key in self._cache:\n        self._log.log(\"debug\", \"Process-pool cache hit\", extra={\"cmd\": cmd})\n        self._tel.event(\"procpool_cache_hit\", {\"cmd\": cmd, \"executor\": executor})\n        self._cache.move_to_end(key)\n        return self._cache[key]\n\n    try:\n        safe_cmd = validate_command(cmd)\n        self._log.log(\"info\", \"Process-pool executing\", extra={\"cmd\": safe_cmd})\n        self._tel.event(\"procpool_execute\", {\"cmd\": safe_cmd, \"executor\": executor})\n\n        result = subprocess.run(  # noqa: S603 # nosec B603\n            safe_cmd,\n            capture_output=True,\n            check=False,\n            shell=False,\n        )\n\n        self._cache[key] = (result.returncode, result.stdout, result.stderr)\n        self._cache.move_to_end(key)\n        if len(self._cache) &gt; self._MAX_CACHE:\n            self._cache.popitem(last=False)\n\n        self._tel.event(\n            \"procpool_executed\",\n            {\n                \"cmd\": safe_cmd,\n                \"executor\": executor,\n                \"returncode\": result.returncode,\n            },\n        )\n        return result.returncode, result.stdout, result.stderr\n\n    except BijuxError:\n        self._tel.event(\n            \"procpool_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": \"validation\"},\n        )\n        raise\n    except Exception as exc:\n        self._tel.event(\n            \"procpool_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(exc)},\n        )\n        raise BijuxError(f\"Process-pool execution failed: {exc}\") from exc\n</code></pre>"},{"location":"reference/infra/process/#bijux_cli.infra.process.ProcessPool.shutdown","title":"<code>shutdown() -&gt; None</code>","text":"<p>Gracefully shuts down the worker process pool.</p> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Gracefully shuts down the worker process pool.\"\"\"\n    self._exec.shutdown(wait=True)\n    self._tel.event(\"procpool_shutdown\", {})\n    self._log.log(\"debug\", \"Process-pool shutdown\")\n</code></pre>"},{"location":"reference/infra/process/#bijux_cli.infra.process.get_process_pool","title":"<code>get_process_pool(logger: ObservabilityProtocol, telemetry: TelemetryProtocol) -&gt; ProcessPoolProtocol</code>","text":"<p>A factory function for creating a <code>ProcessPool</code> instance.</p> <p>This helper respects the <code>BIJUXCLI_MAX_WORKERS</code> environment variable to configure the number of worker processes.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service instance.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProcessPoolProtocol</code> (              <code>ProcessPoolProtocol</code> )          \u2013            <p>A configured instance of the process pool service.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def get_process_pool(\n    logger: ObservabilityProtocol, telemetry: TelemetryProtocol\n) -&gt; ProcessPoolProtocol:\n    \"\"\"A factory function for creating a `ProcessPool` instance.\n\n    This helper respects the `BIJUXCLI_MAX_WORKERS` environment variable to\n    configure the number of worker processes.\n\n    Args:\n        logger (ObservabilityProtocol): The logging service instance.\n        telemetry (TelemetryProtocol): The telemetry service instance.\n\n    Returns:\n        ProcessPoolProtocol: A configured instance of the process pool service.\n    \"\"\"\n    workers = int(os.getenv(\"BIJUXCLI_MAX_WORKERS\", \"4\"))\n    return ProcessPool(logger, telemetry, max_workers=workers)\n</code></pre>"},{"location":"reference/infra/retry/","title":"Retry Module API Reference","text":"<p>This section documents the internals of the <code>retry</code> module in Bijux CLI. </p>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry","title":"<code>bijux_cli.infra.retry</code>","text":"<p>Provides concrete asynchronous retry policy implementations.</p> <p>This module defines classes that implement the <code>RetryPolicyProtocol</code> to handle transient errors in asynchronous operations. It offers two main strategies:</p> <pre><code>* `TimeoutRetryPolicy`: A simple policy that applies a single timeout to an\n    operation.\n* `ExponentialBackoffRetryPolicy`: A more advanced policy that retries an\n    operation multiple times with an exponentially increasing delay and\n    random jitter between attempts.\n</code></pre> <p>These components are designed to be used by services to build resilience against temporary failures, such as network issues.</p>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy","title":"<code>ExponentialBackoffRetryPolicy(telemetry: TelemetryProtocol)</code>","text":"<p>               Bases: <code>RetryPolicyProtocol</code></p> <p>A retry policy with exponential backoff, jitter, and per-attempt timeouts.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting telemetry events.</p> </li> </ul> <p>Initializes the <code>ExponentialBackoffRetryPolicy</code>.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `ExponentialBackoffRetryPolicy`.\n\n    Args:\n        telemetry (TelemetryProtocol): The service for emitting events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets the retry policy state. This is a no-op for this policy.</p> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the retry policy state. This is a no-op for this policy.\"\"\"\n    self._telemetry.event(\"retry_reset\", {})\n</code></pre>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy.run","title":"<code>run(supplier: Callable[[], Awaitable[T]], seconds: float = 1.0, retries: int = 3, delay: float = 1.0, backoff: float = 2.0, jitter: float = 0.3, retry_on: tuple[type[BaseException], ...] = (Exception,)) -&gt; T</code>  <code>async</code>","text":"<p>Executes a supplier with a timeout and exponential-backoff retries.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>The async operation to run.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout for each attempt in seconds. Must be &gt; 0.</p> </li> <li> <code>retries</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The maximum number of retry attempts.</p> </li> <li> <code>delay</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The initial delay in seconds before the first retry.</p> </li> <li> <code>backoff</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier for the delay after each failure.</p> </li> <li> <code>jitter</code>               (<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The random fractional jitter to apply to each delay.</p> </li> <li> <code>retry_on</code>               (<code>tuple[type[BaseException], ...]</code>, default:                   <code>(Exception,)</code> )           \u2013            <p>A tuple of exception types that will trigger a retry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The result of the <code>supplier</code> if one of the attempts succeeds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>seconds</code> is less than or equal to 0.</p> </li> <li> <code>BaseException</code>             \u2013            <p>The last exception raised by <code>supplier</code> if all attempts fail.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>async def run(\n    self,\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n    retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    jitter: float = 0.3,\n    retry_on: tuple[type[BaseException], ...] = (Exception,),\n) -&gt; T:\n    \"\"\"Executes a supplier with a timeout and exponential-backoff retries.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): The async operation to run.\n        seconds (float): The timeout for each attempt in seconds. Must be &gt; 0.\n        retries (int): The maximum number of retry attempts.\n        delay (float): The initial delay in seconds before the first retry.\n        backoff (float): The multiplier for the delay after each failure.\n        jitter (float): The random fractional jitter to apply to each delay.\n        retry_on (tuple[type[BaseException], ...]): A tuple of exception\n            types that will trigger a retry.\n\n    Returns:\n        T: The result of the `supplier` if one of the attempts succeeds.\n\n    Raises:\n        ValueError: If `seconds` is less than or equal to 0.\n        BaseException: The last exception raised by `supplier` if all\n            attempts fail.\n    \"\"\"\n    if seconds &lt;= 0:\n        raise ValueError(\"seconds must be &gt; 0\")\n\n    ctx = _try_asyncio_timeout(seconds)\n\n    if ctx is not None:\n        async with ctx:\n            return await _backoff_loop(\n                supplier,\n                retries=retries,\n                delay=delay,\n                backoff=backoff,\n                jitter=jitter,\n                retry_on=retry_on,\n                telemetry=self._telemetry,\n            )\n    else:\n\n        async def timed_supplier() -&gt; T:\n            \"\"\"Wraps the supplier in an `asyncio.wait_for` timeout.\n\n            Returns:\n                T: The result of the `supplier` if it completes in time.\n            \"\"\"\n            return await asyncio.wait_for(supplier(), timeout=seconds)\n\n        return await _backoff_loop(\n            timed_supplier,\n            retries=retries,\n            delay=delay,\n            backoff=backoff,\n            jitter=jitter,\n            retry_on=retry_on,\n            telemetry=self._telemetry,\n        )\n</code></pre>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.TimeoutRetryPolicy","title":"<code>TimeoutRetryPolicy(telemetry: TelemetryProtocol)</code>","text":"<p>               Bases: <code>RetryPolicyProtocol</code></p> <p>A retry policy that applies a single, one-time timeout to an operation.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting telemetry events.</p> </li> </ul> <p>Initializes the <code>TimeoutRetryPolicy</code>.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `TimeoutRetryPolicy`.\n\n    Args:\n        telemetry (TelemetryProtocol): The service for emitting events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.TimeoutRetryPolicy.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets the retry policy state. This is a no-op for this policy.</p> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the retry policy state. This is a no-op for this policy.\"\"\"\n    self._telemetry.event(\"retry_reset\", {})\n</code></pre>"},{"location":"reference/infra/retry/#bijux_cli.infra.retry.TimeoutRetryPolicy.run","title":"<code>run(supplier: Callable[[], Awaitable[T]], seconds: float = 1.0) -&gt; T</code>  <code>async</code>","text":"<p>Executes an awaitable <code>supplier</code> with a single timeout.</p> <p>This method uses the modern <code>asyncio.timeout</code> context manager if available, otherwise it falls back to <code>asyncio.wait_for</code>.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>The async operation to run.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout duration in seconds. Must be positive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The result of the <code>supplier</code> if it completes in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>seconds</code> is less than or equal to 0.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the operation times out.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>async def run(\n    self,\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n) -&gt; T:\n    \"\"\"Executes an awaitable `supplier` with a single timeout.\n\n    This method uses the modern `asyncio.timeout` context manager if\n    available, otherwise it falls back to `asyncio.wait_for`.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): The async operation to run.\n        seconds (float): The timeout duration in seconds. Must be positive.\n\n    Returns:\n        T: The result of the `supplier` if it completes in time.\n\n    Raises:\n        ValueError: If `seconds` is less than or equal to 0.\n        BijuxError: If the operation times out.\n    \"\"\"\n    if seconds &lt;= 0:\n        raise ValueError(\"seconds must be &gt; 0\")\n\n    ctx = _try_asyncio_timeout(seconds)\n\n    try:\n        if ctx is not None:\n            async with ctx:\n                result = await supplier()\n        else:\n            result = await asyncio.wait_for(supplier(), timeout=seconds)\n\n        self._telemetry.event(\"retry_timeout_success\", {\"seconds\": seconds})\n        return result\n\n    except TimeoutError as exc:\n        self._telemetry.event(\n            \"retry_timeout_failed\", {\"seconds\": seconds, \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Operation timed out after {seconds}s\", http_status=504\n        ) from exc\n</code></pre>"},{"location":"reference/infra/serializer/","title":"Serializer Module API Reference","text":"<p>This section documents the internals of the <code>serializer</code> module in Bijux CLI. </p>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer","title":"<code>bijux_cli.infra.serializer</code>","text":"<p>Provides concrete serialization services for JSON and YAML formats.</p> <p>This module defines concrete implementations of the <code>SerializerProtocol</code>. It offers different serializers optimized for performance and specific formats, gracefully handling optional dependencies.</p> Key components include <ul> <li><code>OrjsonSerializer</code>: A high-performance serializer that uses <code>orjson</code> for     JSON serialization if installed, falling back to the standard <code>json</code>     module. It uses <code>PyYAML</code> for YAML.</li> <li><code>PyYAMLSerializer</code>: A serializer that exclusively handles the YAML format.</li> <li><code>Redacted</code>: A special string subclass for wrapping sensitive data to prevent     it from being exposed in serialized output.</li> <li><code>serializer_for</code>: A factory function that returns the most appropriate     serializer instance for a given format.</li> </ul>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.OrjsonSerializer","title":"<code>OrjsonSerializer(telemetry: TelemetryProtocol | None)</code>","text":"<p>               Bases: <code>_Base</code></p> <p>A serializer that uses <code>orjson</code> for JSON and <code>PyYAML</code> for YAML.</p> <p>This implementation prioritizes performance by using <code>orjson</code> for JSON operations if it is installed, gracefully falling back to the standard library's <code>json</code> module if it is not.</p> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def __init__(self, telemetry: TelemetryProtocol | None) -&gt; None:\n    \"\"\"Initializes the base serializer.\n\n    Args:\n        telemetry (TelemetryProtocol | None): The telemetry service for\n            tracking serialization events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.OrjsonSerializer.dumps","title":"<code>dumps(obj: Any, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; str</code>","text":"<p>Serializes an object to a string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The desired output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or serialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a string.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The desired output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        str: The serialized string.\n\n    Raises:\n        BijuxError: If the format is unsupported or serialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            raw = self._json_dump(obj, pretty)\n            res = raw if isinstance(raw, str) else raw.decode()\n        elif fmt is OutputFormat.YAML:\n            res = self._yaml_dump(obj, pretty)\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_dumps\", format=fmt.value, pretty=pretty)\n        return res\n    except Exception as exc:\n        self._event(\"serialize_dumps_failed\", format=fmt.value, error=str(exc))\n        raise self._axerr(fmt, \"serialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.OrjsonSerializer.dumps_bytes","title":"<code>dumps_bytes(obj: Any, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; bytes</code>","text":"<p>Serializes an object to bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The desired output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized bytes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or serialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to bytes.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The desired output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        bytes: The serialized bytes.\n\n    Raises:\n        BijuxError: If the format is unsupported or serialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            raw = self._json_dump(obj, pretty)\n            res = raw if isinstance(raw, bytes) else raw.encode()\n        elif fmt is OutputFormat.YAML:\n            res = self.dumps(obj, fmt=fmt, pretty=pretty).encode()\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_dumps_bytes\", format=fmt.value, pretty=pretty)\n        return res\n    except Exception as exc:\n        self._event(\n            \"serialize_dumps_bytes_failed\",\n            format=fmt.value,\n            error=str(exc),\n        )\n        raise self._axerr(fmt, \"serialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.OrjsonSerializer.loads","title":"<code>loads(data: str | bytes, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False) -&gt; Any</code>","text":"<p>Deserializes data into a Python object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The format of the input data.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing (often unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or deserialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; Any:\n    \"\"\"Deserializes data into a Python object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input data.\n        pretty (bool): A hint that may affect parsing (often unused).\n\n    Returns:\n        Any: The deserialized object.\n\n    Raises:\n        BijuxError: If the format is unsupported or deserialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            if _HAS_ORJSON:\n                assert _ORJSON is not None  # noqa: S101 # nosec B101\n                res = _ORJSON.loads(data)\n            else:\n                res = json.loads(data)\n        elif fmt is OutputFormat.YAML:\n            if not _HAS_YAML:\n                raise BijuxError(\"PyYAML is required for YAML operations\")\n            assert _YAML is not None  # noqa: S101 # nosec B101\n            txt = data if isinstance(data, str) else data.decode()\n            res = _YAML.safe_load(txt) or {}\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_loads\", format=fmt.value)\n        return res\n    except Exception as exc:\n        self._event(\"serialize_loads_failed\", format=fmt.value, error=str(exc))\n        raise self._axerr(fmt, \"deserialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.PyYAMLSerializer","title":"<code>PyYAMLSerializer(telemetry: TelemetryProtocol | None)</code>","text":"<p>               Bases: <code>_Base</code></p> <p>A serializer that exclusively uses the <code>PyYAML</code> library for YAML.</p> <p>Attributes:</p> <ul> <li> <code>_patched</code>               (<code>bool</code>)           \u2013            <p>A class-level flag to ensure that custom YAML representers are only registered once.</p> </li> </ul> <p>Initializes the <code>PyYAMLSerializer</code>.</p> <p>This also registers a custom YAML representer for the <code>Redacted</code> type on first instantiation.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol | None</code>)           \u2013            <p>The telemetry service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the <code>PyYAML</code> library is not installed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol | None) -&gt; None:\n    \"\"\"Initializes the `PyYAMLSerializer`.\n\n    This also registers a custom YAML representer for the `Redacted` type\n    on first instantiation.\n\n    Args:\n        telemetry (TelemetryProtocol | None): The telemetry service.\n\n    Raises:\n        BijuxError: If the `PyYAML` library is not installed.\n    \"\"\"\n    if not _HAS_YAML:\n        raise BijuxError(\"PyYAML is not installed\")\n    super().__init__(telemetry)\n    if not PyYAMLSerializer._patched:\n        assert _YAML is not None  # noqa: S101 # nosec B101\n        _YAML.add_representer(\n            Redacted,\n            lambda dumper, data: dumper.represent_scalar(\n                \"tag:yaml.org,2002:str\", str(data)\n            ),\n            Dumper=_YAML.SafeDumper,\n        )\n        PyYAMLSerializer._patched = True\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.PyYAMLSerializer.dumps","title":"<code>dumps(obj: Any, *, fmt: OutputFormat = OutputFormat.YAML, pretty: bool = False) -&gt; str</code>","text":"<p>Serializes an object to a YAML string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The output format. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output in block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized YAML string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is not <code>OutputFormat.YAML</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a YAML string.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The output format. Must be `OutputFormat.YAML`.\n        pretty (bool): If True, formats the output in block style.\n\n    Returns:\n        str: The serialized YAML string.\n\n    Raises:\n        BijuxError: If the format is not `OutputFormat.YAML`.\n    \"\"\"\n    if fmt is not OutputFormat.YAML:\n        raise BijuxError(\"PyYAMLSerializer only supports YAML\")\n    return yaml_dump(obj, pretty)\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.PyYAMLSerializer.dumps_bytes","title":"<code>dumps_bytes(obj: Any, *, fmt: OutputFormat = OutputFormat.YAML, pretty: bool = False) -&gt; bytes</code>","text":"<p>Serializes an object to YAML bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The output format. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output in block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized YAML bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to YAML bytes.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The output format. Must be `OutputFormat.YAML`.\n        pretty (bool): If True, formats the output in block style.\n\n    Returns:\n        bytes: The serialized YAML bytes.\n    \"\"\"\n    return self.dumps(obj, fmt=fmt, pretty=pretty).encode()\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.PyYAMLSerializer.loads","title":"<code>loads(data: str | bytes, *, fmt: OutputFormat = OutputFormat.YAML, pretty: bool = False) -&gt; Any</code>","text":"<p>Deserializes YAML data into a Python object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The format of the input. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing (unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is not <code>OutputFormat.YAML</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; Any:\n    \"\"\"Deserializes YAML data into a Python object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input. Must be `OutputFormat.YAML`.\n        pretty (bool): A hint that may affect parsing (unused).\n\n    Returns:\n        Any: The deserialized object.\n\n    Raises:\n        BijuxError: If the format is not `OutputFormat.YAML`.\n    \"\"\"\n    if fmt is not OutputFormat.YAML:\n        raise BijuxError(\"PyYAMLSerializer only supports YAML\")\n    txt = data if isinstance(data, str) else data.decode()\n    assert _YAML is not None  # noqa: S101 # nosec B101\n    return _YAML.safe_load(txt) or {}\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.Redacted","title":"<code>Redacted</code>","text":"<p>               Bases: <code>str</code></p> <p>A string subclass that redacts its value when printed or serialized.</p> <p>This is used to wrap sensitive data, such as secrets or API keys, to prevent them from being accidentally exposed in logs or console output.</p>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.Redacted.__new__","title":"<code>__new__(value: str) -&gt; Redacted</code>","text":"<p>Creates a new <code>Redacted</code> string instance.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>The original, sensitive value to be wrapped.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Redacted</code> (              <code>Redacted</code> )          \u2013            <p>The new <code>Redacted</code> string instance.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def __new__(cls, value: str) -&gt; Redacted:\n    \"\"\"Creates a new `Redacted` string instance.\n\n    Args:\n        value (str): The original, sensitive value to be wrapped.\n\n    Returns:\n        Redacted: The new `Redacted` string instance.\n    \"\"\"\n    return str.__new__(cls, value)\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.Redacted.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Returns the redacted representation.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A static string \"***\" to represent the redacted value.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Returns the redacted representation.\n\n    Returns:\n        str: A static string \"***\" to represent the redacted value.\n    \"\"\"\n    return \"***\"\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.Redacted.to_json","title":"<code>to_json() -&gt; str</code>  <code>staticmethod</code>","text":"<p>Provides a JSON-serializable representation for libraries like <code>orjson</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A static string \"***\" to represent the redacted value.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>@staticmethod\ndef to_json() -&gt; str:\n    \"\"\"Provides a JSON-serializable representation for libraries like `orjson`.\n\n    Returns:\n        str: A static string \"***\" to represent the redacted value.\n    \"\"\"\n    return \"***\"\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.serializer_for","title":"<code>serializer_for(fmt: OutputFormat | str, telemetry: TelemetryProtocol) -&gt; SerializerProtocol[Any]</code>","text":"<p>A factory function that returns a serializer for the given format.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>OutputFormat | str</code>)           \u2013            <p>The desired output format.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service to inject into the serializer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SerializerProtocol[Any]</code>           \u2013            <p>SerializerProtocol[Any]: A configured serializer instance appropriate for the specified format.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def serializer_for(\n    fmt: OutputFormat | str,\n    telemetry: TelemetryProtocol,\n) -&gt; SerializerProtocol[Any]:\n    \"\"\"A factory function that returns a serializer for the given format.\n\n    Args:\n        fmt (OutputFormat | str): The desired output format.\n        telemetry (TelemetryProtocol): The telemetry service to inject into\n            the serializer.\n\n    Returns:\n        SerializerProtocol[Any]: A configured serializer instance appropriate\n            for the specified format.\n    \"\"\"\n    format_enum = fmt if isinstance(fmt, OutputFormat) else OutputFormat(fmt.upper())\n\n    if format_enum is OutputFormat.JSON:\n        return OrjsonSerializer(telemetry)\n    else:\n        return PyYAMLSerializer(telemetry)\n</code></pre>"},{"location":"reference/infra/serializer/#bijux_cli.infra.serializer.yaml_dump","title":"<code>yaml_dump(obj: Any, pretty: bool) -&gt; str</code>","text":"<p>Dumps an object to a YAML string using PyYAML.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, formats the output in an indented block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized YAML string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the <code>PyYAML</code> library is not installed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def yaml_dump(obj: Any, pretty: bool) -&gt; str:\n    \"\"\"Dumps an object to a YAML string using PyYAML.\n\n    Args:\n        obj (Any): The object to serialize.\n        pretty (bool): If True, formats the output in an indented block style.\n\n    Returns:\n        str: The serialized YAML string.\n\n    Raises:\n        BijuxError: If the `PyYAML` library is not installed.\n    \"\"\"\n    if _yaml_mod is None:\n        raise BijuxError(\"PyYAML is required for YAML operations\")\n    dumped = _yaml_mod.safe_dump(\n        obj,\n        sort_keys=False,\n        default_flow_style=not pretty,\n        indent=2 if pretty else None,\n    )\n    return dumped or \"\"\n</code></pre>"},{"location":"reference/infra/telemetry/","title":"Telemetry Module API Reference","text":"<p>This section documents the internals of the <code>telemetry</code> module in Bijux CLI. </p>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry","title":"<code>bijux_cli.infra.telemetry</code>","text":"<p>Provides concrete telemetry service implementations for event tracking.</p> <p>This module defines concrete classes that implement the <code>TelemetryProtocol</code>. It offers different strategies for handling telemetry events, allowing the application's analytics behavior to be configured easily.</p> Key components include <ul> <li><code>TelemetryEvent</code>: An enumeration of all standardized event names, providing     a single source of truth for telemetry event types.</li> <li><code>NullTelemetry</code>: A no-op implementation that silently discards all events,     useful for disabling telemetry entirely.</li> <li><code>LoggingTelemetry</code>: An implementation that forwards all telemetry events to     the application's structured logging service.</li> </ul>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.LoggingTelemetry","title":"<code>LoggingTelemetry(observability: ObservabilityProtocol)</code>","text":"<p>               Bases: <code>TelemetryProtocol</code></p> <p>A telemetry service that logs events via the <code>Observability</code> service.</p> <p>This implementation of <code>TelemetryProtocol</code> forwards all telemetry events to the structured logger as debug-level messages.</p> <p>Attributes:</p> <ul> <li> <code>_obs</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service instance.</p> </li> <li> <code>_buffer</code>               (<code>list</code>)           \u2013            <p>A buffer to store events (currently only cleared on flush).</p> </li> </ul> <p>Initializes the <code>LoggingTelemetry</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>@inject\ndef __init__(self, observability: ObservabilityProtocol):\n    \"\"\"Initializes the `LoggingTelemetry` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging events.\n    \"\"\"\n    self._obs = observability\n    self._buffer: list[tuple[str, dict[str, Any]]] = []\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.LoggingTelemetry.enable","title":"<code>enable() -&gt; None</code>","text":"<p>Performs a no-op enable operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Performs a no-op enable operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.LoggingTelemetry.event","title":"<code>event(name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None</code>","text":"<p>Logs a telemetry event at the 'debug' level.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | TelemetryEvent</code>)           \u2013            <p>The event name or enum member.</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The event data dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def event(self, name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Logs a telemetry event at the 'debug' level.\n\n    Args:\n        name (str | TelemetryEvent): The event name or enum member.\n        payload (dict[str, Any]): The event data dictionary.\n\n    Returns:\n        None:\n    \"\"\"\n    event_name = name.value if isinstance(name, TelemetryEvent) else name\n    self._obs.log(\"debug\", f\"Telemetry event: {event_name}\", extra=payload)\n    self._buffer.append((event_name, payload))\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.LoggingTelemetry.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Clears the internal buffer of telemetry events.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Clears the internal buffer of telemetry events.\"\"\"\n    self._buffer.clear()\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.NullTelemetry","title":"<code>NullTelemetry</code>","text":"<p>               Bases: <code>TelemetryProtocol</code></p> <p>A no-op telemetry service that discards all events.</p> <p>This implementation of <code>TelemetryProtocol</code> can be used to effectively disable analytics and event tracking.</p>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.NullTelemetry.enable","title":"<code>enable() -&gt; None</code>","text":"<p>Performs a no-op enable operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Performs a no-op enable operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.NullTelemetry.event","title":"<code>event(name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None</code>","text":"<p>Discards the telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | TelemetryEvent</code>)           \u2013            <p>The event name (ignored).</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The event data (ignored).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def event(self, name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Discards the telemetry event.\n\n    Args:\n        name (str | TelemetryEvent): The event name (ignored).\n        payload (dict[str, Any]): The event data (ignored).\n\n    Returns:\n        None:\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.NullTelemetry.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Performs a no-op flush operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Performs a no-op flush operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry/#bijux_cli.infra.telemetry.TelemetryEvent","title":"<code>TelemetryEvent</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines standardized telemetry event names for tracking CLI activities.</p>"},{"location":"reference/services/audit/","title":"Audit Module API Reference","text":"<p>This section documents the internals of the <code>audit</code> module in Bijux CLI. </p>"},{"location":"reference/services/audit/#bijux_cli.services.audit","title":"<code>bijux_cli.services.audit</code>","text":"<p>Provides concrete audit service implementations.</p> <p>This module defines concrete classes that implement the <code>AuditProtocol</code>. It offers different strategies for handling command auditing and execution, allowing the application to switch between a simulation mode (<code>DryRunAudit</code>) and a real execution mode (<code>RealAudit</code>).</p> <p>A factory function, <code>get_audit_service</code>, is provided to select the appropriate implementation based on a <code>dry_run</code> flag.</p>"},{"location":"reference/services/audit/#bijux_cli.services.audit.DryRunAudit","title":"<code>DryRunAudit(log: ObservabilityProtocol, tel: TelemetryProtocol)</code>","text":"<p>               Bases: <code>_BaseAudit</code></p> <p>An audit service that records events and simulates command execution.</p> <p>Initializes the <code>DryRunAudit</code> service.</p> <p>Parameters:</p> <ul> <li> <code>log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for structured logging.</p> </li> <li> <code>tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def __init__(self, log: ObservabilityProtocol, tel: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `DryRunAudit` service.\n\n    Args:\n        log (ObservabilityProtocol): The service for structured logging.\n        tel (TelemetryProtocol): The service for event tracking.\n    \"\"\"\n    super().__init__(log, tel)\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.DryRunAudit.cli_audit","title":"<code>cli_audit() -&gt; None</code>","text":"<p>Logs a dry-run CLI audit event.</p> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Logs a dry-run CLI audit event.\"\"\"\n    self._log.log(\"info\", \"CLI audit (dry-run)\", extra={})\n    self._tel.event(\"audit_cli_dry_run\", {})\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.DryRunAudit.log","title":"<code>log(cmd: list[str], *, executor: str) -&gt; None</code>","text":"<p>Logs and records a command without executing it.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs and records a command without executing it.\n\n    Args:\n        cmd (list[str]): The command and arguments to log.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        None:\n    \"\"\"\n    entry = {\"cmd\": cmd, \"executor\": executor}\n    self._commands.append(entry)\n    self._log.log(\"info\", \"Dry-run\", extra=entry)\n    self._tel.event(\"audit_dry_run\", entry)\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.DryRunAudit.run","title":"<code>run(cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]</code>","text":"<p>Simulates the execution of a command.</p> <p>This method logs the command and returns a successful result without actually running a subprocess.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to simulate.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple of dummy values: <code>(0, b\"\", b\"\")</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Simulates the execution of a command.\n\n    This method logs the command and returns a successful result without\n    actually running a subprocess.\n\n    Args:\n        cmd (list[str]): The command to simulate.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple of dummy values: `(0, b\"\", b\"\")`.\n    \"\"\"\n    self.log(cmd, executor=executor)\n    return 0, b\"\", b\"\"\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.RealAudit","title":"<code>RealAudit(log: ObservabilityProtocol, tel: TelemetryProtocol)</code>","text":"<p>               Bases: <code>_BaseAudit</code></p> <p>An audit service that validates, logs, and executes real commands.</p> <p>Initializes the <code>RealAudit</code> service.</p> <p>Parameters:</p> <ul> <li> <code>log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for structured logging.</p> </li> <li> <code>tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def __init__(self, log: ObservabilityProtocol, tel: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `RealAudit` service.\n\n    Args:\n        log (ObservabilityProtocol): The service for structured logging.\n        tel (TelemetryProtocol): The service for event tracking.\n    \"\"\"\n    super().__init__(log, tel)\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.RealAudit.cli_audit","title":"<code>cli_audit() -&gt; None</code>","text":"<p>Logs a real CLI audit event.</p> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Logs a real CLI audit event.\"\"\"\n    self._log.log(\n        \"info\", \"CLI audit (real)\", extra={\"commands\": len(self._commands)}\n    )\n    self._tel.event(\"audit_cli_real\", {\"commands\": len(self._commands)})\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.RealAudit.log","title":"<code>log(cmd: list[str], *, executor: str) -&gt; None</code>","text":"<p>Logs a command with the intent to execute it.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs a command with the intent to execute it.\n\n    Args:\n        cmd (list[str]): The command and arguments to log.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        None:\n    \"\"\"\n    entry = {\"cmd\": cmd, \"executor\": executor}\n    self._commands.append(entry)\n    self._log.log(\"debug\", f\"Executing {executor}\", extra=entry)\n    self._tel.event(\"audit_execute\", entry)\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.RealAudit.run","title":"<code>run(cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]</code>","text":"<p>Validates, logs, and executes a command in a subprocess.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the command's return code, standard output, and standard error.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If command validation fails or an unexpected error occurs during execution.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Validates, logs, and executes a command in a subprocess.\n\n    Args:\n        cmd (list[str]): The command and arguments to execute.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the command's return\n            code, standard output, and standard error.\n\n    Raises:\n        BijuxError: If command validation fails or an unexpected error\n            occurs during execution.\n    \"\"\"\n    try:\n        safe_cmd = validate_command(cmd)\n        self.log(safe_cmd, executor=executor)\n        proc = subprocess.run(  # noqa: S603 # nosec B603\n            safe_cmd,\n            capture_output=True,\n            check=False,\n            shell=False,\n        )\n        self._tel.event(\n            \"audit_executed\",\n            {\n                \"cmd\": safe_cmd,\n                \"executor\": executor,\n                \"returncode\": proc.returncode,\n            },\n        )\n        return proc.returncode, proc.stdout, proc.stderr\n    except BijuxError as err:\n        self._tel.event(\n            \"audit_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(err)},\n        )\n        raise\n    except Exception as err:\n        self._tel.event(\n            \"audit_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(err)},\n        )\n        raise BijuxError(f\"Failed to execute {executor!r}: {err}\") from err\n</code></pre>"},{"location":"reference/services/audit/#bijux_cli.services.audit.get_audit_service","title":"<code>get_audit_service(observability: ObservabilityProtocol, telemetry: TelemetryProtocol, dry_run: bool = False) -&gt; AuditProtocol</code>","text":"<p>A factory function for creating an audit service instance.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns a <code>DryRunAudit</code> instance; otherwise, returns a <code>RealAudit</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AuditProtocol</code> (              <code>AuditProtocol</code> )          \u2013            <p>An instance of the appropriate audit service.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def get_audit_service(\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    dry_run: bool = False,\n) -&gt; AuditProtocol:\n    \"\"\"A factory function for creating an audit service instance.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        dry_run (bool): If True, returns a `DryRunAudit` instance; otherwise,\n            returns a `RealAudit` instance.\n\n    Returns:\n        AuditProtocol: An instance of the appropriate audit service.\n    \"\"\"\n    return (\n        DryRunAudit(observability, telemetry)\n        if dry_run\n        else RealAudit(observability, telemetry)\n    )\n</code></pre>"},{"location":"reference/services/config/","title":"Config Module API Reference","text":"<p>This section documents the internals of the <code>config</code> module in Bijux CLI. </p>"},{"location":"reference/services/config/#bijux_cli.services.config","title":"<code>bijux_cli.services.config</code>","text":"<p>Provides a robust, file-based configuration management service.</p> <p>This module defines the <code>Config</code> class, a concrete implementation of the <code>ConfigProtocol</code>. It is responsible for loading, accessing, and persisting key-value configuration settings from <code>.env</code> files.</p> Key features include <ul> <li>Atomic Writes: Changes are written to a temporary file before being     atomically moved into place to prevent data corruption.</li> <li>Cross-Process Safety: On POSIX systems, <code>fcntl.flock</code> is used with     retries to handle concurrent access from multiple CLI processes.</li> <li>Key Normalization: Configuration keys are handled case-insensitively     and the <code>BIJUXCLI_</code> prefix is optional.</li> <li>Security Checks: Includes validation to prevent operating on device     files or traversing symbolic link loops.</li> </ul>"},{"location":"reference/services/config/#bijux_cli.services.config.Config","title":"<code>Config(dependency_injector: Any)</code>","text":"<p>               Bases: <code>ConfigProtocol</code></p> <p>A robust configuration handler for <code>.env</code> files.</p> <p>This service manages loading, saving, and persisting configuration values, featuring atomic writes and key normalization. Keys are stored internally in lowercase and without the <code>BIJUXCLI_</code> prefix.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>Any</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_data</code>               (<code>dict[str, str]</code>)           \u2013            <p>The in-memory dictionary of configuration data.</p> </li> <li> <code>_path</code>               (<code>Path | None</code>)           \u2013            <p>The path to the configuration file being managed.</p> </li> </ul> <p>Initializes the Config service and attempts to autoload configuration.</p> <p>Parameters:</p> <ul> <li> <code>dependency_injector</code>               (<code>Any</code>)           \u2013            <p>The DI container for resolving dependencies.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>@inject\ndef __init__(self, dependency_injector: Any) -&gt; None:\n    \"\"\"Initializes the Config service and attempts to autoload configuration.\n\n    Args:\n        dependency_injector (Any): The DI container for resolving dependencies.\n    \"\"\"\n    self._di = dependency_injector\n    self._log: ObservabilityProtocol = dependency_injector.resolve(\n        ObservabilityProtocol\n    )\n    self._data: dict[str, str] = {}\n    self._path: Path | None = None\n    try:\n        self.load()\n    except FileNotFoundError:\n        pass\n    except CommandError as e:\n        self._log.log(\n            \"error\", f\"Auto-load of config failed during init: {e}\", extra={}\n        )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.all","title":"<code>all() -&gt; dict[str, str]</code>","text":"<p>Returns all configuration key-value pairs.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary of all configuration data.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def all(self) -&gt; dict[str, str]:\n    \"\"\"Returns all configuration key-value pairs.\n\n    Returns:\n        dict[str, str]: A dictionary of all configuration data.\n    \"\"\"\n    return dict(self._data)\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Deletes all configuration entries and removes the config file.</p> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the config file cannot be deleted due to a lock or other filesystem error.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Deletes all configuration entries and removes the config file.\n\n    Raises:\n        CommandError: If the config file cannot be deleted due to a lock\n            or other filesystem error.\n    \"\"\"\n    self._data = {}\n    if self._path and self._path.exists():\n        try:\n            retry = 40\n            while True:\n                try:\n                    with open(self._path, \"a+\") as real:\n                        fcntl.flock(real.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n                        self._path.unlink()\n                        fcntl.flock(real.fileno(), fcntl.LOCK_UN)\n                    break\n                except BlockingIOError as err:\n                    retry -= 1\n                    if retry == 0:\n                        raise CommandError(\n                            f\"Failed to clear config file {self._path}: File locked\",\n                            http_status=400,\n                        ) from err\n                    time.sleep(0.05)\n        except Exception as exc:\n            self._log.log(\n                \"error\",\n                f\"Failed to clear config file {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to clear config file {self._path}: {exc}\", http_status=500\n            ) from exc\n    self._log.log(\n        \"info\",\n        \"Cleared config data\",\n        extra={\"path\": str(self._path) if self._path else \"None\"},\n    )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Deletes a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to delete (case-insensitive, <code>BIJUXCLI_</code> prefix optional).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the key does not exist or the change cannot be persisted.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a configuration key and persists the change.\n\n    Args:\n        key (str): The key to delete (case-insensitive, `BIJUXCLI_` prefix optional).\n\n    Raises:\n        CommandError: If the key does not exist or the change cannot be persisted.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    if normalized_key not in self._data:\n        self._log.log(\n            \"error\", f\"Config key not found: {key}\", extra={\"key\": normalized_key}\n        )\n        raise CommandError(f\"Config key not found: {key}\", http_status=400)\n    del self._data[normalized_key]\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Deleted config key and persisted to {self._path}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config after deleting {normalized_key}: {exc}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            raise CommandError(\n                f\"Failed to persist config after deleting {normalized_key}: {exc}\",\n                http_status=500,\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.export","title":"<code>export(path: str | Path, out_format: str | None = None) -&gt; None</code>","text":"<p>Exports the configuration to a file or standard output.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The destination file path, or \"-\" for stdout.</p> </li> <li> <code>out_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format ('env', 'json', 'yaml'). If None, the format is auto-detected from the file extension.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the format is unsupported or the export fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def export(self, path: str | Path, out_format: str | None = None) -&gt; None:\n    \"\"\"Exports the configuration to a file or standard output.\n\n    Args:\n        path (str | Path): The destination file path, or \"-\" for stdout.\n        out_format (str | None): The output format ('env', 'json', 'yaml').\n            If None, the format is auto-detected from the file extension.\n\n    Raises:\n        CommandError: If the format is unsupported or the export fails.\n    \"\"\"\n    export_path = Path(path) if path != \"-\" else path\n    output_fmt = (\n        out_format.lower()\n        if out_format\n        else (\n            \"env\"\n            if path == \"-\" or str(path).endswith(\".env\")\n            else \"yaml\"\n            if str(path).endswith((\".yaml\", \".yml\"))\n            else \"json\"\n        )\n    )\n    try:\n        if output_fmt == \"env\":\n            lines = [f\"BIJUXCLI_{k.upper()}={v}\" for k, v in self._data.items()]\n            text = \"\\n\".join(lines) + (\"\\n\" if lines else \"\")\n        elif output_fmt == \"json\":\n            text = (\n                json.dumps({k.upper(): v for k, v in self._data.items()}, indent=2)\n                + \"\\n\"\n            )\n        elif output_fmt == \"yaml\":\n            if yaml is None:\n                raise CommandError(\n                    \"PyYAML not installed for YAML support\", http_status=400\n                )\n            text = yaml.safe_dump(\n                {k.upper(): v for k, v in self._data.items()}, sort_keys=False\n            )\n        else:\n            raise CommandError(f\"Unsupported format: {output_fmt}\", http_status=400)\n        if path == \"-\":\n            print(text, end=\"\")\n            self._log.log(\n                \"info\",\n                \"Exported config to stdout\",\n                extra={\"format\": output_fmt},\n            )\n            return\n        export_path = Path(path)\n        export_path.resolve(strict=False)\n        if not export_path.parent.exists():\n            raise CommandError(\n                f\"No such file or directory: {export_path.parent}\", http_status=400\n            )\n        if export_path.exists() and not os.access(export_path, os.W_OK):\n            raise PermissionError(f\"Permission denied: '{export_path}'\")\n        if not os.access(export_path.parent, os.W_OK):\n            raise PermissionError(f\"Permission denied: '{export_path.parent}'\")\n        with NamedTemporaryFile(\n            \"w\", delete=False, dir=export_path.parent, encoding=\"utf-8\", newline=\"\"\n        ) as temp_file:\n            fd = temp_file.fileno()\n            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n            temp_file.write(text)\n            temp_file.flush()\n            os.fsync(fd)\n            fcntl.flock(fd, fcntl.LOCK_UN)\n            Path(temp_file.name).replace(export_path)\n        self._log.log(\n            \"info\",\n            f\"Exported config to {export_path}\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n    except BlockingIOError as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to export config to {export_path}: File locked\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n        raise CommandError(\n            f\"Failed to export config to {export_path}: File locked\",\n            http_status=400,\n        ) from exc\n    except (OSError, PermissionError, ValueError) as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to export config to {export_path}: {exc}\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n        raise CommandError(\n            f\"Failed to export config to {export_path}: {exc}\", http_status=400\n        ) from exc\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.get","title":"<code>get(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Retrieves a configuration value by key.</p> <p>The key is normalized (lowercase, <code>BIJUXCLI_</code> prefix removed), and the environment is checked first before consulting the in-memory store.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to retrieve.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The value to return if the key is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key, or the default value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the key is not found and no default is provided.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieves a configuration value by key.\n\n    The key is normalized (lowercase, `BIJUXCLI_` prefix removed), and the\n    environment is checked first before consulting the in-memory store.\n\n    Args:\n        key (str): The key to retrieve.\n        default (Any): The value to return if the key is not found.\n\n    Returns:\n        Any: The value associated with the key, or the default value.\n\n    Raises:\n        CommandError: If the key is not found and no default is provided.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    env_key = f\"BIJUXCLI_{normalized_key.upper()}\"\n    if env_key in os.environ:\n        return os.environ[env_key]\n    value = self._data.get(normalized_key, default)\n    if isinstance(value, str):\n        val_lower = value.lower()\n        if val_lower in {\"true\", \"false\"}:\n            return val_lower == \"true\"\n    if value is default and default is None:\n        self._log.log(\n            \"error\", f\"Config key not found: {key}\", extra={\"key\": normalized_key}\n        )\n        raise CommandError(f\"Config key not found: {key}\", http_status=400)\n    self._log.log(\n        \"debug\",\n        f\"Retrieved config key: {normalized_key}\",\n        extra={\"key\": normalized_key, \"value\": str(value)},\n    )\n    return value\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.list_keys","title":"<code>list_keys() -&gt; list[str]</code>","text":"<p>Returns a list of all configuration keys.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all keys in the configuration.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def list_keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all configuration keys.\n\n    Returns:\n        list[str]: A list of all keys in the configuration.\n    \"\"\"\n    return list(self._data.keys())\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.load","title":"<code>load(path: str | Path | None = None) -&gt; None</code>","text":"<p>Loads configuration from a <code>.env</code> file.</p> <p>This method reads a specified <code>.env</code> file, parsing <code>KEY=VALUE</code> pairs. It handles comments, validates syntax, and normalizes keys. If no path is given, it uses the default path from <code>.env</code> or environment.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the <code>.env</code> file. If None, uses the default path from the environment or project structure.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If a specified config file does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If a line is malformed or contains non-ASCII characters.</p> </li> <li> <code>CommandError</code>             \u2013            <p>If the file is binary or another parsing error occurs.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def load(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Loads configuration from a `.env` file.\n\n    This method reads a specified `.env` file, parsing `KEY=VALUE` pairs.\n    It handles comments, validates syntax, and normalizes keys. If no path\n    is given, it uses the default path from `.env` or environment.\n\n    Args:\n        path (str | Path | None): Path to the `.env` file. If None, uses\n            the default path from the environment or project structure.\n\n    Raises:\n        FileNotFoundError: If a specified config file does not exist.\n        ValueError: If a line is malformed or contains non-ASCII characters.\n        CommandError: If the file is binary or another parsing error occurs.\n    \"\"\"\n    import_path = Path(path) if path is not None else None\n    current_path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n    self._validate_config_path(current_path)\n    if import_path:\n        self._validate_config_path(import_path)\n    read_path = import_path or current_path\n    _detect_symlink_loop(read_path)\n    if not read_path.exists():\n        if import_path is not None:\n            raise FileNotFoundError(f\"Config file not found: {read_path}\")\n        self._data = {}\n        return\n    new_data = {}\n    try:\n        content = read_path.read_text(encoding=\"utf-8\")\n        for i, line in enumerate(content.splitlines()):\n            stripped = line.strip()\n            if not stripped or stripped.startswith(\"#\"):\n                continue\n            if \"=\" not in line:\n                raise ValueError(f\"Malformed line {i + 1}: {line}\")\n            key_part, val_part = line.split(\"=\", 1)\n            key = key_part.strip()\n            value = _unescape(val_part)\n            if len(value) &gt;= 2 and value[0] == '\"' and value[-1] == '\"':\n                value = value[1:-1]\n            if not all(ord(c) &lt; 128 for c in key + value):\n                raise ValueError(f\"Non-ASCII characters in line {i + 1}: {line}\")\n            normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n            new_data[normalized_key] = value\n    except UnicodeDecodeError as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to parse config file {read_path}: Binary or non-text content\",\n            extra={\"path\": str(read_path)},\n        )\n        raise CommandError(\n            f\"Failed to parse config file {read_path}: Binary or non-text content\",\n            http_status=400,\n        ) from exc\n    except Exception as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to parse config file {read_path}: {exc}\",\n            extra={\"path\": str(read_path)},\n        )\n        raise CommandError(\n            f\"Failed to parse config file {read_path}: {exc}\", http_status=400\n        ) from exc\n    self._data = new_data\n    if import_path is not None and import_path != current_path:\n        self._path = current_path\n        self.set_many(new_data)\n    else:\n        self._path = read_path\n    self._log.log(\n        \"info\",\n        f\"Loaded config from {read_path} (active: {self._path})\",\n        extra={\"src\": str(read_path), \"active\": str(self._path)},\n    )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.reload","title":"<code>reload() -&gt; None</code>","text":"<p>Reloads configuration from the last-loaded file path.</p> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If no file path has been previously loaded.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reloads configuration from the last-loaded file path.\n\n    Raises:\n        CommandError: If no file path has been previously loaded.\n    \"\"\"\n    if self._path is None:\n        self._log.log(\"error\", \"Config.reload() called before load()\", extra={})\n        raise CommandError(\"Config.reload() called before load()\", http_status=400)\n    if not self._path.exists():\n        self._log.log(\n            \"error\", f\"Config file missing for reload: {self._path}\", extra={}\n        )\n        raise CommandError(\n            f\"Config file missing for reload: {self._path}\", http_status=400\n        )\n    self.load(self._path)\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.save","title":"<code>save() -&gt; None</code>","text":"<p>Persists the current in-memory configuration to its source file.</p> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Persists the current in-memory configuration to its source file.\"\"\"\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    try:\n        self.set_many(self._data)\n    except Exception as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to save config to {self._path}: {exc}\",\n            extra={\"path\": str(self._path)},\n        )\n        raise CommandError(\n            f\"Failed to save config to {self._path}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a single configuration key-value pair and persists it.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set (case-insensitive, <code>BIJUXCLI_</code> prefix optional).</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the configuration cannot be persisted.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a single configuration key-value pair and persists it.\n\n    Args:\n        key (str): The key to set (case-insensitive, `BIJUXCLI_` prefix optional).\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n\n    Raises:\n        CommandError: If the configuration cannot be persisted.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    self._data[normalized_key] = str(value)\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Persisted config to {self._path}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config to {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to persist config to {self._path}: {exc}\", http_status=500\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.set_many","title":"<code>set_many(items: dict[str, Any]) -&gt; None</code>","text":"<p>Sets multiple key-value pairs and persists them to the config file.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary of key-value pairs to set.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def set_many(self, items: dict[str, Any]) -&gt; None:\n    \"\"\"Sets multiple key-value pairs and persists them to the config file.\n\n    Args:\n        items (dict[str, Any]): A dictionary of key-value pairs to set.\n    \"\"\"\n    self._data = {k: str(v) for k, v in items.items()}\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Persisted config to {self._path}\",\n                extra={\"path\": str(self._path)},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config to {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to persist config to {self._path}: {exc}\", http_status=500\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config/#bijux_cli.services.config.Config.unset","title":"<code>unset(key: str) -&gt; None</code>","text":"<p>Removes a configuration key (alias for <code>delete</code>).</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to remove.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def unset(self, key: str) -&gt; None:\n    \"\"\"Removes a configuration key (alias for `delete`).\n\n    Args:\n        key (str): The key to remove.\n    \"\"\"\n    self.delete(key)\n</code></pre>"},{"location":"reference/services/docs/","title":"Docs Module API Reference","text":"<p>This section documents the internals of the <code>docs</code> module in Bijux CLI. </p>"},{"location":"reference/services/docs/#bijux_cli.services.docs","title":"<code>bijux_cli.services.docs</code>","text":"<p>Provides the concrete implementation of the API specification writing service.</p> <p>This module defines the <code>Docs</code> class, which implements the <code>DocsProtocol</code>. It is responsible for serializing API specification data into formats like JSON or YAML and writing the resulting documents to the filesystem. It integrates with observability and telemetry services to log its activities.</p>"},{"location":"reference/services/docs/#bijux_cli.services.docs.Docs","title":"<code>Docs(observability: ObservabilityProtocol, telemetry: TelemetryProtocol, root: str | Path | None = None)</code>","text":"<p>               Bases: <code>DocsProtocol</code></p> <p>A service for writing API specification documents to disk.</p> <p>This class implements the <code>DocsProtocol</code> to handle the serialization and writing of specifications (e.g., OpenAPI, JSON Schema) to files. It maintains a cache of serializer instances for performance.</p> <p>Attributes:</p> <ul> <li> <code>_serializers</code>               (<code>WeakKeyDictionary</code>)           \u2013            <p>A cache of serializer instances, keyed by the telemetry service instance.</p> </li> <li> <code>_observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>_root</code>               (<code>Path</code>)           \u2013            <p>The root directory where documents will be written.</p> </li> </ul> <p>Initializes the <code>Docs</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>root</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The root directory for writing documents. It defaults to the <code>BIJUXCLI_DOCS_DIR</code> environment variable, or \"docs\" if not set.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    root: str | Path | None = None,\n) -&gt; None:\n    \"\"\"Initializes the `Docs` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        root (str | Path | None): The root directory for writing documents.\n            It defaults to the `BIJUXCLI_DOCS_DIR` environment variable,\n            or \"docs\" if not set.\n    \"\"\"\n    self._observability = observability\n    self._telemetry = telemetry\n    env_root = os.getenv(\"BIJUXCLI_DOCS_DIR\")\n    root_dir = env_root if env_root else (root or \"docs\")\n    self._root = Path(root_dir)\n    self._root.mkdir(exist_ok=True, parents=True)\n    if telemetry not in self._serializers:\n        self._serializers[telemetry] = {}\n</code></pre>"},{"location":"reference/services/docs/#bijux_cli.services.docs.Docs.close","title":"<code>close() -&gt; None</code>","text":"<p>Closes the service. This is a no-op for this implementation.</p> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the service. This is a no-op for this implementation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/services/docs/#bijux_cli.services.docs.Docs.render","title":"<code>render(spec: dict[str, Any], *, fmt: OutputFormat) -&gt; str</code>","text":"<p>Renders a specification dictionary to a string in the given format.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The desired output format (e.g., JSON, YAML).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized specification as a string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the underlying serializer returns a non-string result.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def render(self, spec: dict[str, Any], *, fmt: OutputFormat) -&gt; str:\n    \"\"\"Renders a specification dictionary to a string in the given format.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to serialize.\n        fmt (OutputFormat): The desired output format (e.g., JSON, YAML).\n\n    Returns:\n        str: The serialized specification as a string.\n\n    Raises:\n        TypeError: If the underlying serializer returns a non-string result.\n    \"\"\"\n    if self._telemetry not in self._serializers:\n        self._serializers[self._telemetry] = {}\n    if fmt not in self._serializers[self._telemetry]:\n        self._serializers[self._telemetry][fmt] = serializer_for(\n            fmt, self._telemetry\n        )\n    result = self._serializers[self._telemetry][fmt].dumps(\n        spec, fmt=fmt, pretty=False\n    )\n    if not isinstance(result, str):\n        raise TypeError(\n            f\"Expected str from serializer.dumps, got {type(result).__name__}\"\n        )\n    return result\n</code></pre>"},{"location":"reference/services/docs/#bijux_cli.services.docs.Docs.write","title":"<code>write(spec: dict[str, Any], *, fmt: OutputFormat = OutputFormat.JSON, name: str = 'spec') -&gt; str</code>","text":"<p>Writes a specification to a file and returns the path as a string.</p> <p>This is a convenience wrapper around <code>write_sync</code>.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'spec'</code> )           \u2013            <p>The base name for the output file. Defaults to 'spec'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The absolute path to the written file.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def write(\n    self,\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    name: str = \"spec\",\n) -&gt; str:\n    \"\"\"Writes a specification to a file and returns the path as a string.\n\n    This is a convenience wrapper around `write_sync`.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        name (str): The base name for the output file. Defaults to 'spec'.\n\n    Returns:\n        str: The absolute path to the written file.\n    \"\"\"\n    path = self.write_sync(spec, fmt, name)\n    return str(path)\n</code></pre>"},{"location":"reference/services/docs/#bijux_cli.services.docs.Docs.write_sync","title":"<code>write_sync(spec: dict[str, Any], fmt: OutputFormat, name: str | Path) -&gt; Path</code>","text":"<p>Writes the specification to a file synchronously.</p> <p>This method handles path resolution, serializes the <code>spec</code> dictionary, and writes the content to the final destination file.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The desired output format.</p> </li> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The path or base name for the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>The <code>Path</code> object pointing to the written file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If writing to the file fails due to an <code>OSError</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def write_sync(\n    self, spec: dict[str, Any], fmt: OutputFormat, name: str | Path\n) -&gt; Path:\n    \"\"\"Writes the specification to a file synchronously.\n\n    This method handles path resolution, serializes the `spec` dictionary,\n    and writes the content to the final destination file.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The desired output format.\n        name (str | Path): The path or base name for the output file.\n\n    Returns:\n        Path: The `Path` object pointing to the written file.\n\n    Raises:\n        ServiceError: If writing to the file fails due to an `OSError`.\n    \"\"\"\n    final_path = None\n    try:\n        final_path = Path(name).expanduser().resolve()\n        if final_path.is_dir():\n            final_path = final_path / f\"spec.{fmt.value}\"\n        final_path.parent.mkdir(parents=True, exist_ok=True)\n        content = self.render(spec, fmt=fmt)\n        final_path.write_text(content, encoding=\"utf-8\")\n        self._observability.log(\"info\", f\"Wrote docs to {final_path}\")\n        self._telemetry.event(\n            \"docs_written\", {\"path\": str(final_path), \"format\": fmt.value}\n        )\n        return final_path\n    except OSError as exc:\n        self._telemetry.event(\n            \"docs_write_failed\",\n            {\n                \"path\": (\n                    str(final_path) if final_path is not None else \"&lt;unresolved&gt;\"\n                ),\n                \"error\": str(exc),\n            },\n        )\n        raise ServiceError(f\"Unable to write spec: {exc}\", http_status=403) from exc\n</code></pre>"},{"location":"reference/services/doctor/","title":"Doctor Module API Reference","text":"<p>This section documents the internals of the <code>doctor</code> module in Bijux CLI. </p>"},{"location":"reference/services/doctor/#bijux_cli.services.doctor","title":"<code>bijux_cli.services.doctor</code>","text":"<p>Provides the concrete implementation of the CLI health check service.</p> <p>This module defines the <code>Doctor</code> class, which implements the <code>DoctorProtocol</code>. It is responsible for performing diagnostic health checks on the application and its environment.</p>"},{"location":"reference/services/doctor/#bijux_cli.services.doctor.Doctor","title":"<code>Doctor</code>","text":"<p>               Bases: <code>DoctorProtocol</code></p> <p>An implementation of the health check service.</p> <p>This class provides a simple health check method that can be extended in the future to verify dependencies, such as database connections or external API reachability.</p>"},{"location":"reference/services/doctor/#bijux_cli.services.doctor.Doctor.check_health","title":"<code>check_health() -&gt; str</code>","text":"<p>Performs a basic health check on the application.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string indicating the health status. Currently always returns \"healthy\".</p> </li> </ul> Source code in <code>src/bijux_cli/services/doctor.py</code> <pre><code>def check_health(self) -&gt; str:\n    \"\"\"Performs a basic health check on the application.\n\n    Returns:\n        str: A string indicating the health status. Currently always\n            returns \"healthy\".\n    \"\"\"\n    return \"healthy\"\n</code></pre>"},{"location":"reference/services/history/","title":"History Module API Reference","text":"<p>This section documents the internals of the <code>history</code> module in Bijux CLI. </p>"},{"location":"reference/services/history/#bijux_cli.services.history","title":"<code>bijux_cli.services.history</code>","text":"<p>Provides a persistent, cross-process safe command history service.</p> <p>This module defines the <code>History</code> class, a concrete implementation of the <code>HistoryProtocol</code>. It provides a tolerant and robust store for CLI invocation events with several key design features:</p> <pre><code>* **Persistence:** All history is saved to a single JSON array in a\n    per-user file.\n* **Tolerance:** The service is resilient to empty, corrupt, or partially\n    formed history files. If a file is unreadable, it is treated as empty\n    and will be overwritten on the next successful write.\n* **Cross-Process Safety:** On POSIX systems, it uses `fcntl.flock` on a\n    sidecar lock file to safely coordinate writes from multiple concurrent\n    CLI processes. On other systems, it falls back to a thread lock.\n* **Atomic Writes:** All changes are written to a temporary file which is\n    then atomically moved into place, preventing data corruption from\n    interrupted writes.\n* **Memory Management:** The in-memory list of events is capped, and the\n    on-disk file is trimmed to a smaller size to prevent unbounded growth.\n* **Simplicity:** The service intentionally avoids complex features like\n    schema migrations. Unreadable state is discarded rather than repaired.\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History","title":"<code>History(telemetry: LoggingTelemetry, observability: Observability, history_path: Path | None = None)</code>","text":"<p>               Bases: <code>HistoryProtocol</code></p> <p>Manages a persistent history of CLI command invocations.</p> <p>This service maintains an in-memory list of command events and synchronizes it with a persisted JSON file. It is designed to be tolerant of file corruption and safe for concurrent use by multiple CLI processes.</p> <p>Mutating operations (<code>add</code>, <code>clear</code>, <code>import_</code>) acquire a cross-process lock before modifying the file to prevent lost updates and race conditions. The sequence is always: lock, reload from disk, apply change in memory, write atomically, and release lock.</p> <p>Attributes:</p> <ul> <li> <code>_tel</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for emitting events.</p> </li> <li> <code>_obs</code>               (<code>Observability</code>)           \u2013            <p>The logging service for operational errors.</p> </li> <li> <code>_explicit_path</code>               (<code>Path | None</code>)           \u2013            <p>A specific path to the history file, if provided during initialization.</p> </li> <li> <code>_events</code>               (<code>list</code>)           \u2013            <p>The in-memory cache of history event dictionaries.</p> </li> <li> <code>_load_error</code>               (<code>str | None</code>)           \u2013            <p>A message describing the last error that occurred while trying to load the history file, if any.</p> </li> </ul> <p>Initializes the History service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service.</p> </li> <li> <code>observability</code>               (<code>Observability</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>history_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional, explicit path to the history file. If None, a default path will be used.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    telemetry: LoggingTelemetry,\n    observability: Observability,\n    history_path: Path | None = None,\n) -&gt; None:\n    \"\"\"Initializes the History service.\n\n    Args:\n        telemetry (LoggingTelemetry): The telemetry service.\n        observability (Observability): The logging service.\n        history_path (Path | None): An optional, explicit path to the\n            history file. If None, a default path will be used.\n    \"\"\"\n    self._tel = telemetry\n    self._obs = observability\n    self._explicit_path = Path(history_path) if history_path else None\n    self._events: list[dict[str, Any]] = []\n    self._load_error: str | None = None\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.add","title":"<code>add(command: str, *, params: Sequence[str] | None = None, success: bool | None = True, return_code: int | None = 0, duration_ms: float | None = None) -&gt; None</code>","text":"<p>Appends a new command invocation to the history.</p> <p>This operation is cross-process safe. It acquires a lock, reloads the latest history from disk, appends the new entry, and writes the updated history back atomically. Errors are logged but suppressed to allow the originating command to complete its execution.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The command name (ASCII characters are enforced).</p> </li> <li> <code>params</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of parameters and flags.</p> </li> <li> <code>success</code>               (<code>bool | None</code>, default:                   <code>True</code> )           \u2013            <p>Whether the command succeeded.</p> </li> <li> <code>return_code</code>               (<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>The exit code of the command.</p> </li> <li> <code>duration_ms</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The command's duration in milliseconds.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def add(\n    self,\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None:\n    \"\"\"Appends a new command invocation to the history.\n\n    This operation is cross-process safe. It acquires a lock, reloads the\n    latest history from disk, appends the new entry, and writes the\n    updated history back atomically. Errors are logged but suppressed to\n    allow the originating command to complete its execution.\n\n    Args:\n        command (str): The command name (ASCII characters are enforced).\n        params (Sequence[str] | None): A list of parameters and flags.\n        success (bool | None): Whether the command succeeded.\n        return_code (int | None): The exit code of the command.\n        duration_ms (float | None): The command's duration in milliseconds.\n    \"\"\"\n    fp = self._get_history_path()\n    entry = {\n        \"command\": _ascii_clean(command),\n        \"params\": list(params or []),\n        \"timestamp\": _now(),\n        \"success\": bool(success),\n        \"return_code\": return_code if return_code is not None else 0,\n        \"duration_ms\": float(duration_ms) if duration_ms is not None else None,\n    }\n    with _interprocess_lock(fp):\n        self._reload()\n        if self._load_error:\n            msg = f\"[error] Could not load command history: {self._load_error}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._events = []\n        self._events.append(entry)\n        try:\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n        except PermissionError as exc:\n            msg = f\"[error] Could not record command history: {exc}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._load_error = msg\n            return\n        except OSError as exc:\n            if exc.errno in _ENOSPC_ERRORS:\n                msg = f\"[error] Could not record command history: {exc}\"\n                self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n                print(msg, file=sys.stderr)\n                self._load_error = msg\n                return\n            msg = f\"[error] Could not record command history: {exc}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._load_error = msg\n            return\n    with suppress(Exception):\n        self._tel.event(\"history_event_added\", {\"command\": entry[\"command\"]})\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Erases all persisted history.</p> <p>This operation is cross-process safe and atomic.</p> <p>Raises:</p> <ul> <li> <code>PermissionError</code>             \u2013            <p>If the history file or directory is not writable.</p> </li> <li> <code>OSError</code>             \u2013            <p>For other filesystem-related failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Erases all persisted history.\n\n    This operation is cross-process safe and atomic.\n\n    Raises:\n        PermissionError: If the history file or directory is not writable.\n        OSError: For other filesystem-related failures.\n    \"\"\"\n    fp = self._get_history_path()\n    try:\n        with _interprocess_lock(fp):\n            self._events = []\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n            self._tel.event(\"history_cleared\", {})\n    except Exception as exc:\n        msg = f\"History clear failed: {exc}\"\n        self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n        self._load_error = msg\n        raise\n    finally:\n        self._reload()\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.export","title":"<code>export(path: Path) -&gt; None</code>","text":"<p>Exports the current history to a file as a JSON array.</p> <p>This operation is a read-only snapshot and does not lock the source file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The destination file path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>On I/O failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def export(self, path: Path) -&gt; None:\n    \"\"\"Exports the current history to a file as a JSON array.\n\n    This operation is a read-only snapshot and does not lock the source file.\n\n    Args:\n        path (Path): The destination file path.\n\n    Raises:\n        RuntimeError: On I/O failures.\n    \"\"\"\n    self._reload()\n    try:\n        path = path.expanduser()\n        path.parent.mkdir(parents=True, exist_ok=True)\n        text = json.dumps(self._events, ensure_ascii=False, indent=2) + \"\\n\"\n        path.write_text(text, encoding=\"utf-8\")\n    except Exception as exc:\n        raise RuntimeError(f\"Failed exporting history: {exc}\") from exc\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.flush","title":"<code>flush() -&gt; None</code>","text":"<p>Persists all in-memory history data to disk.</p> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Persists all in-memory history data to disk.\"\"\"\n    self._dump()\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.import_","title":"<code>import_(path: Path) -&gt; None</code>","text":"<p>Imports history entries from a file, merging with current history.</p> <p>This operation is cross-process safe and atomic.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The source file path containing a JSON array of entries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>On I/O or parsing failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def import_(self, path: Path) -&gt; None:\n    \"\"\"Imports history entries from a file, merging with current history.\n\n    This operation is cross-process safe and atomic.\n\n    Args:\n        path (Path): The source file path containing a JSON array of entries.\n\n    Raises:\n        RuntimeError: On I/O or parsing failures.\n    \"\"\"\n    fp = self._get_history_path()\n    try:\n        with _interprocess_lock(fp):\n            self._reload()\n            if self._load_error:\n                raise RuntimeError(self._load_error)\n            path = path.expanduser()\n            if not path.exists():\n                raise RuntimeError(f\"Import file not found: {path}\")\n            raw = path.read_text(encoding=\"utf-8\")\n            data = json.loads(raw)\n            if not isinstance(data, list):\n                raise RuntimeError(\n                    f\"Invalid import format (not JSON array): {path}\"\n                )\n            imported: list[dict[str, Any]] = []\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n                e = dict(item)\n                e[\"command\"] = _ascii_clean(str(e.get(\"command\", \"\")))\n                if \"timestamp\" not in e:\n                    e[\"timestamp\"] = _now()\n                imported.append(e)\n            self._events.extend(imported)\n            if len(self._events) &gt; _MAX_IN_MEMORY:\n                self._events = self._events[-_MAX_IN_MEMORY:]\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n            with suppress(Exception):\n                self._tel.event(\"history_imported\", {\"count\": len(imported)})\n\n    except Exception as exc:\n        msg = f\"History import failed: {exc}\"\n        self._obs.log(\n            \"error\", msg, extra={\"import_path\": str(path), \"history_path\": str(fp)}\n        )\n        raise RuntimeError(msg) from exc\n</code></pre>"},{"location":"reference/services/history/#bijux_cli.services.history.History.list","title":"<code>list(*, limit: int | None = 20, group_by: str | None = None, filter_cmd: str | None = None, sort: str | None = None) -&gt; list[dict[str, Any]]</code>","text":"<p>Returns a view of the command history, with optional transformations.</p> <p>This is a read-only operation and does not acquire a cross-process lock, meaning it may not reflect writes from concurrent processes.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>20</code> )           \u2013            <p>The maximum number of entries to return. A value of 0 returns an empty list.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, returns a grouped summary.</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, returns only entries whose command contains this case-sensitive substring.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If 'timestamp', sorts entries by timestamp.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of history entries or grouped summaries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the history file is corrupt.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns a view of the command history, with optional transformations.\n\n    This is a read-only operation and does not acquire a cross-process lock,\n    meaning it may not reflect writes from concurrent processes.\n\n    Args:\n        limit (int | None): The maximum number of entries to return. A value\n            of 0 returns an empty list.\n        group_by (str | None): If provided, returns a grouped summary.\n        filter_cmd (str | None): If provided, returns only entries whose\n            command contains this case-sensitive substring.\n        sort (str | None): If 'timestamp', sorts entries by timestamp.\n\n    Returns:\n        list[dict[str, Any]]: A list of history entries or grouped summaries.\n\n    Raises:\n        RuntimeError: If the history file is corrupt.\n    \"\"\"\n    self._reload()\n    fp = self._get_history_path()\n    try:\n        writable = os.access(fp.parent, os.W_OK)\n    except Exception:\n        writable = True\n    if not writable:\n        msg = f\"Permission denied for history directory: {fp.parent}\"\n        self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n        print(msg, file=sys.stderr)\n    if self._load_error:\n        raise RuntimeError(self._load_error)\n    if limit == 0:\n        return []\n    entries: list[dict[str, Any]] = list(self._events)\n    if filter_cmd:\n        needle = str(filter_cmd)\n        entries = [e for e in entries if needle in (e.get(\"command\") or \"\")]\n    if sort == \"timestamp\":\n        entries.sort(key=lambda e: e.get(\"timestamp\", 0))\n    if group_by:\n        grouped: dict[Any, MutableSequence[dict[str, Any]]] = {}\n        for e in entries:\n            grouped.setdefault(e.get(group_by, \"unknown\"), []).append(e)\n        summary = [\n            {\n                \"group\": k,\n                \"count\": len(v),\n                \"last_run\": max((x.get(\"timestamp\", 0) for x in v), default=0),\n            }\n            for k, v in grouped.items()\n        ]\n        return summary[:limit] if (limit and limit &gt; 0) else summary\n    if limit and limit &gt; 0:\n        entries = entries[-limit:]\n    return entries\n</code></pre>"},{"location":"reference/services/memory/","title":"Memory Module API Reference","text":"<p>This section documents the internals of the <code>memory</code> module in Bijux CLI. </p>"},{"location":"reference/services/memory/#bijux_cli.services.memory","title":"<code>bijux_cli.services.memory</code>","text":"<p>Provides a thread-safe, file-persisted key-value store.</p> <p>This module defines the <code>Memory</code> class, a concrete implementation of the <code>MemoryProtocol</code>. It uses a dictionary for in-memory storage, protected by a <code>threading.Lock</code> for thread safety. Unlike a purely transient store, this implementation persists the entire key-value store to a JSON file on every write operation, allowing state to survive across different CLI invocations.</p>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory","title":"<code>Memory()</code>","text":"<p>               Bases: <code>MemoryProtocol</code></p> <p>Implements <code>MemoryProtocol</code> with a thread-safe, file-backed dictionary.</p> <p>This service provides a simple key-value store that is both thread-safe and persistent to a JSON file (<code>~/.bijux/.memory.json</code>).</p> <p>Attributes:</p> <ul> <li> <code>_store</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The in-memory dictionary holding the data.</p> </li> <li> <code>_lock</code>               (<code>Lock</code>)           \u2013            <p>A lock to ensure thread-safe access to the store.</p> </li> </ul> <p>Initializes the service, loading existing data from the persistence file.</p> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>@inject\ndef __init__(self) -&gt; None:\n    \"\"\"Initializes the service, loading existing data from the persistence file.\"\"\"\n    MEMORY_FILE.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with MEMORY_FILE.open(\"r\") as f:\n            self._store: dict[str, Any] = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        self._store = {}\n    self._lock = Lock()\n</code></pre>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Removes all key-value pairs and persists the change to disk.</p> <p>This operation is thread-safe.</p> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all key-value pairs and persists the change to disk.\n\n    This operation is thread-safe.\n    \"\"\"\n    with self._lock:\n        self._store.clear()\n        self._persist()\n</code></pre>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory.delete","title":"<code>delete(key: str) -&gt; None</code>","text":"<p>Deletes a key-value pair and persists the change to disk.</p> <p>This operation is thread-safe.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a key-value pair and persists the change to disk.\n\n    This operation is thread-safe.\n\n    Args:\n        key (str): The key of the value to delete.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    with self._lock:\n        if key not in self._store:\n            raise KeyError(f\"Memory key not found: {key}\")\n        del self._store[key]\n        self._persist()\n</code></pre>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory.get","title":"<code>get(key: str) -&gt; Any</code>","text":"<p>Retrieves a value by its key in a thread-safe manner.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by its key in a thread-safe manner.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    with self._lock:\n        if key not in self._store:\n            raise KeyError(f\"Memory key not found: {key}\")\n        return self._store[key]\n</code></pre>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory.keys","title":"<code>keys() -&gt; list[str]</code>","text":"<p>Returns a list of all keys currently in the store.</p> <p>This operation is thread-safe.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all string keys.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all keys currently in the store.\n\n    This operation is thread-safe.\n\n    Returns:\n        list[str]: A list of all string keys.\n    \"\"\"\n    with self._lock:\n        return list(self._store.keys())\n</code></pre>"},{"location":"reference/services/memory/#bijux_cli.services.memory.Memory.set","title":"<code>set(key: str, value: Any) -&gt; None</code>","text":"<p>Sets a key-value pair and persists the change to disk.</p> <p>If the key already exists, its value is overwritten. This operation is thread-safe.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value being set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair and persists the change to disk.\n\n    If the key already exists, its value is overwritten. This operation\n    is thread-safe.\n\n    Args:\n        key (str): The key for the value being set.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    with self._lock:\n        self._store[key] = value\n        self._persist()\n</code></pre>"},{"location":"reference/services/utils/","title":"Utils Module API Reference","text":"<p>This section documents the internals of the <code>utils</code> module in Bijux CLI. </p>"},{"location":"reference/services/utils/#bijux_cli.services.utils","title":"<code>bijux_cli.services.utils</code>","text":"<p>Provides shared utility functions for the CLI's service layer.</p> <p>This module contains common helper functions used by various service implementations. It centralizes logic for tasks like input validation and security checks to ensure consistency and robustness across the service layer.</p>"},{"location":"reference/services/utils/#bijux_cli.services.utils.validate_command","title":"<code>validate_command(cmd: list[str]) -&gt; list[str]</code>","text":"<p>Validates a command and its arguments against a whitelist.</p> <p>This security function is designed to prevent shell injection vulnerabilities. It performs several checks: 1.  Verifies the command name against an allowlist defined by the     <code>BIJUXCLI_ALLOWED_COMMANDS</code> environment variable. 2.  Resolves the command's absolute path to ensure it's on the system PATH. 3.  Checks arguments for forbidden shell metacharacters.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to validate, as a list of strings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A validated and safe command list, with the command name replaced by its absolute path, suitable for use with <code>subprocess.run</code> where <code>shell=False</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the command is empty, not on the allowlist, not found on the system PATH, or if any argument contains unsafe characters.</p> </li> </ul> Source code in <code>src/bijux_cli/services/utils.py</code> <pre><code>def validate_command(cmd: list[str]) -&gt; list[str]:\n    \"\"\"Validates a command and its arguments against a whitelist.\n\n    This security function is designed to prevent shell injection vulnerabilities.\n    It performs several checks:\n    1.  Verifies the command name against an allowlist defined by the\n        `BIJUXCLI_ALLOWED_COMMANDS` environment variable.\n    2.  Resolves the command's absolute path to ensure it's on the system PATH.\n    3.  Checks arguments for forbidden shell metacharacters.\n\n    Args:\n        cmd (list[str]): The command and arguments to validate, as a list of\n            strings.\n\n    Returns:\n        list[str]: A validated and safe command list, with the command name\n            replaced by its absolute path, suitable for use with `subprocess.run`\n            where `shell=False`.\n\n    Raises:\n        BijuxError: If the command is empty, not on the allowlist, not found\n            on the system PATH, or if any argument contains unsafe characters.\n    \"\"\"\n    if not cmd:\n        raise BijuxError(\"Empty command not allowed\", http_status=403)\n    env_val = os.getenv(\"BIJUXCLI_ALLOWED_COMMANDS\")\n    allowed_commands = (env_val or \"echo,ls,cat,grep\").split(\",\")\n\n    cmd_name = os.path.basename(cmd[0])\n    if cmd_name not in allowed_commands:\n        raise BijuxError(\n            f\"Command {cmd_name!r} not in allowed list: {allowed_commands}\",\n            http_status=403,\n        )\n    resolved_cmd_path = shutil.which(cmd[0])\n    if not resolved_cmd_path:\n        raise BijuxError(\n            f\"Command not found or not executable: {cmd[0]!r}\", http_status=403\n        )\n    if os.path.basename(resolved_cmd_path) != cmd_name:\n        raise BijuxError(f\"Disallowed command path: {cmd[0]!r}\", http_status=403)\n    cmd[0] = resolved_cmd_path\n    forbidden = set(\";|&amp;&gt;&lt;`!\")\n    for arg in cmd[1:]:\n        if any(ch in arg for ch in forbidden):\n            raise BijuxError(f\"Unsafe argument: {arg!r}\", http_status=403)\n    return cmd\n</code></pre>"},{"location":"reference/services/plugins/entrypoints/","title":"Entrypoints Module API Reference","text":"<p>This section documents the internals of the <code>entrypoints</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/entrypoints/#bijux_cli.services.plugins.entrypoints","title":"<code>bijux_cli.services.plugins.entrypoints</code>","text":"<p>Discovers and loads plugins distributed as Python packages.</p> <p>This module provides the <code>load_entrypoints</code> function, which is responsible for finding and loading plugins that have been installed into the Python environment and registered under the <code>bijux_cli.plugins</code> entry point group. This enables a distributable plugin ecosystem where plugins can be managed via tools like <code>pip</code>.</p>"},{"location":"reference/services/plugins/entrypoints/#bijux_cli.services.plugins.entrypoints.load_entrypoints","title":"<code>load_entrypoints(di: DIContainer | None = None, registry: RegistryProtocol | None = None) -&gt; None</code>  <code>async</code>","text":"<p>Discovers, loads, and registers all entry point-based plugins.</p> <p>This function iterates through all entry points in the 'bijux_cli.plugins' group. For each one, it attempts to load, instantiate, and register the plugin. It also performs an API version compatibility check and runs the plugin's <code>startup</code> hook if present.</p> Note <p>All exceptions during the loading or startup of a single plugin are caught, logged, and reported via telemetry. A failed plugin will be deregistered and will not prevent other plugins from loading.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>DIContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The dependency injection container. If None, the current global container is used.</p> </li> <li> <code>registry</code>               (<code>RegistryProtocol | None</code>, default:                   <code>None</code> )           \u2013            <p>The plugin registry. If None, it is resolved from the DI container.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/plugins/entrypoints.py</code> <pre><code>async def load_entrypoints(\n    di: DIContainer | None = None,\n    registry: RegistryProtocol | None = None,\n) -&gt; None:\n    \"\"\"Discovers, loads, and registers all entry point-based plugins.\n\n    This function iterates through all entry points in the 'bijux_cli.plugins'\n    group. For each one, it attempts to load, instantiate, and register the\n    plugin. It also performs an API version compatibility check and runs the\n    plugin's `startup` hook if present.\n\n    Note:\n        All exceptions during the loading or startup of a single plugin are\n        caught, logged, and reported via telemetry. A failed plugin will be\n        deregistered and will not prevent other plugins from loading.\n\n    Args:\n        di (DIContainer | None): The dependency injection container. If None,\n            the current global container is used.\n        registry (RegistryProtocol | None): The plugin registry. If None, it is\n            resolved from the DI container.\n\n    Returns:\n        None:\n    \"\"\"\n    import bijux_cli\n\n    di = di or DIContainer.current()\n    registry = registry or di.resolve(RegistryProtocol)\n\n    obs = di.resolve(ObservabilityProtocol, None)\n    tel = di.resolve(TelemetryProtocol, None)\n\n    for ep in _iter_plugin_eps():\n        try:\n            plugin_class = ep.load()\n            plugin = plugin_class()\n\n            if not _compatible(plugin):\n                raise RuntimeError(\n                    f\"Plugin '{ep.name}' requires API {getattr(plugin, 'requires_api_version', 'N/A')}, \"\n                    f\"host is {bijux_cli.api_version}\"\n                )\n\n            for tgt in (plugin_class, plugin):\n                raw = getattr(tgt, \"version\", None)\n                if raw is not None and not isinstance(raw, str):\n                    tgt.version = str(raw)\n\n            registry.register(ep.name, plugin, version=plugin.version)\n\n            startup = getattr(plugin, \"startup\", None)\n            if asyncio.iscoroutinefunction(startup):\n                await startup(di)\n            elif callable(startup):\n                startup(di)\n\n            if obs:\n                obs.log(\"info\", f\"Loaded plugin '{ep.name}'\")\n            if tel:\n                tel.event(\"entrypoint_plugin_loaded\", {\"name\": ep.name})\n\n        except Exception as exc:\n            with contextlib.suppress(Exception):\n                registry.deregister(ep.name)\n\n            if obs:\n                obs.log(\n                    \"error\",\n                    f\"Failed to load plugin '{ep.name}'\",\n                    extra={\"trace\": traceback.format_exc(limit=5)},\n                )\n            if tel:\n                tel.event(\n                    \"entrypoint_plugin_failed\", {\"name\": ep.name, \"error\": str(exc)}\n                )\n\n            _LOG.debug(\"Skipped plugin %s: %s\", ep.name, exc, exc_info=True)\n</code></pre>"},{"location":"reference/services/plugins/groups/","title":"Groups Module API Reference","text":"<p>This section documents the internals of the <code>groups</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/groups/#bijux_cli.services.plugins.groups","title":"<code>bijux_cli.services.plugins.groups</code>","text":"<p>Provides helpers for defining plugin command groups and autocompletions.</p> <p>This module offers a convenient, decorator-based API for plugin developers to register command groups and their subcommands. It also includes a factory function for creating dynamic shell completers for command arguments, enhancing the interactive user experience of plugins.</p>"},{"location":"reference/services/plugins/groups/#bijux_cli.services.plugins.groups.command_group","title":"<code>command_group(name: str, *, version: str | None = None) -&gt; Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]</code>","text":"<p>A decorator factory for registering plugin subcommands under a group.</p> <p>This function is designed to be used as a nested decorator to easily define command groups within a plugin.</p> Example <p>A plugin can define a \"user\" command group with a \"create\" subcommand like this::</p> <pre><code>group = command_group(\"user\", version=\"1.0\")\n\n@group(sub=\"create\")\ndef create_user(username: str):\n    ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the parent command group (e.g., \"user\").</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the group.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]</code>           \u2013            <p>Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]: A decorator that takes a subcommand name and returns the final decorator for the function.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/groups.py</code> <pre><code>def command_group(\n    name: str,\n    *,\n    version: str | None = None,\n) -&gt; Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]:\n    \"\"\"A decorator factory for registering plugin subcommands under a group.\n\n    This function is designed to be used as a nested decorator to easily\n    define command groups within a plugin.\n\n    Example:\n        A plugin can define a \"user\" command group with a \"create\" subcommand\n        like this::\n\n            group = command_group(\"user\", version=\"1.0\")\n\n            @group(sub=\"create\")\n            def create_user(username: str):\n                ...\n\n    Args:\n        name (str): The name of the parent command group (e.g., \"user\").\n        version (str | None): An optional version string for the group.\n\n    Returns:\n        Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]:\n            A decorator that takes a subcommand name and returns the final\n            decorator for the function.\n    \"\"\"\n\n    def with_sub(sub: str) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n        \"\"\"Captures the subcommand name for registration.\n\n        Args:\n            sub (str): The name of the subcommand (e.g., \"create\").\n\n        Returns:\n            A decorator for the subcommand function.\n\n        Raises:\n            ValueError: If the subcommand name contains spaces.\n        \"\"\"\n        if \" \" in sub:\n            raise ValueError(\"subcommand may not contain spaces\")\n        full = f\"{name} {sub}\"\n\n        def decorator(fn: Callable[..., Any]) -&gt; Callable[..., Any]:\n            \"\"\"Registers the decorated function as a command.\n\n            Args:\n                fn (Callable[..., Any]): The function to register as a subcommand.\n\n            Returns:\n                The original, undecorated function.\n\n            Raises:\n                RuntimeError: If the `RegistryProtocol` is not initialized.\n            \"\"\"\n            try:\n                di = DIContainer.current()\n                reg: RegistryProtocol = di.resolve(RegistryProtocol)\n            except KeyError as exc:\n                raise RuntimeError(\"RegistryProtocol is not initialized\") from exc\n\n            reg.register(full, fn, version=version)\n\n            try:\n                obs: ObservabilityProtocol = di.resolve(ObservabilityProtocol)\n                obs.log(\n                    \"info\",\n                    \"Registered command group\",\n                    extra={\"cmd\": full, \"version\": version},\n                )\n            except KeyError:\n                pass\n\n            try:\n                tel: TelemetryProtocol = di.resolve(TelemetryProtocol)\n                tel.event(\n                    \"command_group_registered\", {\"command\": full, \"version\": version}\n                )\n            except KeyError:\n                pass\n\n            return fn\n\n        return decorator\n\n    return with_sub\n</code></pre>"},{"location":"reference/services/plugins/groups/#bijux_cli.services.plugins.groups.dynamic_choices","title":"<code>dynamic_choices(callback: Callable[[], list[str]], *, case_sensitive: bool = True) -&gt; Callable[[typer.Context, typer.models.ParameterInfo, str], list[str]]</code>","text":"<p>Creates a <code>Typer</code> completer from a callback function.</p> <p>This factory function generates a completer that provides dynamic shell completion choices for a command argument or option.</p> Example <p>To provide dynamic completion for a <code>--user</code> option::</p> <pre><code>def get_all_users() -&gt; list[str]:\n    return [\"alice\", \"bob\", \"carol\"]\n\n@app.command()\ndef delete(\n    user: str = typer.Option(\n        ...,\n        autocompletion=dynamic_choices(get_all_users)\n    )\n):\n    ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], list[str]]</code>)           \u2013            <p>A no-argument function that returns a list of all possible choices.</p> </li> <li> <code>case_sensitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, prefix matching is case-sensitive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[Context, ParameterInfo, str], list[str]]</code>           \u2013            <p>A <code>Typer</code> completer function.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/groups.py</code> <pre><code>def dynamic_choices(\n    callback: Callable[[], list[str]],\n    *,\n    case_sensitive: bool = True,\n) -&gt; Callable[[typer.Context, typer.models.ParameterInfo, str], list[str]]:\n    \"\"\"Creates a `Typer` completer from a callback function.\n\n    This factory function generates a completer that provides dynamic shell\n    completion choices for a command argument or option.\n\n    Example:\n        To provide dynamic completion for a `--user` option::\n\n            def get_all_users() -&gt; list[str]:\n                return [\"alice\", \"bob\", \"carol\"]\n\n            @app.command()\n            def delete(\n                user: str = typer.Option(\n                    ...,\n                    autocompletion=dynamic_choices(get_all_users)\n                )\n            ):\n                ...\n\n    Args:\n        callback (Callable[[], list[str]]): A no-argument function that returns\n            a list of all possible choices.\n        case_sensitive (bool): If True, prefix matching is case-sensitive.\n\n    Returns:\n        A `Typer` completer function.\n    \"\"\"\n\n    def completer(\n        ctx: typer.Context,\n        param: typer.models.ParameterInfo,\n        incomplete: str,\n    ) -&gt; list[str]:\n        \"\"\"Filters the choices provided by the callback based on user input.\n\n        Args:\n            ctx (typer.Context): The `Typer` command context.\n            param (typer.models.ParameterInfo): The parameter being completed.\n            incomplete (str): The current incomplete user input.\n\n        Returns:\n            list[str]: A filtered list of choices that start with the\n                `incomplete` string.\n        \"\"\"\n        items = callback()\n        if case_sensitive:\n            return [i for i in items if i.startswith(incomplete)]\n        low = incomplete.lower()\n        return [i for i in items if i.lower().startswith(low)]\n\n    return completer\n</code></pre>"},{"location":"reference/services/plugins/hooks/","title":"Hooks Module API Reference","text":"<p>This section documents the internals of the <code>hooks</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks","title":"<code>bijux_cli.services.plugins.hooks</code>","text":"<p>Defines the hook specifications for the Bijux CLI plugin system.</p> <p>This module uses <code>pluggy</code>'s hook specification markers to define the formal set of hooks that plugins can implement. The <code>CoreSpec</code> class groups all standard lifecycle and execution hooks that the core application will invoke on registered plugins. This provides a clear and versioned interface for plugin developers.</p>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec","title":"<code>CoreSpec(dependency_injector: DIContainer)</code>","text":"<p>Defines the core hook specifications for CLI plugins.</p> <p>Plugins can implement methods matching these specifications to integrate with the CLI's lifecycle and command execution flow.</p> <p>Attributes:</p> <ul> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> </ul> <p>Initializes the <code>CoreSpec</code>.</p> <p>Parameters:</p> <ul> <li> <code>dependency_injector</code>               (<code>DIContainer</code>)           \u2013            <p>The DI container for resolving services like the logger.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>def __init__(self, dependency_injector: DIContainer) -&gt; None:\n    \"\"\"Initializes the `CoreSpec`.\n\n    Args:\n        dependency_injector (DIContainer): The DI container for resolving\n            services like the logger.\n    \"\"\"\n    self._log = dependency_injector.resolve(ObservabilityProtocol)\n</code></pre>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec.health","title":"<code>health() -&gt; bool | str</code>","text":"<p>A hook to check the health of a plugin.</p> <p>This hook is called by the <code>bijux plugins check</code> command. A plugin can return a boolean or a string to indicate its status.</p> <p>Returns:</p> <ul> <li> <code>bool | str</code>           \u2013            <p>bool | str: <code>True</code> for healthy, <code>False</code> for unhealthy, or a string with a descriptive status message.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\ndef health(self) -&gt; bool | str:\n    \"\"\"A hook to check the health of a plugin.\n\n    This hook is called by the `bijux plugins check` command. A plugin can\n    return a boolean or a string to indicate its status.\n\n    Returns:\n        bool | str: `True` for healthy, `False` for unhealthy, or a string\n            with a descriptive status message.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook health called\", extra={})\n    return True\n</code></pre>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec.post_execute","title":"<code>post_execute(name: str, result: Any) -&gt; None</code>  <code>async</code>","text":"<p>A hook that is called immediately after a command has executed.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command that was executed.</p> </li> <li> <code>result</code>               (<code>Any</code>)           \u2013            <p>The result object returned from the command.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def post_execute(self, name: str, result: Any) -&gt; None:\n    \"\"\"A hook that is called immediately after a command has executed.\n\n    Args:\n        name (str): The name of the command that was executed.\n        result (Any): The result object returned from the command.\n    \"\"\"\n    self._log.log(\n        \"debug\",\n        \"Hook post_execute called\",\n        extra={\"name\": name, \"result\": repr(result)},\n    )\n</code></pre>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec.pre_execute","title":"<code>pre_execute(name: str, args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; None</code>  <code>async</code>","text":"<p>A hook that is called immediately before a command is executed.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to be executed.</p> </li> <li> <code>args</code>               (<code>tuple[Any, ...]</code>)           \u2013            <p>The positional arguments passed to the command.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The keyword arguments passed to the command.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def pre_execute(\n    self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]\n) -&gt; None:\n    \"\"\"A hook that is called immediately before a command is executed.\n\n    Args:\n        name (str): The name of the command to be executed.\n        args (tuple[Any, ...]): The positional arguments passed to the command.\n        kwargs (dict[str, Any]): The keyword arguments passed to the command.\n    \"\"\"\n    self._log.log(\n        \"debug\",\n        \"Hook pre_execute called\",\n        extra={\"name\": name, \"args\": args, \"kwargs\": kwargs},\n    )\n</code></pre>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec.shutdown","title":"<code>shutdown() -&gt; None</code>  <code>async</code>","text":"<p>A hook that is called once when the CLI engine shuts down.</p> <p>Plugins can use this hook to perform cleanup tasks, such as releasing resources or flushing buffers.</p> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def shutdown(self) -&gt; None:\n    \"\"\"A hook that is called once when the CLI engine shuts down.\n\n    Plugins can use this hook to perform cleanup tasks, such as releasing\n    resources or flushing buffers.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook shutdown called\", extra={})\n</code></pre>"},{"location":"reference/services/plugins/hooks/#bijux_cli.services.plugins.hooks.CoreSpec.startup","title":"<code>startup() -&gt; None</code>  <code>async</code>","text":"<p>A hook that is called once when the CLI engine starts up.</p> <p>Plugins can use this hook to perform initialization tasks, such as setting up resources or starting background tasks.</p> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def startup(self) -&gt; None:\n    \"\"\"A hook that is called once when the CLI engine starts up.\n\n    Plugins can use this hook to perform initialization tasks, such as\n    setting up resources or starting background tasks.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook startup called\", extra={})\n</code></pre>"},{"location":"reference/services/plugins/registry/","title":"Registry Module API Reference","text":"<p>This section documents the internals of the <code>registry</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry","title":"<code>bijux_cli.services.plugins.registry</code>","text":"<p>Provides a concrete plugin registry service using the <code>pluggy</code> framework.</p> <p>This module defines the <code>Registry</code> class, which implements the <code>RegistryProtocol</code>. It serves as the central manager for the entire plugin lifecycle, including registration, aliasing, metadata storage, and the invocation of plugin hooks. It is built on top of the <code>pluggy</code> library to provide a robust and extensible plugin architecture.</p>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry","title":"<code>Registry(telemetry: LoggingTelemetry)</code>","text":"<p>               Bases: <code>RegistryProtocol</code></p> <p>A <code>pluggy</code>-based registry for managing CLI plugins.</p> <p>This class provides aliasing, metadata storage, and telemetry integration on top of the core <code>pluggy</code> plugin management system.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for events.</p> </li> <li> <code>_pm</code>               (<code>PluginManager</code>)           \u2013            <p>The underlying <code>pluggy</code> plugin manager.</p> </li> <li> <code>_plugins</code>               (<code>dict</code>)           \u2013            <p>A mapping of canonical plugin names to plugin objects.</p> </li> <li> <code>_aliases</code>               (<code>dict</code>)           \u2013            <p>A mapping of alias names to canonical plugin names.</p> </li> <li> <code>_meta</code>               (<code>dict</code>)           \u2013            <p>A mapping of canonical plugin names to their metadata.</p> </li> <li> <code>mapping</code>               (<code>MappingProxyType</code>)           \u2013            <p>A read-only view of the <code>_plugins</code> mapping.</p> </li> </ul> <p>Initializes the <code>Registry</code> service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for tracking registry events.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: LoggingTelemetry):\n    \"\"\"Initializes the `Registry` service.\n\n    Args:\n        telemetry (LoggingTelemetry): The telemetry service for tracking\n            registry events.\n    \"\"\"\n    self._telemetry = telemetry\n    self._pm = pluggy.PluginManager(\"bijux\")\n    from bijux_cli.services.plugins.hooks import CoreSpec\n\n    self._pm.add_hookspecs(CoreSpec)\n    self._plugins: dict[str, object] = {}\n    self._aliases: dict[str, str] = {}\n    self._meta: dict[str, dict[str, str]] = {}\n    self.mapping = MappingProxyType(self._plugins)\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.call_hook","title":"<code>call_hook(hook: str, *args: Any, **kwargs: Any) -&gt; list[Any]</code>  <code>async</code>","text":"<p>Invokes a hook on all registered plugins that implement it.</p> <p>This method handles results from multiple plugins, awaiting any results that are coroutines.</p> <p>Parameters:</p> <ul> <li> <code>hook</code>               (<code>str</code>)           \u2013            <p>The name of the hook to invoke.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the hook.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the hook.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>list[Any]: A list containing the results from all hook implementations that did not return <code>None</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the specified hook does not exist.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>async def call_hook(self, hook: str, *args: Any, **kwargs: Any) -&gt; list[Any]:\n    \"\"\"Invokes a hook on all registered plugins that implement it.\n\n    This method handles results from multiple plugins, awaiting any results\n    that are coroutines.\n\n    Args:\n        hook (str): The name of the hook to invoke.\n        *args (Any): Positional arguments to pass to the hook.\n        **kwargs (Any): Keyword arguments to pass to the hook.\n\n    Returns:\n        list[Any]: A list containing the results from all hook\n            implementations that did not return `None`.\n\n    Raises:\n        ServiceError: If the specified hook does not exist.\n    \"\"\"\n    try:\n        hook_fn = getattr(self._pm.hook, hook)\n        results = hook_fn(*args, **kwargs)\n    except AttributeError as error:\n        raise ServiceError(f\"Hook {hook!r} not found\", http_status=404) from error\n    collected = []\n    if isinstance(results, AsyncIterable):\n        async for result in results:\n            if asyncio.iscoroutine(result):\n                collected.append(await result)\n            elif result is not None:\n                collected.append(result)\n    else:\n        for result in results:\n            if asyncio.iscoroutine(result):\n                collected.append(await result)\n            elif result is not None:\n                collected.append(result)\n    try:\n        self._telemetry.event(\"registry_hook_called\", {\"hook\": hook})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"hook_called\", \"error\": str(error)},\n        )\n    return collected\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.deregister","title":"<code>deregister(name: str) -&gt; None</code>","text":"<p>Deregisters a plugin from the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to deregister.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the underlying <code>pluggy</code> deregistration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def deregister(self, name: str) -&gt; None:\n    \"\"\"Deregisters a plugin from the registry.\n\n    Args:\n        name (str): The name or alias of the plugin to deregister.\n\n    Returns:\n        None:\n\n    Raises:\n        ServiceError: If the underlying `pluggy` deregistration fails.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    plugin = self._plugins.pop(canonical, None)\n    if not plugin:\n        return\n    try:\n        self._pm.unregister(plugin)\n    except ValueError as error:\n        raise ServiceError(\n            f\"Pluggy failed to deregister {canonical}: {error}\", http_status=500\n        ) from error\n    self._meta.pop(canonical, None)\n    self._aliases = {a: n for a, n in self._aliases.items() if n != canonical}\n    try:\n        self._telemetry.event(\"registry_plugin_deregistered\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"deregister\", \"error\": str(error)},\n        )\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.get","title":"<code>get(name: str) -&gt; object</code>","text":"<p>Retrieves a plugin by its name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>object</code> (              <code>object</code> )          \u2013            <p>The registered plugin object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the plugin is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def get(self, name: str) -&gt; object:\n    \"\"\"Retrieves a plugin by its name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin to retrieve.\n\n    Returns:\n        object: The registered plugin object.\n\n    Raises:\n        ServiceError: If the plugin is not found.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    try:\n        plugin = self._plugins[canonical]\n    except KeyError as key_error:\n        try:\n            self._telemetry.event(\n                \"registry_plugin_retrieve_failed\",\n                {\"name\": name, \"error\": str(key_error)},\n            )\n        except RuntimeError as telemetry_error:\n            self._telemetry.event(\n                \"registry_telemetry_failed\",\n                {\"operation\": \"retrieve_failed\", \"error\": str(telemetry_error)},\n            )\n        raise ServiceError(\n            f\"Plugin {name!r} not found\", http_status=404\n        ) from key_error\n    try:\n        self._telemetry.event(\"registry_plugin_retrieved\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"retrieve\", \"error\": str(error)},\n        )\n    return plugin\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.has","title":"<code>has(name: str) -&gt; bool</code>","text":"<p>Checks if a plugin is registered under a given name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the plugin is registered, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def has(self, name: str) -&gt; bool:\n    \"\"\"Checks if a plugin is registered under a given name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin to check.\n\n    Returns:\n        bool: True if the plugin is registered, otherwise False.\n    \"\"\"\n    exists = name in self._plugins or name in self._aliases\n    try:\n        self._telemetry.event(\"registry_contains\", {\"name\": name, \"result\": exists})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"contains\", \"error\": str(error)},\n        )\n    return exists\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.meta","title":"<code>meta(name: str) -&gt; dict[str, str]</code>","text":"<p>Retrieves metadata for a specific plugin.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary containing the plugin's metadata.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def meta(self, name: str) -&gt; dict[str, str]:\n    \"\"\"Retrieves metadata for a specific plugin.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        dict[str, str]: A dictionary containing the plugin's metadata.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    info = dict(self._meta.get(canonical, {}))\n    try:\n        self._telemetry.event(\"registry_meta_retrieved\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"meta_retrieved\", \"error\": str(error)},\n        )\n    return info\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.names","title":"<code>names() -&gt; list[str]</code>","text":"<p>Returns a list of all registered plugin names.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of the canonical names of all registered plugins.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def names(self) -&gt; list[str]:\n    \"\"\"Returns a list of all registered plugin names.\n\n    Returns:\n        list[str]: A list of the canonical names of all registered plugins.\n    \"\"\"\n    names = list(self._plugins.keys())\n    try:\n        self._telemetry.event(\"registry_list\", {\"names\": names})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\", {\"operation\": \"list\", \"error\": str(error)}\n        )\n    return names\n</code></pre>"},{"location":"reference/services/plugins/registry/#bijux_cli.services.plugins.registry.Registry.register","title":"<code>register(name: str, plugin: object, *, alias: str | None = None, version: str | None = None) -&gt; None</code>","text":"<p>Registers a plugin with the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The canonical name of the plugin.</p> </li> <li> <code>plugin</code>               (<code>object</code>)           \u2013            <p>The plugin object to register.</p> </li> <li> <code>alias</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional alias for the plugin.</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the name, alias, or plugin object is already registered, or if the underlying <code>pluggy</code> registration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def register(\n    self,\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a plugin with the registry.\n\n    Args:\n        name (str): The canonical name of the plugin.\n        plugin (object): The plugin object to register.\n        alias (str | None): An optional alias for the plugin.\n        version (str | None): An optional version string for the plugin.\n\n    Returns:\n        None:\n\n    Raises:\n        ServiceError: If the name, alias, or plugin object is already\n            registered, or if the underlying `pluggy` registration fails.\n    \"\"\"\n    if name in self._plugins:\n        raise ServiceError(f\"Plugin {name!r} already registered\", http_status=400)\n    if plugin in self._plugins.values():\n        raise ServiceError(\n            \"Plugin object already registered under a different name\",\n            http_status=400,\n        )\n    if alias and (alias in self._plugins or alias in self._aliases):\n        raise ServiceError(f\"Alias {alias!r} already in use\", http_status=400)\n    try:\n        self._pm.register(plugin, name)\n    except ValueError as error:\n        raise ServiceError(\n            f\"Pluggy failed to register {name}: {error}\", http_status=500\n        ) from error\n    self._plugins[name] = plugin\n    self._meta[name] = {\"version\": version or \"unknown\"}\n    if alias:\n        self._aliases[alias] = name\n    try:\n        self._telemetry.event(\n            \"registry_plugin_registered\",\n            {\"name\": name, \"alias\": alias, \"version\": version},\n        )\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"register\", \"error\": str(error)},\n        )\n</code></pre>"}]}