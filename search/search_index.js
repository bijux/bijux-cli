var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Bijux CLI","text":"<p>A modern, predictable CLI framework for Python \u2014 strict global flag precedence, first-class plugins, a DI kernel, and an interactive REPL. Build robust, extensible command-line tools that are easy to test, maintain, and scale.</p> <p> </p> <p>At a glance: Plugin-driven \u2022 deterministic flags \u2022 DI for testability \u2022 REPL \u2022 structured JSON/YAML Quality: 2,600+ tests (unit/integration/functional/E2E). Multi-version CI. Docs build enforced. No telemetry.</p>"},{"location":"index.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Why Bijux CLI?</li> <li>Try It in 20 Seconds</li> <li>Key Features</li> <li>Installation</li> <li>Quick Start</li> <li>Plugins in 60 Seconds</li> <li>Structured Output</li> <li>Developer Introspection</li> <li>Global Flags: Strict Precedence</li> <li>Built-in Commands</li> <li>When to Use (and Not Use)</li> <li>Shell Completion</li> <li>Configuration &amp; Paths</li> <li>Tests &amp; Quality</li> <li>Project Tree</li> <li>Roadmap</li> <li>Docs &amp; Resources</li> <li>Contributing</li> <li>Acknowledgments</li> <li>License</li> </ul> <p>Back to top</p>"},{"location":"index.html#why-bijux-cli","title":"Why Bijux CLI?","text":"<p>Click and Typer excel at simple tools. Bijux emphasizes predictability and modularity for complex ones:</p> <ul> <li>Deterministic flags for reliable CI/scripting.</li> <li>Dependency Injection kernel for testable, decoupled services.</li> <li>First-class plugins to extend without touching the core.</li> <li>Interactive REPL for exploration and debugging.</li> </ul> <p>Back to top</p>"},{"location":"index.html#try-it-in-20-seconds","title":"Try It in 20 Seconds","text":"<pre><code>pipx install bijux-cli  # Or: pip install bijux-cli\nbijux --version\nbijux doctor\nbijux status -f json --no-pretty\n</code></pre> <p>Back to top</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Plugin-Driven Extensibility \u2014 Scaffold, install, validate; plugins become top-level commands.</li> <li>Deterministic Behavior \u2696 \u2014 Strict flag precedence (see ADR-0002).</li> <li>DI Kernel \u2014 Decouple internals; inspect graphs for debugging/tests.</li> <li>REPL Shell \u2014 Persistent session with history; great for exploration/demos.</li> <li>Structured Output \u2014 JSON/YAML (+ pretty/compact, verbosity, consistent errors).</li> <li>Diagnostics \u2014 Built-in <code>doctor</code>, <code>audit</code>, <code>docs</code> for workflows.</li> <li>Shell Completion \u2014 Bash, Zsh, Fish, PowerShell support.</li> </ul> <p>Back to top</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Requires Python 3.11+.</p> <pre><code># Isolated install (recommended)\npipx install bijux-cli\n\n# Standard\npip install bijux-cli\n</code></pre> <p>Upgrade: <code>pipx upgrade bijux-cli</code> or <code>pip install --upgrade bijux-cli</code>.</p> <p>Back to top</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<pre><code># Discover commands/flags\nbijux --help\n\n# Health check\nbijux doctor\n\n# REPL mode\nbijux\nbijux&gt; help\nbijux&gt; status\nbijux&gt; exit\n</code></pre> <p>Back to top</p>"},{"location":"index.html#plugins-in-60-seconds","title":"Plugins in 60 Seconds","text":"<pre><code># Scaffold from a real template (local dir or Git URL), then install\n# Option A: local template (example uses repo's cookiecutter template)\nbijux plugins scaffold my_plugin --template ./plugin_template --force\n\n# Option B: cookiecutter-compatible Git URL\n# bijux plugins scaffold my_plugin --template https://example.com/your/bijux-plugin-template.git --force\n\n# Install &amp; explore\nbijux plugins install ./my_plugin --force\nbijux plugins list\nbijux my_plugin --help\n\n# Validate &amp; remove\nbijux plugins check my_plugin\nbijux plugins uninstall my_plugin\n</code></pre> <p>Plugins dynamically add top-level commands.</p> <p>Back to top</p>"},{"location":"index.html#structured-output","title":"Structured Output","text":"<p>For automation:</p> <pre><code># Compact JSON\nbijux status -f json --no-pretty | jq\n\n# Pretty YAML\nbijux status -f yaml --pretty\n</code></pre> <p>Back to top</p>"},{"location":"index.html#developer-introspection","title":"Developer Introspection","text":"<pre><code># DI graph\nbijux dev di -f json\n\n# Loaded plugins\nbijux dev list-plugins\n</code></pre> <p>Back to top</p>"},{"location":"index.html#global-flags-strict-precedence","title":"Global Flags: Strict Precedence","text":"<p>Fixed ordering eliminates ambiguity.</p> Priority Flag Effect 1 <code>-h</code>, <code>--help</code> Immediate exit (code 0) with usage; ignores all. 2 <code>-q</code>, <code>--quiet</code> Suppress stdout/stderr; preserves exit code. 3 <code>-d</code>, <code>--debug</code> Full diagnostics; implies <code>--verbose</code>, forces <code>--pretty</code>. 4 <code>-f, --format &lt;json\\|yaml&gt;</code> Structured output; invalid \u2192 code 2. 5 <code>--pretty</code> / <code>--no-pretty</code> Indentation toggle (default: <code>--pretty</code>). 6 <code>-v</code>, <code>--verbose</code> Runtime metadata; implied by <code>--debug</code>. <p>Rationale: ADR-0002</p> <p>Back to top</p>"},{"location":"index.html#built-in-commands","title":"Built-in Commands","text":"Command Description Example <code>doctor</code> Environment diagnostics <code>bijux doctor</code> <code>status</code> CLI snapshot <code>bijux status -f json</code> <code>repl</code> Interactive shell <code>bijux repl</code> <code>plugins</code> Manage plugins <code>bijux plugins list</code> <code>config</code> Key-value settings <code>bijux config set core_timeout=5</code> <code>history</code> REPL history <code>bijux history --limit 10</code> <code>audit</code> Security checks <code>bijux audit --dry-run</code> <code>docs</code> Generate specs/docs <code>bijux docs --out spec.json</code> <code>dev</code> Introspection (DI, plugins) <code>bijux dev di</code> <code>sleep</code> Pause <code>bijux sleep -s 5</code> <code>version</code> Version info <code>bijux version</code> <p>Back to top</p>"},{"location":"index.html#when-to-use-and-not-use","title":"When to Use (and Not Use)","text":"<p>Use if you need:</p> <ul> <li>Plugins for extensibility.</li> <li>Deterministic flags for CI/scripts.</li> <li>REPL for interactive workflows.</li> <li>DI for modular, testable design.</li> </ul> <p>Overkill if:</p> <ul> <li>You\u2019re building a tiny one-off script (Click/Typer may be simpler).</li> <li>You don\u2019t need plugins/DI.</li> </ul> <p>Back to top</p>"},{"location":"index.html#shell-completion","title":"Shell Completion","text":"<pre><code># Install (writes to your shell\u2019s completion dir)\nbijux --install-completion\n\n# Or print the script for manual setup\nbijux --show-completion\n</code></pre> <p>Zsh tip: Ensure <code>compinit</code> runs and your <code>fpath</code> includes the completion directory.</p> <p>Back to top</p>"},{"location":"index.html#configuration-paths","title":"Configuration &amp; Paths","text":"<p>Precedence: flags &gt; env &gt; config &gt; defaults.</p> <ul> <li>Config: <code>~/.bijux/.env</code> (<code>BIJUXCLI_CONFIG</code>)</li> <li>History: <code>~/.bijux/.history</code> (<code>BIJUXCLI_HISTORY_FILE</code>)</li> <li>Plugins: <code>~/.bijux/.plugins</code> (<code>BIJUXCLI_PLUGINS_DIR</code>)</li> </ul> <p>Example:</p> <pre><code>export BIJUXCLI_PLUGINS_DIR=./custom-plugins\n</code></pre> <p>Back to top</p>"},{"location":"index.html#tests-quality","title":"Tests &amp; Quality","text":"<ul> <li>Coverage &amp; depth: 2,600+ tests across unit, integration, functional, and E2E layers.</li> <li>Determinism: CI runs the full suite on multiple Python versions (3.11+).</li> <li>Artifacts: JSON/YAML fixtures validate structured outputs; E2E simulates real usage (REPL, plugins, DI).</li> <li>Docs: Read the full testing guide \u2192 TESTS.md.</li> </ul> <p>Quick commands:</p> <pre><code>make test         # all tests\nmake test-unit    # unit tests only\nmake test-e2e     # end-to-end tests only\n</code></pre> <p>Back to top</p>"},{"location":"index.html#project-tree","title":"Project Tree","text":"<p>A guided map of the repository (what lives where, and why). See PROJECT_TREE.md for the full breakdown.</p> <p>Quick glance:</p> <pre><code>api/            # OpenAPI schemas\nconfig/         # Lint/type/security configs\ndocs/           # MkDocs site (Material)\nmakefiles/      # Task modules (docs, test, lint, etc.)\nplugin_template/# Cookiecutter-ready plugin scaffold\nscripts/        # Helper scripts (hooks, docs generation)\nsrc/bijux_cli/  # CLI + library implementation\ntests/          # unit / integration / functional / e2e\n</code></pre> <p>Back to top</p>"},{"location":"index.html#roadmap","title":"Roadmap","text":"<ul> <li>v0.2 \u2014 Async command support, richer plugin registry.</li> <li>v1.0 \u2014 Community plugin marketplace, benchmarks vs. alternatives.</li> </ul> <p>Track progress and suggest features via Issues.</p> <p>Back to top</p>"},{"location":"index.html#docs-resources","title":"Docs &amp; Resources","text":"<ul> <li>Site: https://bijux.github.io/bijux-cli/</li> <li>Changelog: https://github.com/bijux/bijux-cli/blob/main/CHANGELOG.md</li> <li>Repository: https://github.com/bijux/bijux-cli</li> <li>Issues: https://github.com/bijux/bijux-cli/issues</li> <li>Security: Report privately via GitHub Advisory https://github.com/bijux/bijux-cli/security/advisories/new</li> <li>Tests: See TESTS.md</li> <li>Project Tree: See PROJECT_TREE.md</li> </ul> <p>When filing issues, include <code>--debug</code> output where possible.</p> <p>Back to top</p>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>Welcome! See CONTRIBUTING.md for setup, style, and tests. We label good first issue to help you get started.</p> <p>Back to top</p>"},{"location":"index.html#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Built on Typer (CLI), FastAPI (HTTP API), and Injector (DI).</li> <li>Inspired by Click, Typer, and Cobra.</li> <li>Thanks to early contributors and testers!</li> </ul> <p>Back to top</p>"},{"location":"index.html#license","title":"License","text":"<p>MIT \u2014 see LICENSES/MIT.txt. \u00a9 2025 Bijan Mousavi.</p> <p>Back to top</p>"},{"location":"changelog.html","title":"Changelog","text":"<p>All notable changes to Bijux CLI are documented here. This project adheres to Semantic Versioning and the Keep a Changelog format.</p>"},{"location":"changelog.html#unreleased","title":"Unreleased","text":""},{"location":"changelog.html#added","title":"Added","text":"<ul> <li>(add new entries via Towncrier fragments in <code>changelog.d/</code>)</li> </ul>"},{"location":"changelog.html#changed","title":"Changed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog.html#fixed","title":"Fixed","text":"<ul> <li>(add here)</li> </ul>"},{"location":"changelog.html#011-2025-08-14","title":"0.1.1 \u2013 2025-08-14","text":""},{"location":"changelog.html#added_1","title":"Added","text":"<ul> <li>Publish pipeline: GitHub Actions <code>publish.yml</code> that publishes via <code>make publish</code> only after required checks are green and a tag is present.</li> <li>Project map: <code>PROJECT_TREE.md</code> (and <code>docs/project_tree.md</code>) with a curated overview.</li> <li>Docs assets: Community landing page, Plausible analytics partial, and CSS overrides.</li> <li>Docs generator: <code>scripts/helper_mkdocs.py</code> now folds <code>TESTS.md</code> and <code>PROJECT_TREE.md</code> into the site nav.</li> </ul>"},{"location":"changelog.html#changed_1","title":"Changed","text":"<ul> <li>README / USAGE: Refined copy; standardized <code>{#top}</code> anchors and links to TESTS.md and PROJECT_TREE.md.</li> <li>SECURITY.md: Rewritten with clearer reporting, SLAs, scope, and safe harbor.</li> <li>Makefiles: macOS-safe env handling; Cairo-less Interrogate wrapper for doc coverage.</li> <li>Config: Expanded lints/dictionary; <code>mkdocs.yml</code> nav tightened.</li> </ul>"},{"location":"changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>Tests: E2E version fixtures cleaned up.</li> </ul>"},{"location":"changelog.html#packaging","title":"Packaging","text":"<ul> <li>PyPI links corrected: <code>project.urls</code> now points to accurate Homepage/Docs/Changelog/Issues/Discussions.</li> <li>Dynamic versioning from Git tags: Using <code>hatch-vcs</code> with <code>dynamic = [\"version\"]</code>; annotated tags like <code>v0.1.1</code> define the release version. <code>commitizen</code> tags as <code>v$version</code>.</li> <li>Richer PyPI description: <code>hatch-fancy-pypi-readme</code> renders README.md + CHANGELOG.md on PyPI.</li> <li>Wheel/Sdist layout: Explicit Hatch build config ensures <code>py.typed</code>, licenses, and metadata are included.</li> </ul>"},{"location":"changelog.html#010-2025-08-12","title":"0.1.0 \u2013 2025-08-12","text":""},{"location":"changelog.html#added_2","title":"Added","text":"<ul> <li> <p>Core runtime</p> <ul> <li>Implemented Dependency Injection kernel, REPL shell, plugin loader, telemetry hooks, and shell completion (bash/zsh/fish).</li> <li>Added core modules: <code>api</code>, <code>cli</code>, <code>httpapi</code>, <code>core/{constants,context,di,engine,enums,exceptions,paths}</code>.</li> </ul> </li> <li> <p>Contracts layer (<code>contracts/</code>)</p> <ul> <li>Defined protocols for <code>audit</code>, <code>config</code>, <code>context</code>, <code>docs</code>, <code>doctor</code>, <code>emitter</code>, <code>history</code>,   <code>memory</code>, <code>observability</code>, <code>process</code>, <code>registry</code>, <code>retry</code>, <code>serializer</code>, <code>telemetry</code>.</li> <li>Added <code>py.typed</code> markers for downstream type checking.</li> </ul> </li> <li> <p>Services layer</p> <ul> <li>Implemented concrete services for <code>audit</code>, <code>config</code>, <code>docs</code>, <code>doctor</code>, <code>history</code>, <code>memory</code>.</li> <li>Built plugin subsystem: <code>plugins/{entrypoints,groups,hooks,registry}</code>.</li> </ul> </li> <li> <p>Infra layer (<code>infra/</code>)</p> <ul> <li>Implemented <code>emitter</code>, <code>observability</code>, <code>process</code>, <code>retry</code>, <code>serializer</code>, <code>telemetry</code>.</li> </ul> </li> <li> <p>Command suite</p> <ul> <li>Added top-level commands: <code>audit</code>, <code>docs</code>, <code>doctor</code>, <code>help</code>, <code>repl</code>, <code>sleep</code>, <code>status</code>, <code>version</code>.</li> <li>Added <code>config/</code> commands: <code>clear</code>, <code>export</code>, <code>get</code>, <code>list</code>, <code>load</code>, <code>reload</code>, <code>set</code>, <code>unset</code>, <code>service</code>.</li> <li>Added <code>dev/</code> commands: <code>di</code>, <code>list-plugins</code>, <code>service</code>.</li> <li>Added <code>history/</code> commands: <code>clear</code>, <code>service</code>.</li> <li>Added <code>memory/</code> commands: <code>clear</code>, <code>delete</code>, <code>get</code>, <code>list</code>, <code>set</code>, <code>service</code>.</li> <li>Added <code>plugins/</code> commands: <code>check</code>, <code>info</code>, <code>install</code>, <code>list</code>, <code>scaffold</code>, <code>uninstall</code>.</li> </ul> </li> <li> <p>Structured output &amp; flags</p> <ul> <li>Added JSON/YAML output via <code>--format</code>, pretty printing, and deterministic global flag precedence (ADR-0002).</li> </ul> </li> <li> <p>API contract validation &amp; testing</p> <ul> <li>Automated lint/validation of <code>api/*.yaml</code> with Prance, OpenAPI Spec Validator, Redocly, and OpenAPI Generator.</li> <li>Added Schemathesis contract testing against the running server.</li> <li>Pinned OpenAPI Generator CLI version via <code>OPENAPI_GENERATOR_VERSION</code> and automated Node.js toolchain setup in Makefile.</li> </ul> </li> <li> <p>Documentation tooling</p> <ul> <li>Integrated MkDocs (Material), mkdocstrings, literate-nav, and ADR index generation.</li> </ul> </li> <li> <p>Quality &amp; security pipeline</p> <ul> <li>Added formatting/linting: <code>ruff</code> (+format).</li> <li>Added typing: <code>mypy</code>, <code>pyright</code>, <code>pytype</code>.</li> <li>Added docs style/coverage: <code>pydocstyle</code>, <code>interrogate</code>.</li> <li>Added code health: <code>vulture</code>, <code>deptry</code>, <code>radon</code>, <code>codespell</code>, <code>reuse</code>.</li> <li>Added security: <code>bandit</code>, <code>pip-audit</code>.</li> <li>Added mutation testing: <code>mutmut</code>, <code>cosmic-ray</code>.</li> </ul> </li> <li> <p>SBOM</p> <ul> <li>Generated CycloneDX JSON for prod/dev dependencies via <code>make sbom</code> (uses <code>pip-audit</code>).</li> </ul> </li> <li> <p>Citation</p> <ul> <li>Validated <code>CITATION.cff</code> and added export to BibTeX/RIS/EndNote formats via <code>make citation</code>.</li> </ul> </li> <li> <p>Makefile architecture</p> <ul> <li>Modularized the Makefile into <code>makefiles/*.mk</code> for maintainability and clear separation of concerns.</li> <li>Centralized all developer workflows (<code>test</code>, <code>lint</code>, <code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>, <code>build</code>, <code>sbom</code>, <code>citation</code>, <code>changelog</code>, <code>publish</code>) in one consistent interface.</li> <li>Added <code>bootstrap</code> target for idempotent virtualenv setup and Git hook installation from <code>scripts/git-hooks</code> (skips re-installation if already linked).</li> <li>Added <code>all-parallel</code> target to run independent checks (<code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>) concurrently for faster CI/CD.</li> <li>Added <code>make help</code> for self-documenting targets with grouped sections.</li> <li>Provided helper macros (<code>run_tool</code>, <code>read_pyproject_version</code>) to standardize tooling invocation.</li> </ul> </li> <li> <p>pre-commit</p> <ul> <li>Added hygiene hooks: <code>ruff-format</code> + <code>ruff</code>, <code>mdformat</code>, and <code>codespell</code>.</li> <li>Enforced Conventional Commits via commitizen <code>commit-msg</code> hook.</li> </ul> </li> <li> <p>tox orchestration</p> <ul> <li>Configured multi-Python test envs (<code>py311</code>, <code>py312</code>, <code>py313</code>).</li> <li>Mapped Makefile workflows into tox envs (<code>lint</code>, <code>quality</code>, <code>security</code>, <code>api</code>, <code>docs</code>, <code>build</code>, <code>sbom</code>, <code>changelog</code>, <code>citation</code>) to ensure reproducibility.</li> <li>Passed <code>MAKEFLAGS</code> to execute Makefile targets inside tox-managed virtualenvs.</li> </ul> </li> <li> <p>Continuous Integration</p> <ul> <li>Added GitHub Actions workflow running tox across Python versions with Node.js 20 and Java 17 for API checks.</li> <li>Added GitLab CI sample mirroring the GitHub workflow (tox-driven) with artifacts for coverage and API logs.</li> <li>CI/CD pipelines directly leverage the modularized Makefile for consistent local/CI behavior.</li> </ul> </li> <li> <p>Packaging / PyPI page</p> <ul> <li>Built dynamic long description via hatch-fancy-pypi-readme from README.md and CHANGELOG.md for PyPI/TestPyPI.</li> <li>Packaged with <code>LICENSES/</code>, <code>REUSE.toml</code>, <code>CITATION.cff</code>, and <code>py.typed</code> included in source distributions.</li> </ul> </li> </ul>"},{"location":"changelog.html#changed_2","title":"Changed","text":"<ul> <li>Released initial public version.</li> </ul>"},{"location":"changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>None</li> </ul>"},{"location":"code_of_conduct.html","title":"Code of Conduct","text":""},{"location":"code_of_conduct.html#top","title":"Code of Conduct","text":"<p>We pledge to make participation in this community a harassment-free experience for everyone\u2014regardless of age, body size, disability (visible or invisible), ethnicity, sex characteristics, gender identity or expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual orientation. We commit to interactions that are open, welcoming, inclusive, and healthy.</p>"},{"location":"code_of_conduct.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Our Pledge</li> <li>Our Standards</li> <li>Enforcement Responsibilities</li> <li>Scope</li> <li>Reporting</li> <li>Enforcement Guidelines</li> <li>Appeals</li> <li>Attribution</li> </ul> <p>Back to top</p>"},{"location":"code_of_conduct.html#our-pledge","title":"Our Pledge","text":"<p>We pledge to make participation in this community a harassment-free experience for everyone\u2014regardless of age, body size, disability (visible or invisible), ethnicity, sex characteristics, gender identity or expression, level of experience, education, socioeconomic status, nationality, personal appearance, race, religion, or sexual orientation. We commit to interactions that are open, welcoming, inclusive, and healthy.</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#our-standards","title":"Our Standards","text":"<p>Positive behaviors</p> <ul> <li>Show empathy, kindness, and respect.</li> <li>Welcome different opinions and experiences.</li> <li>Give and receive constructive feedback gracefully.</li> <li>Own mistakes, apologize, and learn.</li> <li>Prioritize what benefits the community as a whole.</li> </ul> <p>Unacceptable behaviors</p> <ul> <li>Sexualized language or imagery; unwelcome sexual attention or advances.</li> <li>Trolling; insulting/derogatory remarks; personal or political attacks.</li> <li>Public or private harassment; deliberate intimidation or stalking.</li> <li>Publishing others\u2019 private information (e.g., physical or email address) without explicit permission.</li> <li>Deliberate misgendering or use of deadnames.</li> <li>Any conduct a reasonable person would deem inappropriate in a professional setting.</li> </ul> <p>Back to top</p>"},{"location":"code_of_conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Project maintainers are responsible for clarifying and enforcing this Code. They may remove or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code and will communicate moderation reasons when appropriate. Actions will be proportional to the circumstances.</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#scope","title":"Scope","text":"<p>This Code applies in all project spaces (repositories, issues, discussions, chats) and when individuals are officially representing the project in public spaces (e.g., using an official email, posting via an official account, or representing the project at events\u2014online or offline).</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#reporting","title":"Reporting","text":"<p>Report abusive, harassing, or otherwise unacceptable behavior to the maintainers at mousavi.bijan@gmail.com.</p> <p>To help us investigate, please include (to the extent you\u2019re comfortable):</p> <ul> <li>What happened, and when</li> <li>Where it occurred (link, channel, or location)</li> <li>Names of people involved and any witnesses</li> <li>Any relevant context or screenshots</li> </ul> <p>We will acknowledge receipt as soon as possible and handle reports promptly and fairly. We will respect the privacy and safety of reporters and witnesses.</p> <p>Anti-retaliation: Retaliation against anyone who reports a concern or participates in an investigation is a violation of this Code.</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>1) Correction</p> <p>Impact: Inappropriate or unprofessional behavior.</p> <p>Consequence: Private, written warning that clarifies the violation and sets expectations. A public apology may be requested.</p> <p>2) Warning</p> <p>Impact: A violation through a single incident or a series of actions.</p> <p>Consequence: Formal warning with clear consequences for continued behavior. Limited interaction with affected parties or spaces for a set period.</p> <p>3) Temporary Ban</p> <p>Impact: Serious or sustained violations.</p> <p>Consequence: Temporary ban from interaction or public communication in project spaces for a set period. No public or private interaction with affected parties or enforcers during this time.</p> <p>4) Permanent Ban</p> <p>Impact: Pattern of violations, harassment, or aggression toward individuals or protected classes.</p> <p>Consequence: Permanent ban from all public project spaces.</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#appeals","title":"Appeals","text":"<p>If you believe an action was taken in error or without sufficient context, you may appeal by replying to the original enforcement notice or emailing mousavi.bijan@gmail.com with additional information. Appeals will be reviewed by maintainers not directly involved in the original decision when possible.</p> <p>Back to top</p>"},{"location":"code_of_conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct adapts the Contributor Covenant v2.1 https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines are inspired by the Mozilla Community Participation Guidelines. FAQ: https://www.contributor-covenant.org/faq \u2022 Translations: https://www.contributor-covenant.org/translations</p> <p>Back to top</p> <p>Back to top</p>"},{"location":"community.html","title":"Community","text":"<p>Project policies and how to get involved.</p> <ul> <li>Code of Conduct</li> <li>Contributing</li> <li>Security</li> <li>License</li> </ul>"},{"location":"contributing.html","title":"Contributing","text":""},{"location":"contributing.html#top","title":"Contributing to Bijux CLI","text":"<p>This guide is the single source of truth for local setup, workflows, API validation, and PR rules. Follow it to ensure your changes pass CI seamlessly.\ufe0f</p>"},{"location":"contributing.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Daily Workflow</li> <li>API Development</li> <li>Docs</li> <li>Tests &amp; Coverage</li> <li>Style, Types, Hygiene</li> <li>Security &amp; Supply Chain</li> <li>Tox Envs (Mirror CI)</li> <li>Commits &amp; PRs</li> <li>Pre-Commit</li> <li>Troubleshooting</li> <li>Community &amp; Conduct</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#quick-start","title":"Quick Start","text":"<p>Prereqs</p> <ul> <li>Python 3.11 / 3.12 / 3.13 (<code>pyenv</code> recommended)</li> <li>GNU Make</li> <li>Node.js + npm (for API validation tooling)</li> <li>Optional: pre-commit (to catch issues before pushing)</li> </ul> <p>Setup</p> <pre><code>git clone https://github.com/bijux/bijux-cli.git\ncd bijux-cli\nmake PYTHON=python3.11 install\nsource .venv/bin/activate\n# optional but recommended\npre-commit install\n</code></pre> <p>Sanity check</p> <pre><code>make lint test docs api\n</code></pre> <ul> <li>\u2714 Pass \u2192 your env matches CI</li> <li>\u2718 Fail \u2192 jump to Troubleshooting</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#daily-workflow","title":"Daily Workflow","text":"<ul> <li>Everything runs inside .venv/</li> <li>No global installs after <code>make install</code></li> <li>Make targets mirror CI jobs 1:1</li> </ul> <p>Core targets</p> Target What it does <code>make test</code> <code>pytest</code> + coverage (HTML in <code>htmlcov/</code>) <code>make lint</code> Format (ruff), lint (ruff), type-check (mypy/pyright), complexity (radon) <code>make quality</code> Dead code (vulture), deps hygiene (deptry), REUSE, docstrings (interrogate) <code>make security</code> Bandit + pip-audit <code>make api</code> OpenAPI lint + generator compat + Schemathesis contract tests <code>make docs</code> Build MkDocs (strict) <code>make build</code> Build sdist + wheel <code>make sbom</code> CycloneDX SBOM \u2192 <code>artifacts/sbom.json</code> <code>make mutation</code> Mutation testing (Cosmic Ray + Mutmut) <p>Handy helpers</p> <pre><code>make lint-file file=path/to/file.py\nmake docs-serve # local docs server\n# make docs-deploy # if you have perms\n</code></pre> <p>Back to top</p>"},{"location":"contributing.html#api-development","title":"API Development","text":"<p>Schema: <code>api/v1/schema.yaml</code></p> <p>Tooling: Prance, OpenAPI Spec Validator, Redocly, OpenAPI Generator, Schemathesis</p> <p>Validate locally</p> <pre><code>.venv/bin/uvicorn bijux_cli.httpapi:app --host 0.0.0.0 --port 8000 &amp;\nmake api\n</code></pre> <p>Contract rules</p> <ul> <li>Errors use RFC 7807 Problem JSON</li> <li>Response shapes and pagination are stable or versioned</li> <li>Breaking changes require a versioned path and a changelog entry</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#docs","title":"Docs","text":"<ul> <li>Config: <code>mkdocs.yml</code> (Material, strict)</li> <li>Build: <code>make docs</code></li> <li>Serve: <code>make docs-serve</code></li> <li>Deploy: <code>make docs-deploy</code> (if authorized)</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#tests-coverage","title":"Tests &amp; Coverage","text":"<ul> <li>Run all tests: <code>make test</code></li> <li>Focused run: <code>pytest -k \"&lt;expr&gt;\" -q</code></li> <li>Coverage report: HTML in <code>htmlcov/</code>   (Project enforces a high bar; keep it green.)</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#style-types-hygiene","title":"Style, Types, Hygiene","text":"<ul> <li>Formatting: <code>ruff format</code> (enforced in <code>make lint</code>)</li> <li>Linting: <code>ruff</code></li> <li>Types: <code>mypy</code> (strict) + <code>pyright</code> (strict)</li> <li>Complexity: <code>radon</code></li> <li>Docstrings: <code>interrogate</code> (keep modules \u2265 target thresholds)</li> </ul> <p>Run them all:</p> <pre><code>make lint\n</code></pre> <p>Back to top</p>"},{"location":"contributing.html#security-supply-chain","title":"Security &amp; Supply Chain","text":"<pre><code>make security # bandit + pip-audit\nmake sbom # CycloneDX, saved to artifacts/\n</code></pre> <ul> <li>No secrets in code or tests</li> <li>Keep dependency pins sane; document any suppressions</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#tox-envs-mirror-ci","title":"Tox Envs (Mirror CI)","text":"Env Runs <code>py311</code> / <code>py312</code> / <code>py313</code> <code>make test</code> <code>lint</code> <code>make lint</code> <code>quality</code> <code>make quality</code> <code>security</code> <code>make security</code> <code>api</code> <code>make api</code> <code>docs</code> <code>make docs</code> <code>build</code> <code>make build</code> <code>sbom</code> <code>make sbom</code> <p>List all:</p> <pre><code>tox -av\n</code></pre> <p>Back to top</p>"},{"location":"contributing.html#commits-prs","title":"Commits &amp; PRs","text":""},{"location":"contributing.html#conventional-commits-required","title":"Conventional Commits (required)","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n</code></pre> <p>Types: <code>feat</code> <code>fix</code> <code>docs</code> <code>style</code> <code>refactor</code> <code>test</code> <code>chore</code></p> <p>Example</p> <pre><code>feat(plugins): add plugin scaffolding command\n</code></pre> <p>Breaking changes must include:</p> <pre><code>BREAKING CHANGE: &lt;explanation&gt;\n</code></pre> <p>Commit messages are validated (Commitizen via pre-commit hook).</p>"},{"location":"contributing.html#pr-checklist","title":"PR Checklist","text":"<ol> <li>Branch from <code>main</code></li> <li>Run:    <pre><code>make lint test api docs\n</code></pre></li> <li>Ensure Conventional Commits</li> <li>Open PR with clear summary &amp; rationale</li> </ol> <p>Back to top</p>"},{"location":"contributing.html#pre-commit","title":"Pre-Commit","text":"<pre><code>pre-commit install\n</code></pre> <p>Runs critical checks locally (format, lint, commit message validation, etc.).</p> <p>Back to top</p>"},{"location":"contributing.html#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Missing Node.js \u2192 required for API validation tools</li> <li>Docs fail \u2192 MkDocs is strict; fix broken links/includes</li> <li>pytype on Python &gt; 3.12 \u2192 skipped automatically</li> <li>Port in use for API tests \u2192 kill old <code>uvicorn</code> or use a different port</li> </ul> <p>Back to top</p>"},{"location":"contributing.html#community-conduct","title":"Community &amp; Conduct","text":"<p>Be kind and constructive. See the Code of Conduct in the docs site. If you see something off, let us know.</p> <p>Back to top</p> <p>Build well. Break nothing.</p> <p>Back to top</p>"},{"location":"nav.html","title":"Full Navigation","text":"<ul> <li>Home</li> <li>User Guide</li> <li>Project Tree</li> <li>Tests</li> <li>API Reference<ul> <li>Api Module</li> <li>Cli Module</li> <li>Httpapi Module</li> <li>Commands<ul> <li>Audit Command</li> <li>Docs Command</li> <li>Doctor Command</li> <li>Help Command</li> <li>Repl Command</li> <li>Sleep Command</li> <li>Status Command</li> <li>Utilities Command</li> <li>Version Command</li> </ul> </li> <li>Contracts<ul> <li>Audit Module</li> <li>Config Module</li> <li>Context Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>Emitter Module</li> <li>History Module</li> <li>Memory Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Registry Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul> </li> <li>Core<ul> <li>Constants Module</li> <li>Context Module</li> <li>Di Module</li> <li>Engine Module</li> <li>Enums Module</li> <li>Exceptions Module</li> <li>Paths Module</li> </ul> </li> <li>Infra<ul> <li>Emitter Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul> </li> <li>Services<ul> <li>Audit Module</li> <li>Config Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>History Module</li> <li>Memory Module</li> <li>Utils Module</li> </ul> </li> <li>Commands/config<ul> <li>Clear Command</li> <li>Export Command</li> <li>Get Command</li> <li>List_cmd Command</li> <li>Load Command</li> <li>Reload Command</li> <li>Service Command</li> <li>Set Command</li> <li>Unset Command</li> </ul> </li> <li>Commands/dev<ul> <li>Di Command</li> <li>List_plugins Command</li> <li>Service Command</li> </ul> </li> <li>Commands/history<ul> <li>Clear Command</li> <li>Service Command</li> </ul> </li> <li>Commands/memory<ul> <li>Clear Command</li> <li>Delete Command</li> <li>Get Command</li> <li>List Command</li> <li>Service Command</li> <li>Set Command</li> <li>Utils Command</li> </ul> </li> <li>Commands/plugins<ul> <li>Check Command</li> <li>Info Command</li> <li>Install Command</li> <li>List Command</li> <li>Scaffold Command</li> <li>Uninstall Command</li> <li>Utils Command</li> </ul> </li> <li>Services/plugins<ul> <li>Entrypoints Module</li> <li>Groups Module</li> <li>Hooks Module</li> <li>Registry Module</li> </ul> </li> </ul> </li> <li>Changelog</li> <li>Architecture Decision Records<ul> <li>ADR 0002: Global Flags Precedence</li> <li>ADR 0003: Docstring And Documentation Style</li> <li>ADR 0004: Linting Quality Security</li> </ul> </li> <li>Community<ul> <li>Code of Conduct</li> <li>Contributing</li> <li>Security</li> <li>License</li> </ul> </li> </ul>"},{"location":"project_tree.html","title":"Project Tree &amp; Guide","text":"<p>A guided map of the Bijux CLI repository: what lives where, and why.</p> <p>Back to top</p>"},{"location":"project_tree.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>At a Glance</li> <li>Top-Level Files</li> <li>Dotfiles &amp; CI/CD (Hidden .* Files)</li> <li>Source Code (<code>src/bijux_cli/</code>)</li> <li>Commands</li> <li>Services</li> <li>Contracts</li> <li>Core</li> <li>Infra</li> <li>Root Modules</li> <li>API Schema (<code>api/</code>)</li> <li>Documentation Site (<code>docs/</code>)</li> <li>Configuration (<code>config/</code>)</li> <li>Build &amp; Automation (<code>makefiles/</code>, <code>scripts/</code>)</li> <li>Plugin Template (<code>plugin_template/</code>)</li> <li>Tests (<code>tests/</code>)</li> <li>Packaging &amp; Tooling</li> <li>Licensing &amp; Governance</li> <li>Changelog &amp; Releases</li> </ul> <p>Back to top</p>"},{"location":"project_tree.html#at-a-glance","title":"At a Glance","text":"<pre><code>.\n\u251c\u2500\u2500 api/                # OpenAPI schemas\n\u251c\u2500\u2500 config/             # Lint/type/security configs\n\u251c\u2500\u2500 docs/               # MkDocs site (Material theme)\n\u251c\u2500\u2500 makefiles/          # Makefile modules for tasks\n\u251c\u2500\u2500 plugin\\_template/    # Cookiecutter-compatible plugin scaffold\n\u251c\u2500\u2500 scripts/            # Helper scripts (hooks, docs generation)\n\u251c\u2500\u2500 src/bijux\\_cli/      # Library + CLI implementation\n\u251c\u2500\u2500 tests/              # Unit, integration, functional, E2E\n\u2514\u2500\u2500 .github/workflows/  # CI/CD pipelines (GitHub Actions)\n</code></pre> <p>Back to top</p>"},{"location":"project_tree.html#top-level-files","title":"Top-Level Files","text":"<ul> <li><code>README.md</code> \u2014 overview and quickstart</li> <li><code>USAGE.md</code> \u2014 user guide</li> <li><code>TESTS.md</code> \u2014 testing philosophy &amp; how to run tests</li> <li><code>PROJECT_TREE.md</code> \u2014 this guided map (mirrors <code>docs/project_tree.md</code> on the site)</li> <li><code>SECURITY.md</code>, <code>CODE_OF_CONDUCT.md</code>, <code>CONTRIBUTING.md</code> \u2014 community &amp; policy</li> <li><code>CHANGELOG.md</code>, <code>changelog.d/</code> \u2014 release notes + fragments</li> <li><code>pyproject.toml</code>, <code>tox.ini</code>, <code>pytest.ini</code> \u2014 packaging &amp; test config</li> <li><code>mkdocs.yml</code> \u2014 docs site config</li> <li><code>LICENSES/</code> \u2014 MIT and CC0 texts</li> <li><code>CITATION.cff</code> \u2014 citation metadata</li> <li><code>REUSE.toml</code> \u2014 REUSE licensing compliance</li> <li><code>Makefile</code> \u2014 task entrypoint (delegates to <code>makefiles/</code>)</li> </ul> <p>Back to top</p>"},{"location":"project_tree.html#dotfiles--cicd-hidden--files","title":"Dotfiles &amp; CI/CD (Hidden .* Files)","text":"<p>Hidden files/directories that govern editor behavior, linting, hooks, and pipelines.</p> <p><pre><code>.\n\u251c\u2500\u2500 .editorconfig                # Consistent whitespace/charset across editors\n\u251c\u2500\u2500 .gitattributes               # EOL normalization, linguist hints\n\u251c\u2500\u2500 .gitignore                   # VCS ignores (build, venvs, caches)\n\u251c\u2500\u2500 .gitlab-ci.yml               # Optional GitLab CI parity (if used)\n\u251c\u2500\u2500 .pre-commit-config.yaml      # Pre-commit hook suite (ruff, mypy, etc.)\n\u2514\u2500\u2500 .github/\n\u2514\u2500\u2500 workflows/\n\u251c\u2500\u2500 ci.yml               # Tests, lint, type-check, security, build\n\u2514\u2500\u2500 docs.yml             # Docs build/deploy\n\n````\n\n**Pre-commit (recommended):**\n\n```bash\npipx install pre-commit || python -m pip install -U pre-commit\npre-commit install\npre-commit run --all-files\n````\n\n[Back to top](#top)\n\n---\n\n## Source Code (`src/bijux_cli/`) {#source-code-srcbijux\\_cli}\n\nPrimary implementation: CLI entrypoints, DI kernel, services, contracts, and infrastructure.\n</code></pre> src/bijux_cli/ \u251c\u2500\u2500 init.py \u251c\u2500\u2500 main.py             # python -m bijux_cli \u251c\u2500\u2500 version.py \u251c\u2500\u2500 api.py                  # HTTP API wiring (if enabled) \u251c\u2500\u2500 cli.py                  # Typer root app (entrypoint) \u251c\u2500\u2500 httpapi.py              # HTTP server endpoints \u251c\u2500\u2500 commands/               # User-facing commands \u251c\u2500\u2500 services/               # Business logic implementations \u251c\u2500\u2500 contracts/              # Typed interfaces (protocols) \u251c\u2500\u2500 core/                   # Engine, DI, enums, exceptions, paths \u2514\u2500\u2500 infra/                  # Emitters, serializers, telemetry, retry, process <pre><code>*`py.typed` files (PEP 561) are included across packages to advertise type completeness.*\n\n[Back to top](#top)\n\n### Commands {#commands}\n\nEnd-user commands and subcommands. Each file is a Typer command module.\n</code></pre> reference/commands/index.md \u251c\u2500\u2500 audit.py  docs.py  doctor.py  help.py  repl.py  sleep.py \u251c\u2500\u2500 status.py  utilities.py  version.py \u251c\u2500\u2500 config/   # clear/export/get/list_cmd/load/reload/service/set/unset \u251c\u2500\u2500 dev/      # di/list_plugins/service \u251c\u2500\u2500 history/  # clear/service \u251c\u2500\u2500 memory/   # clear/delete/get/list/service/set/utils \u2514\u2500\u2500 plugins/  # check/info/install/list/scaffold/uninstall/utils <pre><code>* **Top-level commands**: operational functions (`doctor`, `status`, `audit`, \u2026).\n* **Namespace commands** group related operations and include a `service.py` adapter.\n\n[Back to top](#top)\n\n### Services {#services}\n\nConcrete implementations behind commands. Orchestrate work, depend on `contracts` and `infra`.\n</code></pre> src/bijux_cli/services/ \u251c\u2500\u2500 audit.py  config.py  docs.py  doctor.py \u251c\u2500\u2500 history.py  memory.py  utils.py \u2514\u2500\u2500 plugins/ (entrypoints.py, groups.py, hooks.py, registry.py) <pre><code>[Back to top](#top)\n\n### Contracts {#contracts}\n\nTyped interfaces (protocols/ABCs) consumed by services \u2014 clean DI seams.\n</code></pre> src/bijux_cli/contracts/ audit.py  config.py  context.py  docs.py  doctor.py  emitter.py history.py  memory.py  observability.py  process.py  registry.py retry.py  serializer.py  telemetry.py <pre><code>[Back to top](#top)\n\n### Core {#core}\n\nFramework plumbing: engine loop, DI kernel, exceptions, enums, and path helpers.\n</code></pre> src/bijux_cli/core/ constants.py  context.py  di.py  engine.py  enums.py  exceptions.py  paths.py <pre><code>[Back to top](#top)\n\n### Infra {#infra}\n\nFoundational adapters/utilities used across services.\n</code></pre> src/bijux_cli/infra/ emitter.py  observability.py  process.py  retry.py  serializer.py  telemetry.py <pre><code>[Back to top](#top)\n\n### Root Modules {#root-modules}\n\n* `cli.py` \u2014 Typer app creation and command registration\n* `api.py` / `httpapi.py` \u2014 HTTP API composition (if used)\n* `__main__.py` \u2014 module entry (`python -m bijux_cli`)\n* `__version__.py` \u2014 central version string\n\n[Back to top](#top)\n\n---\n\n## API Schema (`api/`) {#api-schema-api}\n</code></pre> api/ \u2514\u2500\u2500 v1/     \u2514\u2500\u2500 schema.yaml   # OpenAPI spec for the HTTP API <pre><code>Source of truth for the public HTTP API (if enabled). Used for validation and documentation.\n\n[Back to top](#top)\n\n---\n\n## Documentation Site (`docs/`) {#documentation-site-docs}\n\nMkDocs (Material) site; build with `make docs-serve` / `mkdocs build`.\n</code></pre> docs/ \u251c\u2500\u2500 index.md            # Home (wraps README) \u251c\u2500\u2500 usage.md            # User Guide (wraps USAGE) \u251c\u2500\u2500 tests.md            # Testing overview (wraps TESTS.md) \u251c\u2500\u2500 project_tree.md     # This guide (wraps PROJECT_TREE) \u251c\u2500\u2500 changelog.md        # Wraps CHANGELOG.md \u251c\u2500\u2500 security.md         # Wraps SECURITY.md \u251c\u2500\u2500 contributing.md     # Wraps CONTRIBUTING.md \u251c\u2500\u2500 code_of_conduct.md  # Wraps CODE_OF_CONDUCT.md \u251c\u2500\u2500 license.md          # Wraps LICENSES/MIT.txt \u251c\u2500\u2500 community.md        # Community landing (overview page) \u251c\u2500\u2500 ADR/                # Architecture Decision Records \u251c\u2500\u2500 assets/             # Logos, CSS (Material overrides in assets/styles/extra.css) \u251c\u2500\u2500 overrides/          # Jinja2 overrides for Material theme \u2514\u2500\u2500 nav.md              # Generated by helper script <pre><code>&gt; `scripts/helper_mkdocs.py` generates API reference pages and a full navigation map at build time.\n\n[Back to top](#top)\n\n---\n\n## Configuration (`config/`) {#configuration-config}\n\nCentralized tool configs:\n</code></pre> config/ \u251c\u2500\u2500 bijux.dic             # custom dictionary \u251c\u2500\u2500 mypy.ini              # type checking \u251c\u2500\u2500 pyrightconfig.json    # pyright settings \u251c\u2500\u2500 ruff.toml             # lint rules (ruff) \u251c\u2500\u2500 coveragerc.ini        # coverage config \u251c\u2500\u2500 cosmic-ray.toml       # mutation testing \u2514\u2500\u2500 README.md             # notes about configs <pre><code>[Back to top](#top)\n\n---\n\n## Build &amp; Automation (`makefiles/`, `scripts/`) {#build--automation-makefilesscripts}\n\n**Makefile modules**\n</code></pre> makefiles/ api.mk  build.mk  changelog.mk  citation.mk  dictionary.mk docs.mk hooks.mk  lint.mk  mutation.mk  publish.mk  quality.mk sbom.mk security.mk  test.mk <pre><code>**Helper scripts**\n</code></pre> scripts/ \u251c\u2500\u2500 helper_mkdocs.py             # generates docs nav + API reference \u251c\u2500\u2500 helper_comments.py           # doc/comment utilities \u251c\u2500\u2500 check-towncrier-fragment.sh  # changelog fragments guard \u251c\u2500\u2500 git-hooks/prepare-commit-msg # conventional commit assist \u2514\u2500\u2500 README.md <pre><code>[Back to top](#top)\n\n---\n\n## Plugin Template (`plugin_template/`) {#plugin-template-plugin\\_template}\n\nCookiecutter-ready skeleton for third-party plugins.\n</code></pre> plugin_template/ \u251c\u2500\u2500 README.md  init.py  cookiecutter.json  pyproject.toml \u2514\u2500\u2500 {{cookiecutter.project_slug}}/     \u251c\u2500\u2500 init.py     \u251c\u2500\u2500 plugin.json     \u2514\u2500\u2500 plugin.py <pre><code>* `plugin.json` \u2014 plugin metadata &amp; entry points\n* `plugin.py` \u2014 plugin\u2019s main module\n\n[Back to top](#top)\n\n---\n\n## Tests (`tests/`) {#tests-tests}\n\nFour layers: **unit**, **integration**, **functional**, **E2E**. See also [`TESTS.md`](tests.md) and `docs/tests.md`.\n</code></pre> tests/ \u251c\u2500\u2500 unit/          # Fast, isolated component tests \u251c\u2500\u2500 integration/   # Subsystem wiring, DI, flows \u251c\u2500\u2500 functional/    # User-facing behavior/flags/output \u2514\u2500\u2500 e2e/           # Full CLI runs + fixtures <pre><code>Highlights:\n\n* `e2e/test_fixtures/` \u2014 JSON/YAML expected outputs (shape tests)\n* Namespaced E2E (e.g., `plugins/`, `repl/`, `history/`) mirror command areas\n* Root tests (`unit/root/`) cover entry points: `__main__`, `cli`, `api`, `httpapi`\n\nRun examples:\n\n```bash\nmake test           # all tests\nmake test-unit      # unit only\nmake test-e2e       # end-to-end only\n</code></pre></p> <p>Back to top</p>"},{"location":"project_tree.html#packaging--tooling","title":"Packaging &amp; Tooling","text":"<ul> <li><code>pyproject.toml</code> \u2014 build system, dependencies, entry points</li> <li><code>tox.ini</code> \u2014 matrix/env automation</li> <li><code>pytest.ini</code> \u2014 Pytest defaults</li> <li><code>package.json</code>, <code>package-lock.json</code> \u2014 optional JS tooling for docs/assets</li> <li><code>REUSE.toml</code> \u2014 REUSE licensing compliance</li> </ul> <p>Back to top</p>"},{"location":"project_tree.html#licensing--governance","title":"Licensing &amp; Governance","text":"<ul> <li><code>LICENSES/</code> \u2014 MIT and CC0 texts</li> <li><code>CODE_OF_CONDUCT.md</code> \u2014 community guidelines</li> <li><code>CONTRIBUTING.md</code> \u2014 how to contribute</li> <li><code>SECURITY.md</code> \u2014 vulnerability reporting policy</li> <li><code>CITATION.cff</code> \u2014 citation metadata</li> </ul> <p>Back to top</p>"},{"location":"project_tree.html#changelog--releases","title":"Changelog &amp; Releases","text":"<ul> <li><code>CHANGELOG.md</code> \u2014 curated release notes</li> <li><code>changelog.d/</code> \u2014 fragment files (Towncrier-style)</li> <li>CI enforces fragment presence for PRs (see <code>scripts/check-towncrier-fragment.sh</code>)</li> </ul> <p>Back to top</p> <p>Tip: New to the codebase? Start at <code>reference/cli.md</code>, jump to the command under <code>reference/commands/index.md</code>, then follow into its corresponding service and contract.</p>"},{"location":"security.html","title":"Security Policy","text":""},{"location":"security.html#top","title":"Security Policy","text":"<p>Last updated: 2025-08-10</p> <p>We follow Coordinated Vulnerability Disclosure (CVD). Please report issues privately and allow time for remediation before public disclosure.</p> <p>Back to top</p>"},{"location":"security.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Supported Versions</li> <li>Reporting a Vulnerability</li> <li>Our Process &amp; SLAs</li> <li>Safe Harbor (Good-Faith Research)</li> <li>Scope</li> <li>Proactive Security Practices</li> <li>Contact</li> </ul> <p>Back to top</p>"},{"location":"security.html#supported-versions","title":"Supported Versions","text":"<p>We patch the latest minor line only.</p> Version Supported <code>0.1.x</code> Yes <code>&lt;0.1.0</code> No <p>When <code>0.2.0</code> is released, support for <code>0.1.x</code> ends. We do not backport beyond the most recent minor line.</p> <p>Back to top</p>"},{"location":"security.html#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Please report privately via one of the following channels:</p> <ul> <li>Preferred: GitHub Private Vulnerability Report https://github.com/bijux/bijux-cli/security/advisories/new</li> <li>Fallback: Email mousavi.bijan@gmail.com with subject   <code>[SECURITY] Vulnerability report: bijux-cli</code></li> </ul>"},{"location":"security.html#what-to-include","title":"What to include (to speed up triage)","text":"<ul> <li>Affected version(s), OS, Python version, and install method</li> <li>Clear impact statement and reproduction steps</li> <li>Minimal PoC if possible</li> <li>Suggested mitigations/workarounds (if any)</li> <li>Whether you\u2019d like credit (name/handle)</li> </ul> <p>Please do not include secrets or production data. If you encounter sensitive information, stop testing and report immediately.</p> <p>Back to top</p>"},{"location":"security.html#our-process--slas","title":"Our Process &amp; SLAs","text":"<p>Best-effort targets based on CVSS v3.x severity:</p> <ul> <li>Acknowledgement: within 48 hours</li> <li>Initial assessment &amp; provisional CVSS: within 5 business days</li> <li> <p>Target fix windows:</p> </li> <li> <p>Critical: 7 days</p> </li> <li>High: 30 days</li> <li>Medium: 90 days</li> <li>Low: 180 days</li> </ul> <p>We publish a GitHub Security Advisory once a fix is available and request a CVE when appropriate. Reporter credit is given with your consent.</p> <p>Back to top</p>"},{"location":"security.html#safe-harbor-good-faith-research","title":"Safe Harbor (Good-Faith Research)","text":"<p>We won\u2019t pursue or support legal action for good-faith testing that:</p> <ul> <li>Avoids privacy violations, data exfiltration, and service interruption</li> <li>Is limited to accounts/environments you control</li> <li>Respects rate limits (no volumetric DoS/spam)</li> <li>Does not escalate or persist beyond what\u2019s necessary to demonstrate impact</li> <li>Stops and reports immediately upon encountering sensitive data</li> </ul> <p>If you\u2019re unsure whether an activity is in scope, ask first via the channels above.</p> <p>Back to top</p>"},{"location":"security.html#scope","title":"Scope","text":"<p>In scope</p> <ul> <li>This repository\u2019s source code</li> <li>Release artifacts we publish</li> <li>CLI runtime behavior and default configurations</li> </ul> <p>Out of scope</p> <ul> <li>Social engineering or physical attacks</li> <li>Third-party platforms/services (unless our integration directly introduces the issue)</li> <li>Volumetric DoS (traffic floods, stress/benchmarking)</li> <li>Issues requiring pre-existing privileged local access without a plausible escalation path</li> <li>Vulnerabilities in third-party plugins not maintained by this org</li> </ul> <p>For dependency vulnerabilities, please also notify the upstream project. We will track, pin/upgrade, or mitigate downstream as needed.</p> <p>Back to top</p>"},{"location":"security.html#proactive-security-practices","title":"Proactive Security Practices","text":"<ul> <li>Dependency auditing: <code>pip-audit</code>; SBOM via CycloneDX (<code>artifacts/sbom.json</code>)</li> <li>Static analysis: <code>bandit</code> on Python sources</li> <li>Policy gates: CI blocks on failed security checks; any ignores are reviewed and documented</li> <li>Supply chain: pinned tooling where feasible; reproducible builds where practical; SBOM generated on release</li> </ul> <p>(No public bounty program at this time.)</p> <p>Back to top</p>"},{"location":"security.html#contact","title":"Contact","text":"<ul> <li>Private report: https://github.com/bijux/bijux-cli/security/advisories/new</li> <li>Email: mousavi.bijan@gmail.com</li> <li>Non-security questions: open a normal GitHub issue</li> </ul> <p>Thank you for helping keep Bijux CLI users safe.</p> <p>Back to top</p> <p>Back to top</p>"},{"location":"tests.html","title":"Comprehensive Testing in Bijux CLI","text":"<p>Predictable quality at scale. Bijux CLI ships with a deep, layered test suite (\u2248 2,664 tests) covering units, integrations, functional scenarios, and full E2E flows. CI enforces green builds across Python 3.11+ with strict linting, typing, and security gates.</p>"},{"location":"tests.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Testing Philosophy</li> <li>Suite Layout</li> <li> <p>Test Types</p> </li> <li> <p>Unit</p> </li> <li>Integration</li> <li>Functional</li> <li>End-to-End (E2E)</li> <li>Fixtures &amp; Data</li> <li>Conventions &amp; Markers</li> <li>Running Tests</li> <li>Selecting/Scoping Tests</li> <li>Coverage &amp; Quality Gates</li> <li>CI Pipeline</li> <li>Mutation &amp; Property-Based Testing</li> <li>Performance, Flakes, Determinism</li> <li>Contributing New Tests</li> <li>Quick Commands Cheat Sheet</li> <li>Links</li> </ul> <p>Back to top</p>"},{"location":"tests.html#testing-philosophy","title":"Testing Philosophy","text":"<p>We optimize for predictability, depth, and maintainability:</p> <ul> <li>Determinism \u2014 stable outputs, structured errors, fixed flag precedence.</li> <li>Layered depth \u2014 unit &gt; integration &gt; functional &gt; E2E, each with clear responsibility.</li> <li>Design pressure \u2014 tests encourage separation of concerns (DI-friendly services, pure serialization, thin CLIs).</li> <li>Speed where it matters \u2014 fast unit feedback; heavier scenarios gated under markers.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#suite-layout","title":"Suite Layout","text":"<p>Top-level structure under <code>tests/</code> (abridged):</p> <pre><code>tests/\n  unit/\n    commands/        # audit, config, dev, docs, doctor, help, history, memory, repl, sleep, status, utilities, version\n    core/            # context, di, engine, enums, exceptions\n    infra/           # emitter, observability, process, retry, serializer, telemetry\n    root/            # __init__, __main__, api, cli, httpapi\n    services/        # audit, config, docs, doctor, history, memory, plugins, utils\n  integration/\n  functional/\n  e2e/\n    api/ dev/ history/ plugins/ repl/ \u2026  # + fixtures\n</code></pre> <p>Shared fixtures live in <code>conftest.py</code> files at appropriate levels; E2E adds JSON/YAML shape fixtures for contract-like assertions.</p> <p>Back to top</p>"},{"location":"tests.html#test-types","title":"Test Types","text":""},{"location":"tests.html#unit","title":"Unit","text":"<p>Goal: Isolate behavior of a single module/service. Coverage highlights:</p> <ul> <li>Core: DI resolution/graphs, engine flow, exceptions/enums consistency.</li> <li>Infra: serializer (JSON/YAML, redaction), retry/backoff w/ jitter &amp; timeouts, observability/telemetry hooks, process management.</li> <li>Services: config/history/memory/plugins/docs/doctor/audit utils.</li> <li>Commands: validation, parsing, structured outputs.</li> </ul> <p>Depth patterns: parametrization; mocks for file I/O, telemetry, and timing; assertions on side-effects (e.g., history atomic writes, locks).</p> <p>Back to top</p>"},{"location":"tests.html#integration","title":"Integration","text":"<p>Goal: Verify wiring (service \u2194 contract \u2194 infra) through DI and orchestrations. Focus: realistic pipelines without the CLI wrapper; concurrency on shared resources (e.g., history locks); config propagation across layers.</p> <p>Back to top</p>"},{"location":"tests.html#functional","title":"Functional","text":"<p>Goal: Assert user-visible behavior of commands. Focus: global flag precedence (help/quiet/debug/format/pretty/verbose), structured stdout/stderr, exit codes, non-interactive REPL.</p> <p>Back to top</p>"},{"location":"tests.html#end-to-end-e2e","title":"End-to-End (E2E)","text":"<p>Goal: Exercise the installed CLI the way a user would. Scope: plugin lifecycle (scaffold/install/list/info/check/uninstall), REPL sessions, dev tools (DI graphs), API endpoints, performance paths (history). Technique: subprocess runs, fixture-driven shape checks (JSON/YAML), perf thresholds where relevant.</p> <p>Back to top</p>"},{"location":"tests.html#fixtures--data","title":"Fixtures &amp; Data","text":"<ul> <li>Global <code>conftest.py</code> manages temp dirs, env overrides, and deterministic clocks where needed.</li> <li>E2E shape fixtures (e.g., <code>di_shape.json</code>, <code>history_shape.yaml</code>) guard contract stability.</li> <li>Redaction helpers ensure secrets never leak in snapshot/shape comparisons.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#conventions--markers","title":"Conventions &amp; Markers","text":"<p>Naming: <code>test_*.py</code>, functions start with <code>test_</code>. Style: pytest idioms\u2014parametrize for matrix cases, minimal mocks, explicit side-effects. Markers:</p> <ul> <li><code>@pytest.mark.slow</code> \u2014 performance or network-heavy paths</li> <li><code>@pytest.mark.e2e</code> \u2014 full CLI/subprocess flows</li> <li><code>@pytest.mark.asyncio</code> \u2014 async units/integrations</li> </ul> <p>Keep tests hermetic: no external network unless explicitly marked, no reliance on machine state.</p> <p>Back to top</p>"},{"location":"tests.html#running-tests","title":"Running Tests","text":"<p>From a clean venv:</p> <pre><code># Everything (fastest path via Makefile orchestration)\nmake test\n\n# Plain pytest\npytest -q\n\n# Tox (multi-Python; mirrors CI)\ntox -q -p auto           # or: tox -e py311,py312,py313\n</code></pre> <p>Common extras:</p> <pre><code># With coverage report\npytest --cov=bijux_cli --cov-report=term-missing\n\n# Stop on first failure, short tracebacks\npytest -x --tb=short\n</code></pre> <p>Back to top</p>"},{"location":"tests.html#selectingscoping-tests","title":"Selecting/Scoping Tests","text":"<pre><code># Only unit\npytest tests/unit -q\n\n# Only E2E\npytest -m e2e -q\n\n# Exclude slow\npytest -m \"not slow\" -q\n\n# Keyword selection\npytest -k \"plugins and not uninstall\" -q\n</code></pre> <p>Back to top</p>"},{"location":"tests.html#coverage--quality-gates","title":"Coverage &amp; Quality Gates","text":"<ul> <li>Coverage target: \u2265 90% overall (critical modules higher).</li> <li>Docs &amp; style: <code>ruff</code> (lint+format), <code>pydocstyle</code>, <code>interrogate</code>.</li> <li>Typing: <code>mypy</code>, <code>pyright</code>, optional <code>pytype</code> passes for regressions.</li> <li>Security &amp; hygiene: <code>bandit</code>, <code>pip-audit</code>, <code>reuse</code>, <code>codespell</code>, <code>deptry</code>, <code>radon</code>.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#ci-pipeline","title":"CI Pipeline","text":"<p>GitHub Actions runs on pushes/PRs:</p> <ul> <li>Matrix: Python 3.11\u20133.13; Node 20 + Java 17 where API/Redoc/OpenAPI tooling is used.</li> <li>Stages: lint \u2192 type \u2192 unit/integration/functional \u2192 E2E \u2192 docs build \u2192 security.</li> <li>Gates: any failure blocks merge; artifacts include coverage and logs.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#mutation--property-based-testing","title":"Mutation &amp; Property-Based Testing","text":"<ul> <li>Mutation: Cosmic Ray &amp; mutmut validate assertion strength on critical paths (serializer, retry/backoff, config).</li> </ul> <p><pre><code>make mutation   # or: cosmic-ray run config/cosmic-ray.toml\n</code></pre> * Property-based: Hypothesis explores edge cases (e.g., serializer inputs, option matrices) beyond example-based tests.</p> <p>Back to top</p>"},{"location":"tests.html#performance-flakes-determinism","title":"Performance, Flakes, Determinism","text":"<ul> <li>Mark perf-sensitive tests as <code>slow</code>; assert upper bounds where meaningful.</li> <li>Avoid sleeps; mock clocks/backoffs (retry tests), or patch <code>asyncio.sleep</code>.</li> <li>No reliance on wall-clock randomness; seed where PRNG used.</li> <li>Flakes are failures\u2014quarantine with markers only until fixed.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#contributing-new-tests","title":"Contributing New Tests","text":"<ul> <li>Pick the right layer (unit vs integration vs E2E).</li> <li>Prefer parametrization over similar copy-pasted tests.</li> <li>Assert shapes &amp; side-effects (stdout/stderr, files, telemetry).</li> <li>Keep fixtures local unless they\u2019re broadly reusable.</li> <li>Don\u2019t hit the network or real home directories\u2014use tmp paths and env overrides.</li> <li>Add docs/examples if behavior is user-visible.</li> </ul> <p>Back to top</p>"},{"location":"tests.html#quick-commands-cheat-sheet","title":"Quick Commands Cheat Sheet","text":"<pre><code># Fast local loop\npytest tests/unit -q\n\n# Functional + E2E only\npytest -m \"functional or e2e\" -q\n\n# Coverage HTML\npytest --cov=bijux_cli --cov-report=html &amp;&amp; open htmlcov/index.html\n\n# Tox across Pythons\ntox -q -p auto\n\n# Lint+type before PR\nmake lint quality\n</code></pre> <p>Back to top</p>"},{"location":"tests.html#links","title":"Links","text":"<ul> <li>Tests directory: https://github.com/bijux/bijux-cli/tree/main/tests</li> <li>Issues / CI runs: https://github.com/bijux/bijux-cli/actions</li> </ul> <p>Back to top</p>"},{"location":"usage.html","title":"Bijux CLI \u2014 User Guide","text":"<p>A practical reference for installation, global flags, commands, configuration, and behavior. For project overview and motivation, see the README.</p>"},{"location":"usage.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Quick Start</li> <li>Shell Completion</li> <li>Global Flags - Precedence</li> <li>Command Reference</li> <li><code>config</code> \u2014 Settings</li> <li><code>plugins</code> \u2014 Plugin Management</li> <li><code>history</code> \u2014 REPL History</li> <li><code>dev</code> \u2014 Developer Tools</li> <li>Built-in Commands (Index)</li> <li>Advanced Usage Patterns</li> <li>Configuration</li> <li>End-to-End Workflows</li> <li>Core Workflow (no plugins)</li> <li>Plugin Workflow (requires a real template)</li> <li>Structured Error Model</li> <li>Exit Codes</li> <li>Troubleshooting &amp; FAQs</li> </ul> <p>Back to top</p>"},{"location":"usage.html#installation","title":"Installation","text":"<p>Requires Python 3.11+.</p>"},{"location":"usage.html#pipx-recommended-for-isolation","title":"pipx (recommended for isolation)","text":"<pre><code>pipx install bijux-cli\npipx ensurepath       # first-time pipx users\n# later\npipx upgrade bijux-cli\n</code></pre>"},{"location":"usage.html#pip","title":"pip","text":"<pre><code>python -m pip install -U bijux-cli\n</code></pre> <p>Tip: Use a virtual environment when installing with plain <code>pip</code>.</p> <p>Back to top</p>"},{"location":"usage.html#quick-start","title":"Quick Start","text":"<pre><code>bijux --help          # commands and global flags\nbijux --version       # version/sanity\nbijux doctor          # environment diagnostics\n\n# REPL\nbijux\nbijux&gt; help\nbijux&gt; status -f json   # {\"version\":\"&lt;current&gt;\", ...}\nbijux&gt; exit\n</code></pre> <p>Back to top</p>"},{"location":"usage.html#shell-completion","title":"Shell Completion","text":"<pre><code>bijux --install-completion   # install for your current shell\nbijux --show-completion      # print the script for manual setup\n</code></pre> <p>Shell notes:</p> <ul> <li>Bash (current session): <code>eval \"$(bijux --show-completion)\"</code></li> <li>Zsh (persistent): add to <code>~/.zshrc</code> <code>fpath+=(\"$HOME/.zfunc\")</code> and <code>autoload -U compinit &amp;&amp; compinit</code>   then run <code>bijux --install-completion</code>.</li> <li>Fish / PowerShell: run <code>--install-completion</code>.</li> </ul> <p>Restart your shell after installing. For Zsh, verify <code>compinit</code> runs and your <code>fpath</code> includes the completions directory.</p> <p>Back to top</p>"},{"location":"usage.html#global-flags-precedence","title":"Global Flags - Precedence","text":"<p>Flags are evaluated in strict order; higher priority short-circuits lower ones.</p> Priority Flag(s) Behavior 1 <code>-h</code>, <code>--help</code> Exit 0 with usage; ignore all other flags. 2 <code>-q</code>, <code>--quiet</code> Suppress stdout/stderr; exit code still reflects result. 3 <code>-d</code>, <code>--debug</code> Full diagnostics; implies <code>--verbose</code> and forces <code>--pretty</code>. 4 <code>-f</code>, <code>--format</code> <code>&lt;json\\|yaml&gt;</code> Structured output; invalid value \u2192 exit code 2 5 <code>--pretty</code> / <code>--no-pretty</code> Indentation control (default: <code>--pretty</code>). 6 <code>-v</code>, <code>--verbose</code> Include runtime metadata; implied by <code>--debug</code>. <p>Details: ADR-0002 (Global Flags Precedence).</p> <p>Warning: When <code>--format</code> is set, errors are emitted in that format to stderr (unless <code>--quiet</code>).</p> <p>Back to top</p>"},{"location":"usage.html#command-reference","title":"Command Reference","text":""},{"location":"usage.html#config--settings","title":"<code>config</code> \u2014 Settings","text":"<p>Dotenv-style key/value settings. Keys must be alphanumeric or underscore.</p> <ul> <li><code>list</code> \u2192 <code>{\"items\":[{\"key\":\"...\",\"value\":\"...\"}]}</code></li> </ul> <pre><code>bijux config list -f json --no-pretty\n</code></pre> <ul> <li><code>get &lt;key&gt;</code> \u2192 <code>{\"value\":\"...\"}</code></li> </ul> <pre><code>bijux config get core_timeout\n</code></pre> <ul> <li><code>set &lt;key=value&gt;</code> / <code>unset &lt;key&gt;</code></li> </ul> <pre><code>bijux config set core_timeout=30\nbijux config unset core_timeout\n</code></pre> <ul> <li><code>export &lt;path&gt;</code> (supports <code>-f json|yaml</code>)</li> </ul> <pre><code>bijux config export ./settings.env\nbijux config export ./settings.json -f json\n</code></pre> <ul> <li><code>load &lt;path&gt;</code> (dotenv), <code>reload</code>, <code>clear</code></li> </ul> <p>Tip: Use <code>-f json --no-pretty</code> for machine-readable output in scripts.</p> <p>Back to top</p>"},{"location":"usage.html#plugins--plugin-management","title":"<code>plugins</code> \u2014 Plugin Management","text":"<p>Default install dir: <code>~/.bijux/.plugins</code> (override via <code>BIJUXCLI_PLUGINS_DIR</code>).</p> <ul> <li><code>list</code> \u2192 <code>{\"plugins\":[\"...\", ...]}</code></li> </ul> <pre><code>bijux plugins list\n</code></pre> <ul> <li> <p><code>info &lt;name|path&gt;</code>, <code>check &lt;name|path&gt;</code>, <code>uninstall &lt;name&gt;</code></p> </li> <li> <p><code>install &lt;path&gt;</code> \u2014 install a plugin directory (use <code>--force</code> to overwrite)</p> </li> </ul> <pre><code>bijux plugins install ./path/to/my_plugin --force\n</code></pre> <ul> <li><code>scaffold &lt;name&gt; --template &lt;path-or-git-url&gt;</code> \u2014 create a plugin from a template</li> </ul> <pre><code># Requires a real template (local dir or cookiecutter-compatible Git URL)\nbijux plugins scaffold my_plugin --template ./templates/bijux-plugin --force\n# or\nbijux plugins scaffold my_plugin --template https://example.com/your/bijux-plugin-template.git --force\n</code></pre> <p>Important: <code>scaffold</code> requires <code>--template</code>. Without it you'll get <code>no_template</code>. Warning: <code>--force</code> overwrites files in the destination.</p> <p>Back to top</p>"},{"location":"usage.html#history--repl-history","title":"<code>history</code> \u2014 REPL History","text":"<ul> <li><code>list</code> (supports <code>--limit</code>, <code>--group-by</code>, <code>--filter</code>, <code>--sort</code>) \u2192 <code>{\"entries\":[...]}</code></li> </ul> <pre><code>bijux history --limit 10 -f json --no-pretty\n</code></pre> <ul> <li><code>--export &lt;path&gt;</code>, <code>--import &lt;path&gt;</code>, <code>clear</code></li> </ul> <p>Back to top</p>"},{"location":"usage.html#dev--developer-tools","title":"<code>dev</code> \u2014 Developer Tools","text":"<ul> <li><code>di</code> \u2192 <code>{\"factories\":[...],\"services\":[...]}</code></li> </ul> <pre><code>bijux dev di -f json\n</code></pre> <ul> <li><code>list-plugins</code> \u2014 diagnostic list of discovered plugins</li> </ul> <p>Back to top</p>"},{"location":"usage.html#built-in-commands-index","title":"Built-in Commands (Index)","text":"Command Purpose Example (sample output) <code>audit</code> Security/compliance checks <code>bijux audit --dry-run</code> \u2192 <code>{\"issues\":[...]}</code> <code>docs</code> Generate specs/docs <code>bijux docs --out spec.json</code> \u2192 writes file <code>doctor</code> Health diagnostics <code>bijux doctor</code> \u2192 summary or detailed findings <code>memory</code> Key-value store <code>bijux memory set key=val</code> \u2192 <code>{\"status\":\"set\"}</code> <code>repl</code> Interactive shell <code>bijux repl</code> \u2192 interactive <code>bijux&gt;</code> prompt <code>sleep</code> Pause execution <code>bijux sleep -s 5</code> \u2192 pauses for 5 seconds <code>status</code> CLI status snapshot <code>bijux status -f json</code> \u2192 <code>{\"version\":\"&lt;current&gt;\", ...}</code> <code>version</code> Version info <code>bijux version</code> \u2192 <code>&lt;current&gt;</code> <p>Plugins appear as additional top-level commands after install.</p> <p>Back to top</p>"},{"location":"usage.html#advanced-usage-patterns","title":"Advanced Usage Patterns","text":"<ul> <li>Batch config apply:</li> </ul> <pre><code>bijux config set core_timeout=30 &amp;&amp; bijux config reload\n</code></pre> <ul> <li>Check all installed plugins:</li> </ul> <pre><code>bijux plugins list -f json --no-pretty \\\n  | jq -r '.plugins[]' \\\n  | xargs -I {} bijux plugins check {}\n</code></pre> <ul> <li>Diagnostics pipeline:</li> </ul> <pre><code>bijux doctor --debug &gt; diag.log\nbijux status -d &gt;&gt; diag.log\n</code></pre> <p>Tip: Combine with <code>--quiet</code> in CI to suppress output while preserving exit codes.</p> <p>Back to top</p>"},{"location":"usage.html#configuration","title":"Configuration","text":"<p>Default paths (overridable via environment variables):</p> <ul> <li>Config file: <code>~/.bijux/.env</code> (<code>BIJUXCLI_CONFIG</code>)</li> <li>History file: <code>~/.bijux/.history</code> (<code>BIJUXCLI_HISTORY_FILE</code>)</li> <li>Plugins dir: <code>~/.bijux/.plugins</code> (<code>BIJUXCLI_PLUGINS_DIR</code>)</li> </ul> <p>Example override (shell profile):</p> <pre><code>export BIJUXCLI_PLUGINS_DIR=./plugins\n</code></pre> <p>Resolution precedence: 1) CLI flags \u2192 2) Environment variables \u2192 3) Config file \u2192 4) Defaults</p> <p>Back to top</p>"},{"location":"usage.html#end-to-end-workflows","title":"End-to-End Workflows","text":""},{"location":"usage.html#core-workflow-no-plugins","title":"Core Workflow (no plugins)","text":"<p>This flow works on any install; it does not assume a template or extra files.</p> <pre><code># Fresh artifacts directory\nrm -rf artifacts &amp;&amp; mkdir -p artifacts\n\n# Version and health\nbijux --version\nbijux doctor\n\n# Config operations\nbijux config set core_timeout=30\nbijux config get core_timeout                 # {\"value\":\"30\"}\nbijux config list -f json --no-pretty &gt; artifacts/config.json\nbijux config export artifacts/settings.env\nbijux config export artifacts/settings.json -f json\n\n# REPL creates history\nbijux repl &lt;&lt;'EOF'\nversion\nhelp\nexit\nEOF\n\n# History operations\nbijux history --limit 5 -f json --no-pretty &gt; artifacts/history.json\nbijux history --export artifacts/history-full.json\nbijux history --import artifacts/history-full.json\n\n# Cleanup\nbijux history clear\nbijux config clear\n</code></pre>"},{"location":"usage.html#plugin-workflow-requires-a-real-template","title":"Plugin Workflow (requires a real template)","text":"<p>Choose one of the following:</p> <ul> <li>A) Local template directory you maintain (e.g., <code>./templates/bijux-plugin</code>)</li> <li>B) Cookiecutter-compatible Git URL (e.g., your organization\u2019s plugin template repo)</li> </ul> <pre><code># Start clean\nbijux plugins uninstall my_plugin || true\nrm -rf tmp &amp;&amp; mkdir -p tmp\n\n# Scaffold (requires a real template path or Git URL)\n# Option A: local template directory\nbijux plugins scaffold my_plugin --template ./templates/bijux-plugin --force\n\n# Option B: cookiecutter-compatible Git URL\n# bijux plugins scaffold my_plugin --template https://example.com/your/bijux-plugin-template.git --force\n\n# Install the newly scaffolded plugin\nbijux plugins install ./my_plugin --force\n\n# Verify &amp; validate\nbijux plugins list                     # {\"plugins\":[\"my_plugin\", ...]}\nbijux plugins info my_plugin\nbijux plugins check my_plugin\n\n# Uninstall when done\nbijux plugins uninstall my_plugin || true\n</code></pre> <p>If you do not provide a real template, <code>scaffold</code> will fail with <code>no_template</code>, and subsequent <code>install/info/check</code> commands will also fail.</p> <p>Back to top</p>"},{"location":"usage.html#structured-error-model","title":"Structured Error Model","text":"<p>With <code>--format</code>, errors are structured and written to stderr (unless <code>--quiet</code>):</p> <pre><code>{\n  \"error\": \"message\",\n  \"code\": 2,\n  \"failure\": \"machine_readable_reason\",\n  \"command\": \"subcommand path\",\n  \"fmt\": \"json\"\n}\n</code></pre> <p>The YAML form is emitted when <code>-f yaml</code> is used.</p> <p>Back to top</p>"},{"location":"usage.html#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 General/internal error 2 Usage/invalid argument 3 Encoding/hygiene error <p>Commands may define additional non-conflicting codes.</p> <p>Back to top</p>"},{"location":"usage.html#troubleshooting-faqs","title":"Troubleshooting &amp; FAQs","text":"<ul> <li>Start with <code>bijux doctor</code>.</li> <li>Need more detail? Use <code>--verbose</code> or <code>--debug</code> (adds pretty printing and diagnostics).</li> <li>Scripting? Prefer <code>-f json --no-pretty</code> and read from stdout; errors go to stderr.</li> <li>Completion not working? Re-run <code>--install-completion</code> and restart the shell; ensure Zsh <code>compinit</code> and <code>fpath</code> are correct.</li> <li>Permission denied? Ensure paths are writable; avoid <code>sudo</code> unless absolutely required.</li> <li> <p>Plugin errors?</p> </li> <li> <p><code>no_template</code>: you must pass a real <code>--template</code> (path or Git URL) to <code>plugins scaffold</code>.</p> </li> <li><code>not_found</code> / <code>not_installed</code>: confirm plugin name; check <code>bijux plugins list</code>.</li> <li>Use <code>bijux plugins check &lt;name&gt;</code> after installing.</li> <li>Bug reports: include <code>--debug</code> output, version (<code>bijux --version</code>), OS, and repro steps.</li> </ul> <p>Back to top</p>"},{"location":"ADR/index.html","title":"Architecture Decision Records Overview","text":"<p>This section lists all ADRs.</p>"},{"location":"ADR/index.html#adrs","title":"ADRs","text":"<ul> <li>ADR 0002: Global Flags Precedence</li> <li>ADR 0003: Docstring And Documentation Style</li> <li>ADR 0004: Linting Quality Security</li> </ul>"},{"location":"ADR/0002-global-flags-precedence.html","title":"ADR 0002: Global Flag Precedence Contract","text":"<ul> <li>Date: 2025\u201108\u201101</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0002-global-flags-precedence.html#context","title":"Context","text":"<p>Our Bijux CLI requires a deterministic and testable handling of global flags (<code>--help</code>, <code>--quiet</code>, <code>--debug</code>, <code>--format</code>, <code>--pretty</code>/<code>--no-pretty</code>, <code>--verbose</code>) across all commands to ensure consistency. This prevents ambiguous behaviors in hypothesis-driven fuzz tests, provides a clear \"short-circuit\" model for scripting and human users, and maintains synchronization between documentation, ADRs, and implementations. Without a formal contract, variations in flag-resolution rules could lead to edge cases and debugging challenges.</p>"},{"location":"ADR/0002-global-flags-precedence.html#decision","title":"Decision","text":"<p>All Bijux CLI commands must enforce global flags in the following strict precedence order, with exact semantics applied uniformly:</p> <ol> <li>Help (<code>-h</code> / <code>--help</code>)</li> <li>Short-circuits all other processing.</li> <li>Immediately prints usage information and exits with code 0.</li> <li> <p>Skips validation or processing of any other flags or arguments.</p> </li> <li> <p>Quiet (<code>-q</code> / <code>--quiet</code>)</p> </li> <li>Applies only if help is absent.</li> <li>Suppresses all normal output on stdout and stderr.</li> <li>Still performs full validation of flags and arguments, exiting with 0 on success or non-zero on errors.</li> <li> <p>Overrides debug, format, pretty/no-pretty, and verbose for output suppression, but not for exit codes.</p> </li> <li> <p>Debug (<code>--debug</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Emits diagnostics and full trace information to stderr.</li> <li>Implicitly enables verbose output (e.g., runtime metadata).</li> <li> <p>Forces <code>--pretty</code> formatting, overriding any <code>--no-pretty</code>.</p> </li> <li> <p>Format (<code>-f &lt;fmt&gt;</code> / <code>--format &lt;fmt&gt;</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Requires a valid format name (<code>json</code> or <code>yaml</code>, case-insensitive).</li> <li> <p>Invalid or missing value triggers a structured error payload and exit code 2.</p> </li> <li> <p>Pretty / No-Pretty (<code>--pretty</code> / <code>--no-pretty</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Controls indentation for human-readable structured output.</li> <li>Defaults to <code>--pretty</code> if neither is specified.</li> <li> <p>Overridden by debug, which always enforces pretty formatting.</p> </li> <li> <p>Verbose (<code>-v</code> / <code>--verbose</code>)</p> </li> <li>Applies only if neither help nor quiet is present.</li> <li>Appends runtime metadata (e.g., Python version, platform) to structured output.</li> <li>No-op under quiet; implied by debug.</li> </ol>"},{"location":"ADR/0002-global-flags-precedence.html#error-handling-rules","title":"Error-Handling Rules","text":"<ul> <li>Under help, always exit 0 with usage displayed, ignoring any invalid flags or arguments.</li> <li>Under quiet, suppress both stdout and stderr and return only an exit code (no JSON/YAML payload).</li> <li>Standard exit codes apply otherwise:</li> <li><code>0</code>: Success</li> <li><code>1</code>: Internal/fatal errors</li> <li><code>2</code>: Bad CLI usage (missing/invalid flags or arguments)</li> <li><code>3</code>: ASCII/encoding hygiene failures</li> <li>Every error payload (JSON or YAML) must include:</li> <li><code>\"error\"</code>: Human-readable message</li> <li><code>\"code\"</code>: Numeric exit code</li> </ul>"},{"location":"ADR/0002-global-flags-precedence.html#consequences","title":"Consequences","text":""},{"location":"ADR/0002-global-flags-precedence.html#pros","title":"Pros","text":"<ul> <li>Ensures deterministic behavior, eliminating flakiness in fuzz tests and user interactions.</li> <li>Provides a single source of truth for flag handling, simplifying documentation and maintenance.</li> <li>Enhances testability by allowing assertions on specific argv patterns (e.g., <code>-h</code> always yields usage and exit 0).</li> </ul>"},{"location":"ADR/0002-global-flags-precedence.html#cons","title":"Cons","text":"<ul> <li>Requires each command's entrypoint to inspect <code>sys.argv</code> (or Typer/Click context) before parsing, adding initial implementation overhead.</li> <li>Contributors unfamiliar with the precedence must adapt, with no flexibility for command-specific variations.</li> </ul>"},{"location":"ADR/0002-global-flags-precedence.html#enforcement","title":"Enforcement","text":"<ul> <li>No command implementation or pull request is accepted unless it fully adheres to this precedence contract.</li> <li>CI pipelines and reviewers must verify compliance through tests, rejecting any deviations in flag handling or semantics.</li> <li>This policy is binding and non-negotiable to maintain CLI consistency.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html","title":"ADR 0003: Docstring and Documentation Style","text":"<ul> <li>Date: 2025\u201108\u201101</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html#context","title":"Context","text":"<p>Our codebase demands a rigorously consistent and machine-parsable documentation style to facilitate the seamless, automated generation of comprehensive and visually appealing webpages through MkDocs. This process depends entirely on full, detailed docstrings placed at the top of every Python file, which must thoroughly explain the complete contents of that file. User-facing documentation\u2014encompassing guides, ADRs, and READMEs\u2014must remain highly readable in plain text while rendering flawlessly on the web. By utilizing tools like MkDocs for rendering and linters for validation, we enable all contributors to produce and sustain uniformly high-quality documentation, with absolutely no exceptions permitted.</p>"},{"location":"ADR/0003-docstring-and-documentation-style.html#decision","title":"Decision","text":""},{"location":"ADR/0003-docstring-and-documentation-style.html#docstrings","title":"Docstrings","text":"<p>We enforce the exclusive use of the Google Python Style Guide for all in-code docstrings throughout the codebase, prohibiting any deviations or mixed styles to guarantee absolute unification and automated enforcement.</p> <ul> <li>Every Python file must commence with a comprehensive module-level docstring enclosed in triple quotes <code>\"\"\"\u2026\"\"\"</code>, beginning with a concise one-sentence summary on the initial line.</li> <li>After the summary, insert a blank line followed by an exhaustive description of the file's entire code, covering its overall purpose, architectural structure, primary components, interdependencies, and pertinent usage guidelines. This docstring must be fully self-explanatory, eschewing abbreviated or partial content.</li> <li> <p>Include the following sections in precise order, omitting only those that are wholly inapplicable:</p> <ol> <li>Args: <pre><code> Args:\n     name (str): Description of the argument.\n     count (int): Description of the argument.\n</code></pre></li> <li>Returns: <pre><code>Returns:\n    bool: Description of the return value.\n</code></pre></li> <li>Raises: <pre><code>Raises:\n    ValueError: Description of when and why the exception is raised.\n</code></pre></li> </ol> </li> <li> <p>In docstrings, employ <code>*</code> exclusively for any bullet points or lists (such as in descriptions or output contracts) to ensure proper line-separated display in MkDocs-generated webpages. Example:   <pre><code>Output Contract:\n    * Success: {\"version\": str, \"timestamp\": float}\n    * Verbose: {\"python\": str, \"platform\": str}\n    * Error: {\"error\": str, \"code\": int}\n</code></pre></p> </li> <li>Avoid <code>-</code> or alternative markers that could lead to rendering inconsistencies.</li> <li>Extend full Google-style docstrings to every class, function, and method, with each providing a thorough account of its functionality and integration within the file.</li> <li>Prohibit the use of <code>&lt;module&gt;</code>, <code>:param:</code>, reST directives, or any non-Google elements\u2014strict adherence to Google format is required.</li> <li>Mandate enforcement through tools like <code>pydocstyle</code> set to the \"google\" convention, embedded in CI/CD workflows to automatically block non-conforming submissions.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html#repository-documentation","title":"Repository Documentation","text":"<ul> <li>Store all ADRs in <code>docs/ADR/</code> with filenames formatted as <code>XXXX-&lt;short-title&gt;.md</code>, where <code>XXXX</code> represents a zero-padded integer.</li> <li>Restrict all repository documentation (ADRs, READMEs, guides) to Markdown format only.</li> <li>Prefer <code>*</code> for Markdown bullet points. <code>-</code> is also acceptable to match GitHub/MkDocs defaults.</li> <li>Mandate inclusion of Date, Status, and Author headers in ADRs, as exemplified in this document.</li> <li>Set up MkDocs to draw from <code>docs/</code> as the primary source directory for automated website publication.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html#consequences","title":"Consequences","text":""},{"location":"ADR/0003-docstring-and-documentation-style.html#pros","title":"Pros","text":"<ul> <li>Delivers a uniformly professional codebase with reliable introspection and automated API reference generation.</li> <li>Ensures out-of-the-box compatibility with tools like MkDocs for superior documentation websites.</li> <li>Provides contributors with unambiguous, enforceable guidelines, streamlining reviews through automation and objectivity.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html#cons","title":"Cons","text":"<ul> <li>Incurs upfront costs for refactoring existing non-compliant files.</li> <li>Necessitates adaptation for contributors unaccustomed to Google style or rigorous linting protocols.</li> </ul>"},{"location":"ADR/0003-docstring-and-documentation-style.html#enforcement","title":"Enforcement","text":"<ul> <li>Prohibit acceptance of any code or documentation pull request that fails to comply fully with this ADR.</li> <li>Empower reviewers and CI systems to reject submissions outright for issues such as absent module-level docstrings, incomplete explanations, stylistic inconsistencies, or improper bullet formatting.</li> <li>Establish this policy as irrevocably binding, with no provisions for negotiation or exceptions.</li> </ul>"},{"location":"ADR/0004-linting-quality-security.html","title":"ADR 0004: Linting, Quality, and Security Toolchain","text":"<ul> <li>Date: 2025-08-01</li> <li>Status: Accepted</li> <li>Author: Bijan Mousavi</li> </ul>"},{"location":"ADR/0004-linting-quality-security.html#context","title":"Context","text":"<p>We need a single, reproducible pipeline for code style, formatting, type-safety, complexity, documentation coverage, dead code, dependency hygiene, license compliance, and security checks \u2014 identical locally and in CI. Developers should be able to run:</p> <pre><code>make lint\nmake quality\nmake security\n</code></pre> <p>and get the same results everywhere.</p> <p>We standardized on the following tools:</p> <ul> <li>Ruff for formatting, import sorting, and linting (with auto-fix where safe).</li> <li>Mypy and Pytype for static typing (Pytype runs where supported).</li> <li>Pyright for fast type checks (editor/CI parity).</li> <li>Pydocstyle (Google convention) for docstring style.</li> <li>Interrogate for documentation coverage.</li> <li>Radon for cyclomatic complexity.</li> <li>Vulture for dead code detection.</li> <li>Deptry for unused/incorrect dependencies.</li> <li>REUSE for SPDX license header compliance.</li> <li>Bandit for security static analysis.</li> <li>pip-audit for dependency vulnerability audits.</li> </ul> <p>All configuration lives under <code>config/</code> (with a few root files like <code>REUSE.toml</code>), ensuring CI/local parity.</p>"},{"location":"ADR/0004-linting-quality-security.html#decision","title":"Decision","text":""},{"location":"ADR/0004-linting-quality-security.html#makefile-targets","title":"Makefile Targets","text":"<p>We enforce Makefile targets to run the full toolchain consistently.</p> Lint (<code>Makefile</code>) <pre><code># Lint Configuration\n\nRUFF        := $(ACT)/ruff\nMYPY        := $(ACT)/mypy\nPYTYPE      := $(ACT)/pytype\nCODESPELL   := $(ACT)/codespell\nPYRIGHT     := $(ACT)/pyright\nPYDOCSTYLE  := $(ACT)/pydocstyle\nRADON       := $(ACT)/radon\n\n.PHONY: lint lint-file lint-dir\n\nlint:\n    @echo \"\u2192 Running all linting checks\"\n    @$(MAKE) lint-dir dir=src/bijux_cli\n    @$(MAKE) lint-dir dir=tests\n    @echo \"\u2714 Linting completed successfully\"\n\nlint-file:\nifndef file\n    $(error Usage: make lint-file file=path/to/file.py)\nendif\n    @$(call run_tool,RuffFormat,$(RUFF) format)\n    @$(call run_tool,Ruff,$(RUFF) check --fix --config config/ruff.toml)\n    @$(call run_tool,Mypy,$(MYPY) --config-file config/mypy.ini --strict)\n    @$(call run_tool,Codespell,$(CODESPELL) -I config/bijux.dic)\n    @$(call run_tool,Pyright,$(PYRIGHT) --project config/pyrightconfig.json)\n    @$(call run_tool,Radon,$(RADON) cc -s -a)\n    @$(call run_tool,Pydocstyle,$(PYDOCSTYLE) --convention=google)\n\nlint-dir:\nifndef dir\n    $(error Usage: make lint-dir dir=&lt;directory_path&gt;)\nendif\n    @echo \"=== Linting directory '$(dir)' ===\"\n    @for file in $$(find $(dir) -type f -name '*.py'); do \\\n        $(MAKE) lint-file file=$$file; \\\n    done\n    @if $(VENV_PYTHON) -c 'import sys; sys.exit(0) if sys.version_info &gt;= (3, 13) else sys.exit(1)'; then \\\n        echo \"\u2192 Skipping Pytype (unsupported on Python &gt; 3.12)\"; \\\n    else \\\n        $(call run_tool,Pytype,$(PYTYPE) --disable import-error); \\\n    fi\n\n##@ Lint\nlint: ## Run all lint checks (ruff, mypy, pyright, codespell, radon, pydocstyle)\nlint-file: ## Lint a single Python file (requires file=&lt;path&gt;)\nlint-dir: ## Lint all Python files in a directory (requires dir=&lt;path&gt;)\n</code></pre> Quality (<code>Makefile</code>) <pre><code># Quality Configuration\n\nINTERROGATE_PATHS ?= src/bijux_cli\nQUALITY_PATHS     ?= src/bijux_cli\n\nVULTURE     := $(ACT)/vulture\nDEPTRY      := $(ACT)/deptry\nREUSE       := $(ACT)/reuse\nINTERROGATE := $(ACT)/interrogate\nPYTHON      := $(shell command -v python3 || command -v python)\n\nifeq ($(shell uname -s),Darwin)\n  BREW_PREFIX := $(shell command -v brew &gt;/dev/null 2&gt;&amp;1 &amp;&amp; brew --prefix)\n  CAIRO_PREFIX := $(shell test -n \"$(BREW_PREFIX)\" &amp;&amp; brew --prefix cairo)\n  QUALITY_ENV := DYLD_FALLBACK_LIBRARY_PATH=\"$(BREW_PREFIX)/lib:$(CAIRO_PREFIX)/lib:$$DYLD_FALLBACK_LIBRARY_PATH\"\nelse\n  QUALITY_ENV :=\nendif\n\n.PHONY: quality interrogate-report\n\nquality:\n    @echo \"\u2192 Running quality checks...\"\n    @echo \"   - Dead code analysis (Vulture)\"\n    @$(VULTURE) $(QUALITY_PATHS) --min-confidence 80\n    @echo \"   - Dependency hygiene (Deptry)\"\n    @$(DEPTRY) $(QUALITY_PATHS)\n    @echo \"   - License &amp; SPDX compliance (REUSE)\"\n    @$(REUSE) lint\n    @echo \"   - Documentation coverage (Interrogate)\"\n    @$(MAKE) interrogate-report\n    @echo \"\u2714 Quality checks passed\"\n\ninterrogate-report:\n    @echo \"\u2192 Generating docstring coverage report (&lt;100%)\"\n    @set +e; \\\n      OUT=\"$$( $(QUALITY_ENV) $(INTERROGATE) --verbose $(INTERROGATE_PATHS) )\"; \\\n      rc=$$?; \\\n      OFF=\"$$(printf '%s\\n' \"$$OUT\" | awk -F'|' 'NR&gt;3 &amp;&amp; $$0 ~ /^\\|/ { \\\n        name=$$2; cov=$$6; gsub(/^[ \\t]+|[ \\t]+$$/, \"\", name); gsub(/^[ \\t]+|[ \\t]+$$/, \"\", cov); \\\n        if (name !~ /^-+$$/ &amp;&amp; cov != \"100%\") printf(\"  - %s (%s)\\n\", name, cov); \\\n      }')\"; \\\n      if [ -n \"$$OFF\" ]; then printf \"%s\\n\" \"$$OFF\"; else echo \"\u2714 All files 100% documented\"; fi; \\\n      exit $$rc\n\n##@ Quality\nquality: ## Run all quality checks: Vulture (dead code), Deptry (deps), REUSE (SPDX), Interrogate (docs)\ninterrogate-report: ## Generate docstring coverage report for files &lt;100%\n</code></pre> Security (<code>Makefile</code>) <pre><code># Security Configuration\n\nSECURITY_PATHS   ?= src/bijux_cli\nBANDIT           := $(ACT)/bandit\nPIP_AUDIT        := $(ACT)/pip-audit\nSBOM_IGNORE      ?= PYSEC-2022-42969\n\n.PHONY: security\n\nsecurity:\n    @echo \"\u2192 Bandit (Python static analysis)\" &amp;&amp; $(BANDIT) -r $(SECURITY_PATHS)\n    @echo \"\u2192 Pip-audit (dependency vulnerability scan)\" &amp;&amp; \\\n      $(PIP_AUDIT) $(foreach V,$(SBOM_IGNORE),--ignore-vuln $(V))\n\n##@ Security\nsecurity: ## Run Bandit and pip-audit with optional vulnerability ignores\n</code></pre> <p>This setup supports whole-project runs as well as per-directory/per-file runs, with reasonable exclusions for generated or template content.</p>"},{"location":"ADR/0004-linting-quality-security.html#tool-configurations","title":"Tool Configurations","text":"<p>The toolchain is driven by unified configs:</p> Ruff (<code>config/ruff.toml</code>) <pre><code>target-version = \"py311\"\nline-length = 88\nrespect-gitignore = true\nsrc = [\"src\", \"tests\"]\n\nexclude = [\n  \".git\", \".hg\", \".mypy_cache\", \".pytest_cache\", \".ruff_cache\", \".tox\", \".venv\",\n  \"build\", \"dist\", \"docs\", \"htmlcov\", \"__pycache__\", \"migrations\", \"*.egg-info\"\n]\n\n[lint]\nselect = [\n  \"E\",\"F\",\"I\",\"B\",\"UP\",\"SIM\",\"PT\",\"N\",\"A\",\"C4\",\"S\",\"TID\",\"PERF\",\n  # \"RUF\",\"ARG\",\"TRY\",\"T20\",\"BLE\",\"ERA\"\n]\nignore = [\"E501\", \"E203\"]\n\n[lint.per-file-ignores]\n\"tests/**\" = [\"S101\"]\n\"__init__.py\" = [\"F401\"]\n\n[lint.isort]\nforce-sort-within-sections = true\nknown-first-party = [\"bijux_cli\"]\nrequired-imports = [\"from __future__ import annotations\"]\n\n[lint.flake8-tidy-imports]\nban-relative-imports = \"parents\"\n\n[lint.mccabe]\nmax-complexity = 10\n</code></pre> Mypy (<code>config/mypy.ini</code>) <pre><code>[mypy]\npython_version = 3.11\nstrict = true\n\nshow_error_codes = true\npretty = true\nwarn_unreachable = true\nwarn_unused_configs = true\nwarn_unused_ignores = true\nfollow_imports = silent\n\nmypy_path = src\nfiles = src, tests\n\nexclude = ^(\\.venv|build|dist|docs|htmlcov|\\.mypy_cache|\\.pytest_cache|\\.ruff_cache|\\.tox|__pycache__|migrations|\\.egg-info|node_modules)/\n\nplugins = pydantic.mypy\n\n[mypy-cookiecutter.*]\nignore_missing_imports = true\n\n[mypy-bijux_cli.core.di]\ndisable_error_code = type-abstract\n\n[pydantic-mypy]\ninit_typed = true\nwarn_required_dynamic_aliases = true\nwarn_untyped_fields = true\n</code></pre> Pyright (<code>config/pyrightconfig.json</code>) <pre><code>{\n  \"include\": [\n    \"src\",\n    \"tests\"\n  ],\n  \"exclude\": [\n    \".venv\",\n    \"build\",\n    \"dist\",\n    \"htmlcov\",\n    \".pytest_cache\",\n    \".mypy_cache\",\n    \".pytype\",\n    \".ruff_cache\",\n    \".tox\",\n    \"**/__pycache__\",\n    \"node_modules\"\n  ],\n  \"pythonVersion\": \"3.11\",\n  \"typeCheckingMode\": \"strict\",\n  \"useLibraryCodeForTypes\": true,\n  \"reportMissingImports\": \"warning\",\n  \"reportMissingTypeStubs\": \"none\",\n  \"reportUnusedImport\": \"error\",\n  \"reportPrivateUsage\": \"warning\",\n  \"reportUnnecessaryTypeIgnoreComment\": \"warning\",\n  \"reportUnnecessaryCast\": \"warning\",\n  \"reportUnnecessaryIsInstance\": \"warning\",\n  \"reportOptionalSubscript\": \"error\",\n  \"reportOptionalMemberAccess\": \"error\",\n  \"reportOptionalCall\": \"error\",\n  \"reportOptionalIterable\": \"error\",\n  \"reportOptionalContextManager\": \"error\",\n  \"reportOptionalOperand\": \"error\",\n  \"reportGeneralTypeIssues\": \"error\",\n  \"reportUntypedClassDecorator\": \"error\",\n  \"reportIncompatibleMethodOverride\": \"error\",\n  \"reportUnknownVariableType\": \"none\",\n  \"reportUnknownParameterType\": \"none\",\n  \"reportUntypedFunctionDecorator\": \"none\",\n  \"reportUnknownMemberType\": \"none\",\n  \"reportUnknownArgumentType\": \"none\",\n  \"reportUnknownLambdaType\": \"none\",\n  \"reportUnusedVariable\": \"information\",\n  \"executionEnvironments\": [\n    {\n      \"root\": \".\",\n      \"extraPaths\": [\n        \"src\"\n      ]\n    }\n  ]\n}\n</code></pre> Deptry (<code>pyproject.toml</code>) <pre><code>[tool.deptry]\nignore = [\"DEP002\", \"DEP003\"]\n</code></pre> Interrogate (<code>pyproject.toml</code>) <pre><code>[tool.interrogate]\nfail-under = 98\nexclude = [\"src/bijux_cli/core/di.py\"]\ncolor = true\n</code></pre> REUSE (<code>REUSE.toml</code>) <pre><code>version = 1\n\n# Config/docs/assets: public domain\n[[annotations]]\npath = [\n  \"**/*.png\", \"**/*.svg\", \"**/*.ico\", \"**/*.gif\", \"**/*.jpg\", \"**/*.jpeg\",\n  \"**/*.html\", \"**/*.toml\", \"**/*.ini\", \"**/*.cfg\", \"**/*.conf\",\n  \"**/*.env\", \"**/*.env.*\", \"**/*.yaml\", \"**/*.yml\", \"**/*.json\",\n  \"**/*.cff\", \"**/*.dic\", \".coverage*\", \".gitattributes\", \".gitignore\",\n  \"changelog.d/**\", \"**/.editorconfig\", \"artifacts/**\", \"scripts/git-hooks/**\"\n]\nprecedence = \"override\"\nSPDX-License-Identifier = \"CC0-1.0\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Templates: public domain\n[[annotations]]\npath = [\"plugin_template/**\"]\nprecedence = \"override\"\nSPDX-License-Identifier = \"CC0-1.0\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Code: MIT\n[[annotations]]\npath = [\"**/*.py\", \"**/*.pyi\", \"**/*.sh\", \"**/*.mk\", \"Makefile\", \"Dockerfile\", \"Dockerfile.*\"]\nprecedence = \"closest\"\nSPDX-License-Identifier = \"MIT\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n\n# Markdown docs: MIT\n[[annotations]]\npath = [\"**/*.md\"]\nprecedence = \"closest\"\nSPDX-License-Identifier = \"MIT\"\nSPDX-FileCopyrightText = \"\u00a9 2025 Bijan Mousavi\"\n</code></pre> <p>Docstring Style Enforcement We mandate Google-style docstrings via Pydocstyle (enforced in Makefile):</p> <pre><code>pydocstyle --convention=google path/to/file.py\n</code></pre> <p>Interrogate enforces documentation coverage thresholds as configured.</p>"},{"location":"ADR/0004-linting-quality-security.html#ci-integration","title":"CI Integration","text":"<ul> <li><code>make lint</code> runs over <code>src/</code> and <code>tests/</code>.</li> <li><code>make quality</code> and <code>make security</code> run project-wide.</li> <li>Any failure blocks the build; no overrides.</li> </ul>"},{"location":"ADR/0004-linting-quality-security.html#consequences","title":"Consequences","text":""},{"location":"ADR/0004-linting-quality-security.html#pros","title":"Pros","text":"<ul> <li>Uniform enforcement across the repo; no drift.</li> <li>One tool (Ruff) handles formatting, import sorting, and linting with fast auto-fixes.</li> <li>Strong typing via Mypy, Pytype (where supported), and Pyright.</li> <li>Doc style &amp; coverage enforced via Pydocstyle + Interrogate.</li> <li>Maintainability boosted by Vulture (dead code), Deptry (deps), Radon (complexity).</li> <li>SPDX compliance via REUSE.</li> <li>Security posture improved through Bandit + pip-audit.</li> <li>All configs centralized under <code>config/</code>, ensuring local/CI parity.</li> </ul>"},{"location":"ADR/0004-linting-quality-security.html#cons","title":"Cons","text":"<ul> <li>Initial setup and periodic rule maintenance.</li> <li>Contributors must align with strict rules and workflow.</li> </ul>"},{"location":"ADR/0004-linting-quality-security.html#enforcement","title":"Enforcement","text":"<ul> <li>Code is accepted only if it passes all configured targets and checks in this ADR.</li> <li>Reviewers &amp; CI must reject non-compliant changes (lint, quality, security, or config deviations).</li> <li>This policy is binding to preserve the integrity of the toolchain.</li> </ul>"},{"location":"reference/index.html","title":"Reference Index","text":"<ul> <li>Api Module</li> <li>Cli Module</li> <li>Httpapi Module</li> </ul>"},{"location":"reference/api.html","title":"Api Module API Reference","text":"<p>This section documents the internals of the <code>api</code> module in Bijux CLI. </p>"},{"location":"reference/api.html#bijux_cli.api","title":"bijux_cli.api","text":"<p>Provides a high-level, synchronous facade for the Bijux CLI's core engine.</p> <p>This module defines the <code>BijuxAPI</code> class, which serves as the primary public interface for programmatic interaction with the CLI. It wraps the asynchronous core <code>Engine</code> and other services to present a stable, thread-safe, and synchronous API.</p> <p>This facade is intended for use in integrations, testing, or any scenario where the CLI's command and plugin management logic needs to be embedded within another Python application.</p>"},{"location":"reference/api.html#bijux_cli.api.BijuxAPI","title":"BijuxAPI","text":"<pre><code>BijuxAPI(*, debug: bool = False)\n</code></pre> <p>A thread-safe, synchronous access layer for the Bijux CLI engine.</p> <p>This class provides a stable public API for registering commands, executing them, and managing plugins. It wraps the internal asynchronous <code>Engine</code> to allow for simpler, synchronous integration into other applications.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_engine</code>               (<code>Engine</code>)           \u2013            <p>The core asynchronous runtime engine.</p> </li> <li> <code>_registry</code>               (<code>RegistryProtocol</code>)           \u2013            <p>The plugin registry service.</p> </li> <li> <code>_obs</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service.</p> </li> </ul> <p>Initializes the <code>BijuxAPI</code> and the underlying CLI engine.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode for all underlying services. Defaults to False.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def __init__(self, *, debug: bool = False) -&gt; None:\n    \"\"\"Initializes the `BijuxAPI` and the underlying CLI engine.\n\n    Args:\n        debug (bool): If True, enables debug mode for all underlying\n            services. Defaults to False.\n    \"\"\"\n    DIContainer.reset()\n    self._di = DIContainer.current()\n    self._engine = Engine(\n        self._di,\n        debug=debug,\n        fmt=OutputFormat.JSON,\n    )\n    self._registry: RegistryProtocol = self._di.resolve(RegistryProtocol)\n    self._obs: ObservabilityProtocol = self._di.resolve(ObservabilityProtocol)\n    self._tel: TelemetryProtocol = self._di.resolve(TelemetryProtocol)\n</code></pre>"},{"location":"reference/api.html#bijux_cli.api.BijuxAPI.load_plugin","title":"load_plugin","text":"<pre><code>load_plugin(path: str | Path) -&gt; None\n</code></pre> <p>Loads or reloads a plugin module from a file path.</p> <p>This method dynamically loads the specified plugin file, initializes it, and registers it with the CLI system. If the plugin is already loaded, it is reloaded.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The filesystem path to the plugin's Python file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If plugin loading, initialization, or registration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def load_plugin(self, path: str | Path) -&gt; None:\n    \"\"\"Loads or reloads a plugin module from a file path.\n\n    This method dynamically loads the specified plugin file, initializes it,\n    and registers it with the CLI system. If the plugin is already loaded,\n    it is reloaded.\n\n    Args:\n        path (str | Path): The filesystem path to the plugin's Python file.\n\n    Raises:\n        BijuxError: If plugin loading, initialization, or registration fails.\n    \"\"\"\n    from bijux_cli.__version__ import __version__\n    from bijux_cli.services.plugins import load_plugin as _load_plugin\n\n    p = Path(path).expanduser().resolve()\n    module_name = f\"bijux_plugin_{p.stem}\"\n\n    try:\n        if module_name in sys.modules:\n            importlib.reload(sys.modules[module_name])\n\n        plugin = _load_plugin(p, module_name)\n        plugin.startup(self._engine.di)\n\n        if self._registry.has(p.stem):\n            self._registry.deregister(p.stem)\n\n        self._registry.register(\n            p.stem,\n            plugin,\n            alias=str(__version__),\n        )\n        self._obs.log(\"info\", \"Loaded plugin\", extra={\"path\": str(p)})\n        self._schedule_event(\"api.plugin_loaded\", {\"path\": str(p)})\n\n    except Exception as exc:\n        self._schedule_event(\n            \"api.plugin_load.error\", {\"path\": str(p), \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Failed to load plugin {p}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api.html#bijux_cli.api.BijuxAPI.register","title":"register","text":"<pre><code>register(name: str, callback: Callable[..., Any]) -&gt; None\n</code></pre> <p>Registers or replaces a Python callable as a CLI command.</p> <p>The provided callable is wrapped to handle both synchronous and asynchronous functions automatically.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The command name to register.</p> </li> <li> <code>callback</code>               (<code>Callable[..., Any]</code>)           \u2013            <p>The Python function to be executed when the command is run.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the command name is already in use or another registration error occurs.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def register(self, name: str, callback: Callable[..., Any]) -&gt; None:\n    \"\"\"Registers or replaces a Python callable as a CLI command.\n\n    The provided callable is wrapped to handle both synchronous and\n    asynchronous functions automatically.\n\n    Args:\n        name (str): The command name to register.\n        callback (Callable[..., Any]): The Python function to be executed\n            when the command is run.\n\n    Raises:\n        BijuxError: If the command name is already in use or another\n            registration error occurs.\n    \"\"\"\n\n    class _Wrapper:\n        \"\"\"Wraps a user-provided callable to be executed asynchronously.\"\"\"\n\n        def __init__(self, cb: Callable[..., Any]) -&gt; None:\n            \"\"\"Initializes the wrapper.\n\n            Args:\n                cb (Callable[..., Any]): The callable to wrap.\n            \"\"\"\n            self._cb = cb\n\n        async def execute(self, *args: Any, **kwargs: Any) -&gt; Any:\n            \"\"\"Execute the wrapped callable, awaiting if it's a coroutine.\n\n            Args:\n                *args (Any): Positional arguments to pass to the callable.\n                **kwargs (Any): Keyword arguments to pass to the callable.\n\n            Returns:\n                Any: The result of the callable execution.\n            \"\"\"\n            if asyncio.iscoroutinefunction(self._cb):\n                return await self._cb(*args, **kwargs)\n            return self._cb(*args, **kwargs)\n\n    try:\n        if self._registry.has(name):\n            self._registry.deregister(name)\n        self._registry.register(name, _Wrapper(callback))\n        self._obs.log(\"info\", \"Registered command\", extra={\"name\": name})\n        self._schedule_event(\"api.register\", {\"name\": name})\n    except ServiceError as exc:\n        self._schedule_event(\n            \"api.register.error\", {\"name\": name, \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Could not register command {name}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api.html#bijux_cli.api.BijuxAPI.run_async","title":"run_async  <code>async</code>","text":"<pre><code>run_async(\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Runs a command asynchronously with validation.</p> <p>This method performs validation of flags and environment variables before dispatching the command to the internal engine for execution.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to execute.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the command.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables verbose output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'json'</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, formats the output for readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>For invalid flags, unsupported formats, or internal execution errors.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>async def run_async(\n    self,\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Runs a command asynchronously with validation.\n\n    This method performs validation of flags and environment variables\n    before dispatching the command to the internal engine for execution.\n\n    Args:\n        name (str): The name of the command to execute.\n        *args (Any): Positional arguments for the command.\n        quiet (bool): If True, suppresses output.\n        verbose (bool): If True, enables verbose output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, formats the output for readability.\n        debug (bool): If True, enables debug mode.\n        **kwargs (Any): Additional keyword arguments to pass to the command.\n\n    Returns:\n        Any: The result of the command's execution.\n\n    Raises:\n        BijuxError: For invalid flags, unsupported formats, or internal\n            execution errors.\n    \"\"\"\n    try:\n        fmt = fmt.lower()\n        if fmt not in (\"json\", \"yaml\"):\n            raise BijuxError(\"Unsupported format\", http_status=400)\n\n        if quiet and (verbose or debug):\n            raise BijuxError(\n                \"--quiet cannot be combined with --verbose/--debug\", http_status=400\n            )\n\n        validate_common_flags(fmt, name, quiet, verbose or debug)\n\n        for k, v in os.environ.items():\n            if k in IGNORE:\n                continue\n            if not v.isascii():\n                raise BijuxError(\n                    \"Non-ASCII characters in environment\", http_status=400\n                )\n\n        result = await self._engine.run_command(name, *args, **kwargs)\n        self._schedule_event(\"api.run\", {\"name\": name})\n        return result\n\n    except CommandError as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n\n    except ServiceError as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n\n    except BijuxError:\n        raise\n\n    except Exception as exc:\n        self._schedule_event(\"api.run.error\", {\"name\": name, \"error\": str(exc)})\n        raise BijuxError(\n            f\"Failed to run command {name}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/api.html#bijux_cli.api.BijuxAPI.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Runs a command synchronously.</p> <p>This method is a blocking wrapper around the asynchronous <code>run_async</code> method. It manages the asyncio event loop to provide a simple, synchronous interface.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to run.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments for the command.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables verbose logging.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'json'</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, formats the output for readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> Source code in <code>src/bijux_cli/api.py</code> <pre><code>def run_sync(\n    self,\n    name: str,\n    *args: Any,\n    quiet: bool = False,\n    verbose: bool = False,\n    fmt: str = \"json\",\n    pretty: bool = True,\n    debug: bool = False,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Runs a command synchronously.\n\n    This method is a blocking wrapper around the asynchronous `run_async`\n    method. It manages the asyncio event loop to provide a simple,\n    synchronous interface.\n\n    Args:\n        name (str): The name of the command to run.\n        *args (Any): Positional arguments for the command.\n        quiet (bool): If True, suppresses output.\n        verbose (bool): If True, enables verbose logging.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, formats the output for readability.\n        debug (bool): If True, enables debug mode.\n        **kwargs (Any): Additional keyword arguments to pass to the command.\n\n    Returns:\n        Any: The result of the command's execution.\n    \"\"\"\n    try:\n        loop = asyncio.get_running_loop()\n    except RuntimeError:\n        return asyncio.run(\n            self.run_async(\n                name,\n                *args,\n                quiet=quiet,\n                verbose=verbose,\n                fmt=fmt,\n                pretty=pretty,\n                debug=debug,\n                **kwargs,\n            )\n        )\n    else:\n        return loop.run_until_complete(\n            self.run_async(\n                name,\n                *args,\n                quiet=quiet,\n                verbose=verbose,\n                fmt=fmt,\n                pretty=pretty,\n                debug=debug,\n                **kwargs,\n            )\n        )\n</code></pre>"},{"location":"reference/cli.html","title":"Cli Module API Reference","text":"<p>This section documents the internals of the <code>cli</code> module in Bijux CLI. </p>"},{"location":"reference/cli.html#bijux_cli.cli","title":"bijux_cli.cli","text":"<p>Constructs the main <code>Typer</code> application for the Bijux CLI.</p> <p>This module serves as the primary builder for the entire CLI. It defines the root <code>Typer</code> app, orchestrates the registration of all core commands and the discovery of dynamic plugins, and sets the default behavior for when the CLI is invoked without any command.</p>"},{"location":"reference/cli.html#bijux_cli.cli.build_app","title":"build_app","text":"<pre><code>build_app() -&gt; Typer\n</code></pre> <p>Builds and configures the root <code>Typer</code> application.</p> <p>This factory function performs the main steps of assembling the CLI: 1.  Creates the root <code>Typer</code> app instance. 2.  Registers all core, built-in commands. 3.  Discovers and registers all dynamic plugins. 4.  Sets the default callback to launch the REPL.</p> <p>Returns:</p> <ul> <li> <code>Typer</code>           \u2013            <p>typer.Typer: The fully constructed <code>Typer</code> application.</p> </li> </ul> Source code in <code>src/bijux_cli/cli.py</code> <pre><code>def build_app() -&gt; typer.Typer:\n    \"\"\"Builds and configures the root `Typer` application.\n\n    This factory function performs the main steps of assembling the CLI:\n    1.  Creates the root `Typer` app instance.\n    2.  Registers all core, built-in commands.\n    3.  Discovers and registers all dynamic plugins.\n    4.  Sets the default callback to launch the REPL.\n\n    Returns:\n        typer.Typer: The fully constructed `Typer` application.\n    \"\"\"\n    app = typer.Typer(\n        help=\"Bijux CLI \u2013 Lean, plug-in\u2011driven command\u2011line interface.\",\n        invoke_without_command=True,\n        context_settings={\n            \"ignore_unknown_options\": True,\n            \"allow_extra_args\": True,\n        },\n    )\n    register_commands(app)\n    register_dynamic_plugins(app)\n    app.callback(invoke_without_command=True)(maybe_default_to_repl)\n    return app\n</code></pre>"},{"location":"reference/cli.html#bijux_cli.cli.maybe_default_to_repl","title":"maybe_default_to_repl","text":"<pre><code>maybe_default_to_repl(ctx: Context) -&gt; None\n</code></pre> <p>Invokes the <code>repl</code> command if no other subcommand is specified.</p> <p>This function is used as the root callback for the main <code>Typer</code> application. It checks if a subcommand was invoked and, if not, re-executes the CLI with the <code>repl</code> command.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used to check for an invoked subcommand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/cli.py</code> <pre><code>def maybe_default_to_repl(ctx: Context) -&gt; None:\n    \"\"\"Invokes the `repl` command if no other subcommand is specified.\n\n    This function is used as the root callback for the main `Typer` application.\n    It checks if a subcommand was invoked and, if not, re-executes the CLI\n    with the `repl` command.\n\n    Args:\n        ctx (Context): The Typer context, used to check for an invoked subcommand.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand is None:\n        subprocess.call([sys.argv[0], \"repl\"])  # noqa: S603  # nosec B603\n</code></pre>"},{"location":"reference/httpapi.html","title":"Httpapi Module API Reference","text":"<p>This section documents the internals of the <code>httpapi</code> module in Bijux CLI. </p>"},{"location":"reference/httpapi.html#bijux_cli.httpapi","title":"bijux_cli.httpapi","text":"<p>Provides a self-contained FastAPI application for a CRUD API.</p> <p>This module defines a complete HTTP API for managing \"Item\" resources using the FastAPI framework. It includes all necessary components for a functional web service.</p> Services <ul> <li>Pydantic Models: <code>ItemIn</code>, <code>Item</code>, and response models for data     validation and serialization.</li> <li>Storage Layer: A formal <code>ItemStoreProtocol</code> and a concrete,     thread-safe <code>InMemoryItemStore</code> implementation.</li> <li>API Endpoints: A FastAPI <code>APIRouter</code> with path operations for all     CRUD (Create, Read, Update, Delete) actions.</li> <li>Application Lifecycle: A <code>lifespan</code> manager to prepopulate and     clear the data store on startup and shutdown.</li> </ul>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore","title":"InMemoryItemStore","text":"<pre><code>InMemoryItemStore()\n</code></pre> <p>               Bases: <code>ItemStoreProtocol</code></p> <p>A thread-safe, in-memory implementation of the <code>ItemStoreProtocol</code>.</p> <p>Attributes:</p> <ul> <li> <code>_items</code>               (<code>dict</code>)           \u2013            <p>The main dictionary storing items by their ID.</p> </li> <li> <code>_name_index</code>               (<code>dict</code>)           \u2013            <p>An index to enforce unique item names.</p> </li> <li> <code>_lock</code>               (<code>RLock</code>)           \u2013            <p>A lock to ensure thread-safe operations.</p> </li> <li> <code>_next_id</code>               (<code>int</code>)           \u2013            <p>A counter for generating new item IDs.</p> </li> </ul> <p>Initializes the in-memory item store.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the in-memory item store.\"\"\"\n    self._items: dict[int, Item] = {}\n    self._name_index: dict[str, int] = {}\n    self._lock = threading.RLock()\n    self._next_id = 1\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.create","title":"create","text":"<pre><code>create(data: ItemIn) -&gt; Item\n</code></pre> <p>Creates a new item.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ItemIn</code>)           \u2013            <p>The data for the new item.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The newly created item, including its generated ID.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 409 if an item with the same name exists.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def create(self, data: ItemIn) -&gt; Item:\n    \"\"\"Creates a new item.\n\n    Args:\n        data (ItemIn): The data for the new item.\n\n    Returns:\n        The newly created item, including its generated ID.\n\n    Raises:\n        HTTPException: With status 409 if an item with the same name exists.\n    \"\"\"\n    with self._lock:\n        name = data.name  # Already stripped by validator\n        if name in self._name_index:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/conflict\"),\n                    title=\"Conflict\",\n                    status=status.HTTP_409_CONFLICT,\n                    detail=\"Item with this name already exists\",\n                    instance=\"/v1/items\",\n                ).model_dump(mode=\"json\"),\n            )\n        item_id = self._next_id\n        self._next_id += 1\n        item = Item(id=item_id, name=name, description=data.description)\n        self._items[item_id] = item\n        self._name_index[name] = item_id\n        logger.info(f\"Created item: {item}\")\n        return item\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.delete","title":"delete","text":"<pre><code>delete(item_id: int) -&gt; None\n</code></pre> <p>Deletes an item by its unique ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def delete(self, item_id: int) -&gt; None:\n    \"\"\"Deletes an item by its unique ID.\n\n    Args:\n        item_id (int): The ID of the item to delete.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found.\n    \"\"\"\n    with self._lock:\n        item = self._items.pop(item_id, None)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        del self._name_index[item.name]\n        logger.info(f\"Deleted item id={item_id}\")\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.get","title":"get","text":"<pre><code>get(item_id: int) -&gt; Item\n</code></pre> <p>Gets an item by its unique ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The requested item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get(self, item_id: int) -&gt; Item:\n    \"\"\"Gets an item by its unique ID.\n\n    Args:\n        item_id (int): The ID of the item to retrieve.\n\n    Returns:\n        The requested item.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found.\n    \"\"\"\n    with self._lock:\n        item = self._items.get(item_id)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        return item\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.list_items","title":"list_items","text":"<pre><code>list_items(\n    limit: int, offset: int\n) -&gt; tuple[list[Item], int]\n</code></pre> <p>Lists items with pagination in a thread-safe manner.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>)           \u2013            <p>The maximum number of items to return.</p> </li> <li> <code>offset</code>               (<code>int</code>)           \u2013            <p>The starting index for the items to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[Item], int]</code>           \u2013            <p>A tuple containing the list of items and the total number of items.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def list_items(self, limit: int, offset: int) -&gt; tuple[list[Item], int]:\n    \"\"\"Lists items with pagination in a thread-safe manner.\n\n    Args:\n        limit (int): The maximum number of items to return.\n        offset (int): The starting index for the items to return.\n\n    Returns:\n        A tuple containing the list of items and the total number of items.\n    \"\"\"\n    with self._lock:\n        items = list(self._items.values())\n        return items[offset : offset + limit], len(items)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.prepopulate","title":"prepopulate","text":"<pre><code>prepopulate(data: list[dict[str, Any]]) -&gt; None\n</code></pre> <p>Prepopulates the store with a list of items.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def prepopulate(self, data: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Prepopulates the store with a list of items.\"\"\"\n    with self._lock:\n        for entry in data:\n            self.create(ItemIn(**entry))\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the store to its initial empty state.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the store to its initial empty state.\"\"\"\n    with self._lock:\n        self._items.clear()\n        self._name_index.clear()\n        self._next_id = 1\n        logger.info(\"Store reset\")\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.InMemoryItemStore.update","title":"update","text":"<pre><code>update(item_id: int, data: ItemIn) -&gt; Item\n</code></pre> <p>Updates an existing item.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>)           \u2013            <p>The ID of the item to update.</p> </li> <li> <code>data</code>               (<code>ItemIn</code>)           \u2013            <p>The new data for the item.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code>           \u2013            <p>The updated item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>HTTPException</code>             \u2013            <p>With status 404 if the item is not found, or 409 if the new name conflicts with another existing item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def update(self, item_id: int, data: ItemIn) -&gt; Item:\n    \"\"\"Updates an existing item.\n\n    Args:\n        item_id (int): The ID of the item to update.\n        data (ItemIn): The new data for the item.\n\n    Returns:\n        The updated item.\n\n    Raises:\n        HTTPException: With status 404 if the item is not found, or 409\n            if the new name conflicts with another existing item.\n    \"\"\"\n    with self._lock:\n        item = self._items.get(item_id)\n        if not item:\n            raise HTTPException(\n                status_code=status.HTTP_404_NOT_FOUND,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/not-found\"),\n                    title=\"Not found\",\n                    status=status.HTTP_404_NOT_FOUND,\n                    detail=\"Item not found\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        name = data.name  # Already stripped by validator\n        if name != item.name and name in self._name_index:\n            raise HTTPException(\n                status_code=status.HTTP_409_CONFLICT,\n                detail=Problem(\n                    type=AnyUrl(\"https://bijux-cli.dev/docs/errors/conflict\"),\n                    title=\"Conflict\",\n                    status=status.HTTP_409_CONFLICT,\n                    detail=\"Item with this name already exists\",\n                    instance=f\"/v1/items/{item_id}\",\n                ).model_dump(mode=\"json\"),\n            )\n        if name != item.name:\n            del self._name_index[item.name]\n            self._name_index[name] = item_id\n        updated = Item(id=item_id, name=name, description=data.description)\n        self._items[item_id] = updated\n        logger.info(f\"Updated item: {updated}\")\n        return updated\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.Item","title":"Item","text":"<p>               Bases: <code>ItemIn</code></p> <p>Defines the full item model, including its unique identifier.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>int</code>)           \u2013            <p>The unique identifier for the item.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the item.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>An optional description for the item.</p> </li> </ul>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemIn","title":"ItemIn","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the input model for creating or updating an item.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the item.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>An optional description for the item.</p> </li> </ul>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemIn.normalize_name","title":"normalize_name  <code>classmethod</code>","text":"<pre><code>normalize_name(v: str) -&gt; str\n</code></pre> <p>Strips leading/trailing whitespace from the name field.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef normalize_name(cls: type[ItemIn], v: str) -&gt; str:  # noqa: N805\n    \"\"\"Strips leading/trailing whitespace from the name field.\"\"\"\n    return v.strip()\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemListResponse","title":"ItemListResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the response model for a paginated list of items.</p> <p>Attributes:</p> <ul> <li> <code>items</code>               (<code>list[Item]</code>)           \u2013            <p>The list of items on the current page.</p> </li> <li> <code>total</code>               (<code>int</code>)           \u2013            <p>The total number of items available.</p> </li> </ul>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol","title":"ItemStoreProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for an item storage service.</p>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.create","title":"create","text":"<pre><code>create(data: ItemIn) -&gt; Item\n</code></pre> <p>Creates a new item.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def create(self, data: ItemIn) -&gt; Item:\n    \"\"\"Creates a new item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.delete","title":"delete","text":"<pre><code>delete(item_id: int) -&gt; None\n</code></pre> <p>Deletes an item by its unique ID.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def delete(self, item_id: int) -&gt; None:\n    \"\"\"Deletes an item by its unique ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.get","title":"get","text":"<pre><code>get(item_id: int) -&gt; Item\n</code></pre> <p>Gets an item by its unique ID.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get(self, item_id: int) -&gt; Item:\n    \"\"\"Gets an item by its unique ID.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.list_items","title":"list_items","text":"<pre><code>list_items(\n    limit: int, offset: int\n) -&gt; tuple[list[Item], int]\n</code></pre> <p>Lists items with pagination.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def list_items(self, limit: int, offset: int) -&gt; tuple[list[Item], int]:\n    \"\"\"Lists items with pagination.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.prepopulate","title":"prepopulate","text":"<pre><code>prepopulate(data: list[dict[str, Any]]) -&gt; None\n</code></pre> <p>Prepopulates the store with a list of items.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def prepopulate(self, data: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Prepopulates the store with a list of items.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the store to its initial empty state.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the store to its initial empty state.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.ItemStoreProtocol.update","title":"update","text":"<pre><code>update(item_id: int, data: ItemIn) -&gt; Item\n</code></pre> <p>Updates an existing item.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def update(self, item_id: int, data: ItemIn) -&gt; Item:\n    \"\"\"Updates an existing item.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.Problem","title":"Problem","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a standard RFC 7807 problem details response.</p> <p>Attributes:</p> <ul> <li> <code>type</code>               (<code>AnyUrl</code>)           \u2013            <p>A URI reference that identifies the problem type.</p> </li> <li> <code>title</code>               (<code>str</code>)           \u2013            <p>A short, human-readable summary of the problem type.</p> </li> <li> <code>status</code>               (<code>int</code>)           \u2013            <p>The HTTP status code.</p> </li> <li> <code>detail</code>               (<code>str</code>)           \u2013            <p>A human-readable explanation specific to this occurrence.</p> </li> <li> <code>instance</code>               (<code>str</code>)           \u2013            <p>A URI reference that identifies the specific occurrence.</p> </li> </ul>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.create_item","title":"create_item","text":"<pre><code>create_item(\n    item: ItemIn = Body(...),\n    store: ItemStoreProtocol = Depends(get_store),\n) -&gt; Item\n</code></pre> <p>Creates a new item.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>ItemIn</code>, default:                   <code>Body(...)</code> )           \u2013            <p>The data for the new item from the request body.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The newly created item, including its server-generated ID.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.post(\n    \"/items\",\n    response_model=Item,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create item\",\n    description=\"Create a new item.\",\n    responses={409: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef create_item(\n    item: ItemIn = Body(...),  # noqa: B008\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Creates a new item.\n\n    Args:\n        item (ItemIn): The data for the new item from the request body.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The newly created item, including its server-generated ID.\n    \"\"\"\n    return store.create(item)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.delete_item","title":"delete_item","text":"<pre><code>delete_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),\n) -&gt; Response\n</code></pre> <p>Deletes an item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to delete.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Response</code> (              <code>Response</code> )          \u2013            <p>An empty response with a 204 No Content status code.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.delete(\n    \"/items/{item_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete item\",\n    description=\"Delete an item by its ID.\",\n    responses={404: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef delete_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Response:\n    \"\"\"Deletes an item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to delete.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Response: An empty response with a 204 No Content status code.\n    \"\"\"\n    store.delete(item_id)\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.get_item","title":"get_item","text":"<pre><code>get_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),\n) -&gt; Item\n</code></pre> <p>Retrieves a single item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to retrieve.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The requested item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.get(\n    \"/items/{item_id}\",\n    response_model=Item,\n    summary=\"Get item\",\n    description=\"Get a single item by its ID.\",\n    responses={404: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef get_item(\n    item_id: int = Path(..., gt=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Retrieves a single item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to retrieve.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The requested item.\n    \"\"\"\n    return store.get(item_id)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.get_store","title":"get_store","text":"<pre><code>get_store() -&gt; ItemStoreProtocol\n</code></pre> <p>A FastAPI dependency to provide the <code>ItemStoreProtocol</code> instance.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>def get_store() -&gt; ItemStoreProtocol:\n    \"\"\"A FastAPI dependency to provide the `ItemStoreProtocol` instance.\"\"\"\n    return store\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.health","title":"health  <code>async</code>","text":"<pre><code>health() -&gt; dict[str, str]\n</code></pre> <p>Lightweight readiness probe used by Makefile <code>api-test</code>.</p> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.get(\"/health\", summary=\"Health check\", tags=[\"Health\"])\nasync def health() -&gt; dict[str, str]:\n    \"\"\"Lightweight readiness probe used by Makefile `api-test`.\"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.http_exception_handler","title":"http_exception_handler  <code>async</code>","text":"<pre><code>http_exception_handler(\n    request: Request, exc: HTTPException\n) -&gt; JSONResponse\n</code></pre> <p>A custom exception handler for <code>HTTPException</code>.</p> <p>This handler intercepts FastAPI's standard HTTP exceptions and ensures they are logged and returned in the standard JSON error format.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The incoming request.</p> </li> <li> <code>exc</code>               (<code>HTTPException</code>)           \u2013            <p>The HTTP exception.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JSONResponse</code> (              <code>JSONResponse</code> )          \u2013            <p>A JSON response detailing the HTTP error.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.exception_handler(HTTPException)\nasync def http_exception_handler(request: Request, exc: HTTPException) -&gt; JSONResponse:\n    \"\"\"A custom exception handler for `HTTPException`.\n\n    This handler intercepts FastAPI's standard HTTP exceptions and ensures they\n    are logged and returned in the standard JSON error format.\n\n    Args:\n        request (Request): The incoming request.\n        exc (HTTPException): The HTTP exception.\n\n    Returns:\n        JSONResponse: A JSON response detailing the HTTP error.\n    \"\"\"\n    logger.warning(f\"HTTP error: {exc.status_code} {exc.detail}\")\n    return JSONResponse(status_code=exc.status_code, content=exc.detail)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.lifespan","title":"lifespan  <code>async</code>","text":"<pre><code>lifespan(app: FastAPI) -&gt; AsyncIterator[None]\n</code></pre> <p>Manages the application's lifespan events for startup and shutdown.</p> <p>On startup, this context manager resets and prepopulates the in-memory store with demo data. On shutdown, it resets the store again.</p> <p>Parameters:</p> <ul> <li> <code>app</code>               (<code>FastAPI</code>)           \u2013            <p>The FastAPI application instance.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>AsyncIterator[None]</code> )          \u2013            <p>Yields control to the application while it is running.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Manages the application's lifespan events for startup and shutdown.\n\n    On startup, this context manager resets and prepopulates the in-memory\n    store with demo data. On shutdown, it resets the store again.\n\n    Args:\n        app (FastAPI): The FastAPI application instance.\n\n    Yields:\n        None: Yields control to the application while it is running.\n    \"\"\"\n    store.reset()\n    store.prepopulate(\n        [\n            {\"name\": \"Item One\", \"description\": \"Description one\"},\n            {\"name\": \"Item Two\", \"description\": \"Description two\"},\n        ]\n    )\n    logger.info(\"Prepopulated store with demo items\")\n    yield\n    store.reset()\n    logger.info(\"Store reset on shutdown\")\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.list_items","title":"list_items","text":"<pre><code>list_items(\n    limit: int = Query(10, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    store: ItemStoreProtocol = Depends(get_store),\n) -&gt; ItemListResponse\n</code></pre> <p>Retrieves a paginated list of items.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Query(10, ge=1, le=100)</code> )           \u2013            <p>The maximum number of items per page.</p> </li> <li> <code>offset</code>               (<code>int</code>, default:                   <code>Query(0, ge=0)</code> )           \u2013            <p>The starting offset for the item list.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemListResponse</code> (              <code>ItemListResponse</code> )          \u2013            <p>An object containing the list of items and total count.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.get(\n    \"/items\",\n    response_model=ItemListResponse,\n    summary=\"List items\",\n    description=\"List all items with pagination.\",\n    tags=[\"Items\"],\n)\ndef list_items(\n    limit: int = Query(10, ge=1, le=100),\n    offset: int = Query(0, ge=0),\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; ItemListResponse:\n    \"\"\"Retrieves a paginated list of items.\n\n    Args:\n        limit (int): The maximum number of items per page.\n        offset (int): The starting offset for the item list.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        ItemListResponse: An object containing the list of items and total count.\n    \"\"\"\n    items, total = store.list_items(limit, offset)\n    return ItemListResponse(items=items, total=total)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.update_item","title":"update_item","text":"<pre><code>update_item(\n    item_id: int = Path(..., gt=0),\n    item: ItemIn = Body(...),\n    store: ItemStoreProtocol = Depends(get_store),\n) -&gt; Item\n</code></pre> <p>Updates an existing item by its ID.</p> <p>Parameters:</p> <ul> <li> <code>item_id</code>               (<code>int</code>, default:                   <code>Path(..., gt=0)</code> )           \u2013            <p>The unique identifier of the item to update.</p> </li> <li> <code>item</code>               (<code>ItemIn</code>, default:                   <code>Body(...)</code> )           \u2013            <p>The new data for the item from the request body.</p> </li> <li> <code>store</code>               (<code>ItemStoreProtocol</code>, default:                   <code>Depends(get_store)</code> )           \u2013            <p>The dependency-injected item store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Item</code> (              <code>Item</code> )          \u2013            <p>The updated item.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@router.put(\n    \"/items/{item_id}\",\n    response_model=Item,\n    summary=\"Update item\",\n    description=\"Update an existing item.\",\n    responses={404: {\"model\": Problem}, 409: {\"model\": Problem}},\n    tags=[\"Items\"],\n)\ndef update_item(\n    item_id: int = Path(..., gt=0),\n    item: ItemIn = Body(...),  # noqa: B008\n    store: ItemStoreProtocol = Depends(get_store),  # noqa: B008\n) -&gt; Item:\n    \"\"\"Updates an existing item by its ID.\n\n    Args:\n        item_id (int): The unique identifier of the item to update.\n        item (ItemIn): The new data for the item from the request body.\n        store (ItemStoreProtocol): The dependency-injected item store.\n\n    Returns:\n        Item: The updated item.\n    \"\"\"\n    return store.update(item_id, item)\n</code></pre>"},{"location":"reference/httpapi.html#bijux_cli.httpapi.validation_exception_handler","title":"validation_exception_handler  <code>async</code>","text":"<pre><code>validation_exception_handler(\n    request: Request, exc: RequestValidationError\n) -&gt; JSONResponse\n</code></pre> <p>A custom exception handler for <code>RequestValidationError</code>.</p> <p>This handler intercepts validation errors from FastAPI and formats them into a standard <code>JSONResponse</code> with a 422 status code.</p> <p>Parameters:</p> <ul> <li> <code>request</code>               (<code>Request</code>)           \u2013            <p>The incoming request.</p> </li> <li> <code>exc</code>               (<code>RequestValidationError</code>)           \u2013            <p>The validation exception.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>JSONResponse</code> (              <code>JSONResponse</code> )          \u2013            <p>A JSON response detailing the validation error.</p> </li> </ul> Source code in <code>src/bijux_cli/httpapi.py</code> <pre><code>@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(\n    request: Request, exc: RequestValidationError\n) -&gt; JSONResponse:\n    \"\"\"A custom exception handler for `RequestValidationError`.\n\n    This handler intercepts validation errors from FastAPI and formats them\n    into a standard `JSONResponse` with a 422 status code.\n\n    Args:\n        request (Request): The incoming request.\n        exc (RequestValidationError): The validation exception.\n\n    Returns:\n        JSONResponse: A JSON response detailing the validation error.\n    \"\"\"\n    logger.warning(f\"Validation error: {exc.errors()}\")\n    return JSONResponse(\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n        content=Problem(\n            type=AnyUrl(\"https://bijux-cli.dev/docs/errors/validation-error\"),\n            title=\"Validation error\",\n            status=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=str(exc),\n            instance=str(request.url),\n        ).model_dump(mode=\"json\"),\n    )\n</code></pre>"},{"location":"reference/commands/index.html","title":"Reference / Commands Index","text":"<ul> <li>Audit Command</li> <li>Docs Command</li> <li>Doctor Command</li> <li>Help Command</li> <li>Repl Command</li> <li>Sleep Command</li> <li>Status Command</li> <li>Utilities Command</li> <li>Version Command</li> </ul>"},{"location":"reference/commands/audit.html","title":"Audit Command API Reference","text":"<p>This section documents the internals of the <code>audit</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/audit.html#bijux_cli.commands.audit","title":"bijux_cli.commands.audit","text":"<p>Audit command for the Bijux CLI.</p> <p>Audits the current environment and configuration, emitting machine-readable structured output in JSON or YAML. Supports dry-run simulation and writing results to a file. Handles ASCII hygiene and structured error contracts. Output is automation-safe and suitable for scripting or monitoring.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"completed\"}</code></li> <li>Dry-run: <code>{\"status\": \"dry-run\"}</code></li> <li>Written: <code>{\"status\": \"written\", \"file\": \"&lt;path&gt;\"}</code></li> <li>Verbose: <code>{\"python\": str, \"platform\": str}</code></li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success, dry-run, or write success.</li> <li><code>1</code>: Unexpected/internal error.</li> <li><code>2</code>: CLI argument/flag/format or output-path error.</li> <li><code>3</code>: ASCII/encoding error.</li> </ul>"},{"location":"reference/commands/audit.html#bijux_cli.commands.audit.audit","title":"audit","text":"<pre><code>audit(\n    ctx: Context,\n    dry_run: bool = DRY_RUN_OPTION,\n    output: Path | None = OUTPUT_OPTION,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux audit</code> command.</p> <p>This function orchestrates the entire audit process. It validates all CLI flags and arguments, performs environment checks (e.g., for non-ASCII characters), builds the appropriate result payload, and emits it to stdout or a file in the specified format. All errors are handled and emitted in a structured format before exiting with a specific code.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used to manage command state and detect stray arguments.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>DRY_RUN_OPTION</code> )           \u2013            <p>If True, simulates the audit and reports a \"dry-run\" status without performing actions.</p> </li> <li> <code>output</code>               (<code>Path | None</code>, default:                   <code>OUTPUT_OPTION</code> )           \u2013            <p>If a path is provided, writes the audit result to the specified file instead of stdout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors. The exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability. This is overridden by <code>debug</code>.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, which implies <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a status code and structured error payload upon validation failures (e.g., bad arguments, ASCII errors), I/O issues, or unexpected exceptions. The exit code follows the contract defined in the module docstring.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/audit.py</code> <pre><code>@audit_app.callback(invoke_without_command=True)\ndef audit(\n    ctx: typer.Context,\n    dry_run: bool = DRY_RUN_OPTION,\n    output: Path | None = OUTPUT_OPTION,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux audit` command.\n\n    This function orchestrates the entire audit process. It validates all CLI\n    flags and arguments, performs environment checks (e.g., for non-ASCII\n    characters), builds the appropriate result payload, and emits it to\n    stdout or a file in the specified format. All errors are handled and\n    emitted in a structured format before exiting with a specific code.\n\n    Args:\n        ctx (typer.Context): The Typer context, used to manage command state\n            and detect stray arguments.\n        dry_run (bool): If True, simulates the audit and reports a \"dry-run\"\n            status without performing actions.\n        output (Path | None): If a path is provided, writes the audit result\n            to the specified file instead of stdout.\n        quiet (bool): If True, suppresses all output except for errors. The\n            exit code is the primary indicator of the outcome.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n            This is overridden by `debug`.\n        debug (bool): If True, enables debug diagnostics, which implies `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a status code and structured error payload upon\n            validation failures (e.g., bad arguments, ASCII errors), I/O\n            issues, or unexpected exceptions. The exit code follows the\n            contract defined in the module docstring.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"audit\"\n\n    try:\n        stray_args = [a for a in ctx.args if not a.startswith(\"-\")]\n        if stray_args:\n            raise typer.BadParameter(f\"No such argument: {stray_args[0]}\")\n        fmt_lower = validate_common_flags(fmt, command, quiet)\n        include_runtime = verbose or debug\n        effective_pretty = debug or pretty\n        out_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n\n        if contains_non_ascii_env():\n            emit_error_and_exit(\n                \"Non-ASCII environment variables detected\",\n                code=3,\n                failure=\"ascii_env\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n            )\n        try:\n            validate_env_file_if_present(os.environ.get(\"BIJUXCLI_CONFIG\", \"\"))\n        except ValueError as exc:\n            emit_error_and_exit(\n                str(exc),\n                code=3,\n                failure=\"ascii\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n            )\n\n    except typer.BadParameter as exc:\n        error_fmt = fmt.lower() if fmt.lower() in (\"json\", \"yaml\") else \"json\"\n        emit_error_and_exit(\n            exc.message,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=verbose or debug,\n        )\n\n    try:\n        emitter = DIContainer.current().resolve(EmitterProtocol)\n        payload = _build_payload(include_runtime, dry_run)\n\n        if output is not None:\n            _write_output_file(\n                output_path=output,\n                payload=payload,\n                emitter=emitter,\n                fmt=out_format,\n                pretty=effective_pretty,\n                debug=debug,\n                dry_run=dry_run,\n            )\n            payload = {\"status\": \"written\", \"file\": str(output)}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n\n        new_run_command(\n            command_name=command,\n            payload_builder=lambda _: payload,\n            quiet=quiet,\n            verbose=(verbose or debug),\n            fmt=fmt_lower,\n            pretty=(debug or pretty),\n            debug=debug,\n        )\n\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n    except OSError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=2,\n            failure=\"output_file\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"An unexpected error occurred: {exc}\",\n            code=1,\n            failure=\"unexpected\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n</code></pre>"},{"location":"reference/commands/docs.html","title":"Docs Command API Reference","text":"<p>This section documents the internals of the <code>docs</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/docs.html#bijux_cli.commands.docs","title":"bijux_cli.commands.docs","text":"<p>Docs command for the Bijux CLI.</p> <p>Generates a machine-readable specification of the entire CLI, outputting it as JSON or YAML. This command is designed for automation, enabling integration with external documentation tools or APIs. It supports outputting to stdout or a file and ensures all text is ASCII-safe.</p> Output Contract <ul> <li>Success (file):   <code>{\"status\": \"written\", \"file\": \"&lt;path&gt;\"}</code></li> <li>Success (stdout): The raw specification string is printed directly.</li> <li>Spec fields:      <code>{\"version\": str, \"commands\": list, ...}</code></li> <li>Verbose:          Adds <code>{\"python\": str, \"platform\": str}</code> to the spec.</li> <li>Error:            <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Fatal or internal error.</li> <li><code>2</code>: CLI argument, flag, or format error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/docs.html#bijux_cli.commands.docs.docs","title":"docs","text":"<pre><code>docs(\n    ctx: Context,\n    out: Path | None = OUT_OPTION,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux docs</code> command.</p> <p>This function orchestrates the entire specification generation process. It validates CLI flags, checks for ASCII-safe environment variables, resolves the output destination, builds the specification payload, and writes the result to a file or stdout. All errors are handled and emitted in a structured format before exiting with a specific code.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context, used for managing command state.</p> </li> <li> <code>out</code>               (<code>Path | None</code>, default:                   <code>OUT_OPTION</code> )           \u2013            <p>The output destination: a file path, a directory, or '-' to signify stdout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform metadata in the spec.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits the application with a contract-compliant status code and payload upon any error, including argument validation, ASCII violations, serialization failures, or I/O issues.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/docs.py</code> <pre><code>@docs_app.callback(invoke_without_command=True)\ndef docs(\n    ctx: typer.Context,\n    out: Path | None = OUT_OPTION,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux docs` command.\n\n    This function orchestrates the entire specification generation process. It\n    validates CLI flags, checks for ASCII-safe environment variables, resolves\n    the output destination, builds the specification payload, and writes the\n    result to a file or stdout. All errors are handled and emitted in a\n    structured format before exiting with a specific code.\n\n    Args:\n        ctx (typer.Context): The Typer context, used for managing command state.\n        out (Path | None): The output destination: a file path, a directory, or\n            '-' to signify stdout.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform metadata in the spec.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits the application with a contract-compliant status code\n            and payload upon any error, including argument validation, ASCII\n            violations, serialization failures, or I/O issues.\n    \"\"\"\n    from bijux_cli.commands.utilities import normalize_format\n    from bijux_cli.infra.serializer import OrjsonSerializer, PyYAMLSerializer\n    from bijux_cli.infra.telemetry import NullTelemetry\n\n    command = \"docs\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = normalize_format(fmt)\n\n    if ctx.args:\n        stray = ctx.args[0]\n        msg = (\n            f\"No such option: {stray}\"\n            if stray.startswith(\"-\")\n            else f\"Too many arguments: {' '.join(ctx.args)}\"\n        )\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII characters in environment variables\",\n            code=3,\n            failure=\"ascii_env\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    out_env = os.environ.get(\"BIJUXCLI_DOCS_OUT\")\n    if out is None and out_env:\n        out = Path(out_env)\n\n    target, path = _resolve_output_target(out, fmt_lower)\n\n    try:\n        spec = _build_spec_payload(effective_include_runtime)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    serializer = (\n        PyYAMLSerializer(NullTelemetry())\n        if output_format is OutputFormat.YAML\n        else OrjsonSerializer(NullTelemetry())\n    )\n    try:\n        content = serializer.dumps(spec, fmt=output_format, pretty=effective_pretty)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Serialization failed: {exc}\",\n            code=1,\n            failure=\"serialize\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if os.environ.get(\"BIJUXCLI_TEST_IO_FAIL\") == \"1\":\n        emit_error_and_exit(\n            \"Simulated I/O failure for test\",\n            code=1,\n            failure=\"io_fail\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if target == \"-\":\n        if not quiet:\n            typer.echo(content)\n        raise typer.Exit(0)\n\n    if path is None:\n        emit_error_and_exit(\n            \"Internal error: expected non-null output path\",\n            code=1,\n            failure=\"internal\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    parent = path.parent\n    if not parent.exists():\n        emit_error_and_exit(\n            f\"Output directory does not exist: {parent}\",\n            code=2,\n            failure=\"output_dir\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    try:\n        path.write_text(content, encoding=\"utf-8\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to write spec: {exc}\",\n            code=2,\n            failure=\"write\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    emit_and_exit(\n        {\"status\": \"written\", \"file\": str(path)},\n        output_format,\n        effective_pretty,\n        verbose,\n        debug,\n        quiet,\n        command,\n    )\n</code></pre>"},{"location":"reference/commands/doctor.html","title":"Doctor Command API Reference","text":"<p>This section documents the internals of the <code>doctor</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/doctor.html#bijux_cli.commands.doctor","title":"bijux_cli.commands.doctor","text":"<p>Implements the <code>doctor</code> command for the Bijux CLI.</p> <p>This module provides the functionality for the <code>bijux doctor</code> command, which runs a series of health diagnostics on the CLI's operating environment. It checks for common configuration issues and reports a summary of its findings in a structured, machine-readable format suitable for automation.</p> Output Contract <ul> <li>Success: <code>{\"status\": str, \"summary\": list[str]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success (command ran without errors, regardless of health status).</li> <li><code>1</code>: Internal or fatal error (e.g., dependency injection failure).</li> <li><code>2</code>: CLI argument or flag error.</li> </ul>"},{"location":"reference/commands/doctor.html#bijux_cli.commands.doctor.doctor","title":"doctor","text":"<pre><code>doctor(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux doctor</code> command.</p> <p>This function orchestrates the health check process. It validates all CLI flags, performs critical pre-flight checks (like dependency availability), and then invokes the main run utility to build and emit the health payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for managing command state.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output; the exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits the application with a contract-compliant status code and payload upon any error, such as invalid arguments or an internal system failure.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/doctor.py</code> <pre><code>@doctor_app.callback(invoke_without_command=True)\ndef doctor(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux doctor` command.\n\n    This function orchestrates the health check process. It validates all CLI\n    flags, performs critical pre-flight checks (like dependency availability),\n    and then invokes the main run utility to build and emit the health payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for managing command state.\n        quiet (bool): If True, suppresses all output; the exit code is the\n            primary indicator of the outcome.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits the application with a contract-compliant status code\n            and payload upon any error, such as invalid arguments or an\n            internal system failure.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"doctor\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if ctx.args:\n        stray = ctx.args[0]\n        msg = (\n            f\"No such option: {stray}\"\n            if stray.startswith(\"-\")\n            else f\"Too many arguments: {' '.join(ctx.args)}\"\n        )\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=\"args\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    try:\n        DIContainer.current().resolve(EmitterProtocol)\n        DIContainer.current().resolve(TelemetryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=1,\n            failure=\"internal\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=_build_payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/help.html","title":"Help Command API Reference","text":"<p>This section documents the internals of the <code>help</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/help.html#bijux_cli.commands.help","title":"bijux_cli.commands.help","text":"<p>Implements the <code>help</code> command for the Bijux CLI.</p> <p>This module provides a contextual help system that can generate and display help text for any command or subcommand. It supports multiple output formats, including human-readable text for interactive use and structured JSON or YAML for automation and integration purposes. It also includes special logic to suppress known noisy warnings from the plugin system during help generation.</p> Output Contract <ul> <li>Human:      Standard CLI help text is printed to stdout.</li> <li>JSON/YAML:  <code>{\"help\": str}</code></li> <li>Verbose:    Adds <code>{\"python\": str, \"platform\": str, \"runtime_ms\": int}</code>.</li> <li>Error:      <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Fatal or internal error.</li> <li><code>2</code>: CLI argument, flag, or \"command not found\" error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/help.html#bijux_cli.commands.help.help_callback","title":"help_callback","text":"<pre><code>help_callback(\n    ctx: Context,\n    command_path: list[str] | None = ARGS,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        _HUMAN, \"-f\", \"--format\", help=HELP_FORMAT_HELP\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux help</code> command.</p> <p>This function orchestrates the entire help generation process. It parses the target command path, finds the corresponding command object, performs ASCII and format validation, and emits the help text in the specified format.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>command_path</code>               (<code>list[str] | None</code>, default:                   <code>ARGS</code> )           \u2013            <p>A list of tokens representing the path to the target command (e.g., <code>[\"config\", \"get\"]</code>).</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output. The exit code is the primary indicator of outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in structured output formats.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option(_HUMAN, '-f', '--format', help=HELP_FORMAT_HELP)</code> )           \u2013            <p>The output format: \"human\", \"json\", or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints structured output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant exit code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/help.py</code> <pre><code>@help_app.callback(invoke_without_command=True)\ndef help_callback(\n    ctx: typer.Context,\n    command_path: list[str] | None = ARGS,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(_HUMAN, \"-f\", \"--format\", help=HELP_FORMAT_HELP),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux help` command.\n\n    This function orchestrates the entire help generation process. It parses the\n    target command path, finds the corresponding command object, performs ASCII\n    and format validation, and emits the help text in the specified format.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        command_path (list[str] | None): A list of tokens representing the path\n            to the target command (e.g., `[\"config\", \"get\"]`).\n        quiet (bool): If True, suppresses all output. The exit code is the\n            primary indicator of outcome.\n        verbose (bool): If True, includes Python and platform details in\n            structured output formats.\n        fmt (str): The output format: \"human\", \"json\", or \"yaml\".\n        pretty (bool): If True, pretty-prints structured output.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant exit code and payload\n            upon completion or error.\n    \"\"\"\n    started_at = time.perf_counter()\n\n    if \"-h\" in sys.argv or \"--help\" in sys.argv:\n        all_args = sys.argv[2:]\n        known_flags_with_args = {\"-f\", \"--format\"}\n        path_tokens = []\n        i = 0\n        while i &lt; len(all_args):\n            arg = all_args[i]\n            if arg in known_flags_with_args:\n                i += 2\n            elif arg.startswith(\"-\"):\n                i += 1\n            else:\n                path_tokens.append(arg)\n                i += 1\n\n        target = _find_target_command(ctx, path_tokens) or _find_target_command(ctx, [])\n        if target:\n            target_cmd, target_ctx = target\n            help_text = _get_formatted_help(target_cmd, target_ctx)\n            typer.echo(help_text)\n        raise typer.Exit(0)\n\n    tokens = command_path or []\n    command = \"help\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n    fmt_lower = fmt.strip().lower()\n    error_fmt = fmt_lower if fmt_lower in (\"json\", \"yaml\") else \"json\"\n\n    if quiet:\n        if fmt_lower not in _VALID_FORMATS:\n            raise SystemExit(2)\n\n        for token in tokens:\n            if \"\\x00\" in token:\n                raise SystemExit(3)\n            try:\n                token.encode(\"ascii\")\n            except UnicodeEncodeError as err:\n                raise SystemExit(3) from err\n\n        if contains_non_ascii_env():\n            raise SystemExit(3)\n\n        if not _find_target_command(ctx, tokens):\n            raise SystemExit(2)\n\n        raise SystemExit(0)\n\n    if fmt_lower != \"human\":\n        validate_common_flags(\n            fmt,\n            command,\n            quiet,\n            include_runtime=effective_include_runtime,\n        )\n\n    if fmt_lower not in _VALID_FORMATS:\n        emit_error_and_exit(\n            f\"Unsupported format: '{fmt}'\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    for token in tokens:\n        if \"\\x00\" in token:\n            emit_error_and_exit(\n                \"Embedded null byte in command path\",\n                code=3,\n                failure=\"null_byte\",\n                command=command,\n                fmt=error_fmt,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n        try:\n            token.encode(\"ascii\")\n        except UnicodeEncodeError:\n            emit_error_and_exit(\n                f\"Non-ASCII characters in command path: {token!r}\",\n                code=3,\n                failure=\"ascii\",\n                command=command,\n                fmt=error_fmt,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII in environment\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    target = _find_target_command(ctx, tokens)\n    if not target:\n        emit_error_and_exit(\n            f\"No such command: {' '.join(tokens)}\",\n            code=2,\n            failure=\"not_found\",\n            command=command,\n            fmt=error_fmt,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    DIContainer.current().resolve(EmitterProtocol)\n    target_cmd, target_ctx = target\n    help_text = _get_formatted_help(target_cmd, target_ctx)\n\n    if fmt_lower == _HUMAN:\n        typer.echo(help_text)\n        raise typer.Exit(0)\n\n    try:\n        payload = _build_help_payload(help_text, effective_include_runtime, started_at)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    emit_and_exit(\n        payload=payload,\n        fmt=output_format,\n        effective_pretty=effective_pretty,\n        verbose=verbose,\n        debug=debug,\n        quiet=quiet,\n        command=command,\n        exit_code=0,\n    )\n</code></pre>"},{"location":"reference/commands/repl.html","title":"Repl Command API Reference","text":"<p>This section documents the internals of the <code>repl</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/repl.html#bijux_cli.commands.repl","title":"bijux_cli.commands.repl","text":"<p>Implements the interactive Read-Eval-Print Loop (REPL) for the Bijux CLI.</p> <p>This module provides a rich, interactive shell for executing Bijux CLI commands. It enhances the user experience with features like persistent command history, context-aware tab-completion, and a colorized prompt. Users can chain multiple commands on a single line using semicolons. The REPL can also operate in a non-interactive mode to process commands piped from stdin.</p> <p>The REPL itself operates in a human-readable format. When executing commands, it respects global flags like <code>--format</code> or <code>--quiet</code> for those specific invocations.</p> Exit Codes <ul> <li><code>0</code>: The REPL session was exited cleanly (e.g., via <code>exit</code>, <code>quit</code>,   Ctrl+D, or a caught signal).</li> <li><code>2</code>: An invalid flag was provided to the <code>repl</code> command itself   (e.g., <code>--format=json</code>).</li> </ul>"},{"location":"reference/commands/repl.html#bijux_cli.commands.repl.CommandCompleter","title":"CommandCompleter","text":"<pre><code>CommandCompleter(main_app: Typer)\n</code></pre> <p>               Bases: <code>Completer</code></p> <p>Provides context-aware tab-completion for the REPL.</p> <p>Initializes the completer.</p> <p>Parameters:</p> <ul> <li> <code>main_app</code>               (<code>Typer</code>)           \u2013            <p>The root Typer application whose commands and options will be used for completion suggestions.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def __init__(self, main_app: typer.Typer) -&gt; None:\n    \"\"\"Initializes the completer.\n\n    Args:\n        main_app (typer.Typer): The root Typer application whose commands\n            and options will be used for completion suggestions.\n    \"\"\"\n    self.main_app = main_app\n    self._cmd_map = self._collect(main_app)\n    self._BUILTINS = _BUILTINS\n</code></pre>"},{"location":"reference/commands/repl.html#bijux_cli.commands.repl.CommandCompleter.get_completions","title":"get_completions","text":"<pre><code>get_completions(\n    document: Document, _complete_event: CompleteEvent\n) -&gt; Iterator[Completion]\n</code></pre> <p>Yields completion suggestions for the current input.</p> <p>Parameters:</p> <ul> <li> <code>document</code>               (<code>Document</code>)           \u2013            <p>The current <code>prompt_toolkit</code> document.</p> </li> <li> <code>_complete_event</code>               (<code>CompleteEvent</code>)           \u2013            <p>The completion event (unused).</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Completion</code> (              <code>Completion</code> )          \u2013            <p>A <code>prompt_toolkit</code> <code>Completion</code> object.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def get_completions(  # pyright: ignore[reportIncompatibleMethodOverride]\n    self,\n    document: Document,\n    _complete_event: CompleteEvent,\n) -&gt; Iterator[Completion]:\n    \"\"\"Yields completion suggestions for the current input.\n\n    Args:\n        document (Document): The current `prompt_toolkit` document.\n        _complete_event (CompleteEvent): The completion event (unused).\n\n    Yields:\n        Completion: A `prompt_toolkit` `Completion` object.\n    \"\"\"\n    text = document.text_before_cursor\n    try:\n        words: list[str] = shlex.split(text)\n    except ValueError:\n        return\n    if text.endswith(\" \") or not text:\n        words.append(\"\")\n    current = words[-1]\n\n    found = False\n\n    if current.startswith(\"-\"):\n        for opt in GLOBAL_OPTS:\n            if opt.startswith(current):\n                found = True\n                yield Completion(opt, start_position=-len(current))\n\n    cmd_obj, _rem = self._find(words[:-1])\n    if cmd_obj is None:\n        for b in self._BUILTINS:\n            if b.startswith(current):\n                found = True\n                yield Completion(b, start_position=-len(current))\n\n    if cmd_obj is None:\n        for key in self._cmd_map:\n            if len(key) == 1 and key[0].startswith(current):\n                found = True\n                yield Completion(key[0], start_position=-len(current))\n        return\n\n    if isinstance(cmd_obj, typer.Typer):\n        names = [c.name for c in getattr(cmd_obj, \"registered_commands\", [])]\n        names += [g.name for g in getattr(cmd_obj, \"registered_groups\", [])]\n        for n in names:\n            if n.startswith(current):\n                found = True\n                yield Completion(n, start_position=-len(current))\n\n    if not isinstance(cmd_obj, typer.Typer) and hasattr(cmd_obj, \"params\"):\n        for param in cmd_obj.params:\n            for opt in (*param.opts, *(getattr(param, \"secondary_opts\", []) or [])):\n                if opt.startswith(current):\n                    found = True\n                    yield Completion(opt, start_position=-len(current))\n\n    if \"--help\".startswith(current):\n        found = True\n        yield Completion(\"--help\", start_position=-len(current))\n\n    if not found:\n        if (\n            len(words) &gt;= 3\n            and words[0] == \"config\"\n            and words[1] == \"set\"\n            and words[2] == \"\"\n        ):\n            yield Completion(\"KEY=VALUE\", display=\"KEY=VALUE\", start_position=0)\n        elif current == \"\":\n            yield Completion(\"DUMMY\", display=\"DUMMY\", start_position=0)\n</code></pre>"},{"location":"reference/commands/repl.html#bijux_cli.commands.repl.get_prompt","title":"get_prompt","text":"<pre><code>get_prompt() -&gt; str | ANSI\n</code></pre> <p>Returns the REPL prompt string.</p> <p>The prompt is styled with ANSI colors unless <code>NO_COLOR</code> or a test mode environment variable is set.</p> <p>Returns:</p> <ul> <li> <code>str | ANSI</code>           \u2013            <p>str | ANSI: The prompt string, which may include ANSI color codes.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>def get_prompt() -&gt; str | ANSI:\n    \"\"\"Returns the REPL prompt string.\n\n    The prompt is styled with ANSI colors unless `NO_COLOR` or a test mode\n    environment variable is set.\n\n    Returns:\n        str | ANSI: The prompt string, which may include ANSI color codes.\n    \"\"\"\n    if os.environ.get(\"BIJUXCLI_TEST_MODE\") == \"1\" or os.environ.get(\"NO_COLOR\") == \"1\":\n        return \"bijux&gt; \"\n    return ANSI(\"\\x1b[36mbijux&gt; \\x1b[0m\")\n</code></pre>"},{"location":"reference/commands/repl.html#bijux_cli.commands.repl.main","title":"main","text":"<pre><code>main(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"human\", \"-f\", \"--format\", help=HELP_FORMAT_HELP\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint for the <code>bijux repl</code> command.</p> <p>This function initializes the REPL environment. It validates flags, sets up signal handlers for clean shutdown, and dispatches to either the non-interactive (piped) mode or the interactive async prompt loop.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, forces non-interactive mode and suppresses prompts and command output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, enables verbose output for subcommands.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('human', '-f', '--format', help=HELP_FORMAT_HELP)</code> )           \u2013            <p>The desired output format. Only \"human\" is supported for the REPL itself.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, enables pretty-printing for subcommands.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics for subcommands.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/repl.py</code> <pre><code>@repl_app.callback(invoke_without_command=True)\ndef main(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"human\", \"-f\", \"--format\", help=HELP_FORMAT_HELP),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux repl` command.\n\n    This function initializes the REPL environment. It validates flags, sets\n    up signal handlers for clean shutdown, and dispatches to either the\n    non-interactive (piped) mode or the interactive async prompt loop.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, forces non-interactive mode and suppresses\n            prompts and command output.\n        verbose (bool): If True, enables verbose output for subcommands.\n        fmt (str): The desired output format. Only \"human\" is supported for\n            the REPL itself.\n        pretty (bool): If True, enables pretty-printing for subcommands.\n        debug (bool): If True, enables debug diagnostics for subcommands.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"repl\"\n    effective_include_runtime = (verbose or debug) and not quiet\n\n    fmt_lower = fmt.strip().lower()\n\n    if fmt_lower != \"human\":\n        validate_common_flags(\n            fmt_lower,\n            command,\n            quiet,\n            include_runtime=effective_include_runtime,\n        )\n        emit_error_and_exit(\n            \"REPL only supports human format.\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    for sig in (\n        signal.SIGINT,\n        signal.SIGTERM,\n        signal.SIGHUP,\n        signal.SIGQUIT,\n        signal.SIGUSR1,\n    ):\n        with suppress(Exception):\n            signal.signal(sig, _exit_on_signal)\n\n    if quiet or not sys.stdin.isatty():\n        _run_piped(quiet)\n    else:\n        try:\n            asyncio.get_event_loop()\n        except RuntimeError:\n            asyncio.set_event_loop(asyncio.new_event_loop())\n\n        asyncio.run(_run_interactive())\n</code></pre>"},{"location":"reference/commands/sleep.html","title":"Sleep Command API Reference","text":"<p>This section documents the internals of the <code>sleep</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/sleep.html#bijux_cli.commands.sleep","title":"bijux_cli.commands.sleep","text":"<p>Implements the <code>sleep</code> command for the Bijux CLI.</p> <p>This module provides a simple command to pause execution for a specified duration. It is primarily used for scripting, testing, or rate-limiting operations within automated workflows. The command returns a structured payload confirming the duration slept.</p> Output Contract <ul> <li>Success: <code>{\"slept\": float}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or configuration-related error.</li> <li><code>2</code>: Invalid argument (e.g., negative duration) or timeout exceeded.</li> </ul>"},{"location":"reference/commands/sleep.html#bijux_cli.commands.sleep.sleep","title":"sleep","text":"<pre><code>sleep(\n    ctx: Context,\n    seconds: float = Option(\n        ...,\n        \"--seconds\",\n        \"-s\",\n        help=\"Duration in seconds (must be \u2265 0)\",\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux sleep</code> command.</p> <p>This function validates the requested sleep duration against configuration limits, pauses execution, and then emits a structured payload confirming the duration.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>Option(..., '--seconds', '-s', help='Duration in seconds (must be \u2265 0)')</code> )           \u2013            <p>The duration in seconds to pause execution. Must be non-negative and not exceed the configured command timeout.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a contract-compliant status code and payload upon any error, such as a negative sleep duration or a timeout violation.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/sleep.py</code> <pre><code>@sleep_app.callback(invoke_without_command=True)\ndef sleep(\n    ctx: typer.Context,\n    seconds: float = typer.Option(\n        ..., \"--seconds\", \"-s\", help=\"Duration in seconds (must be \u2265 0)\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux sleep` command.\n\n    This function validates the requested sleep duration against configuration\n    limits, pauses execution, and then emits a structured payload confirming\n    the duration.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        seconds (float): The duration in seconds to pause execution. Must be\n            non-negative and not exceed the configured command timeout.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a contract-compliant status code and payload\n            upon any error, such as a negative sleep duration or a timeout\n            violation.\n    \"\"\"\n    command = \"sleep\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if seconds &lt; 0:\n        emit_error_and_exit(\n            \"sleep length must be non-negative\",\n            code=2,\n            failure=\"negative\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    cfg: ConfigProtocol = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        timeout = float(cfg.get(\"BIJUXCLI_COMMAND_TIMEOUT\", DEFAULT_COMMAND_TIMEOUT))\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to read timeout: {exc}\",\n            code=1,\n            failure=\"config\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if seconds &gt; timeout:\n        emit_error_and_exit(\n            \"Command timed out because sleep duration exceeded the configured timeout.\",\n            code=2,\n            failure=\"timeout\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    time.sleep(seconds)\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, seconds),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/status.html","title":"Status Command API Reference","text":"<p>This section documents the internals of the <code>status</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/status.html#bijux_cli.commands.status","title":"bijux_cli.commands.status","text":"<p>Implements the <code>status</code> command for the Bijux CLI.</p> <p>This module provides a lightweight \"liveness probe\" for the CLI, designed for health checks and monitoring. In its default mode, it performs a quick check and returns a simple \"ok\" status. It also supports a continuous \"watch\" mode that emits status updates at a regular interval.</p> Output Contract <ul> <li>Success:          <code>{\"status\": \"ok\"}</code></li> <li>Verbose:          Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Watch Mode Tick:  <code>{\"status\": \"ok\", \"ts\": float, ...}</code></li> <li>Watch Mode Stop:  <code>{\"status\": \"watch-stopped\", ...}</code></li> <li>Error:            <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or fatal error during execution.</li> <li><code>2</code>: Invalid argument (e.g., bad watch interval or format).</li> <li><code>3</code>: ASCII encoding error.</li> </ul>"},{"location":"reference/commands/status.html#bijux_cli.commands.status.status","title":"status","text":"<pre><code>status(\n    ctx: Context,\n    watch: float | None = Option(\n        None, \"--watch\", help=\"Poll every N seconds\"\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux status</code> command.</p> <p>This function orchestrates the status check. It validates flags and then dispatches to either the single-run logic or the continuous watch mode based on the presence of the <code>--watch</code> flag.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>watch</code>               (<code>float | None</code>, default:                   <code>Option(None, '--watch', help='Poll every N seconds')</code> )           \u2013            <p>If provided, enters watch mode, polling at this interval in seconds. Must be a positive number.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python and platform details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Watch mode only supports \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a contract-compliant status code and payload upon any error, such as an invalid watch interval.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/status.py</code> <pre><code>@status_app.callback(invoke_without_command=True)\ndef status(\n    ctx: typer.Context,\n    watch: float | None = typer.Option(None, \"--watch\", help=\"Poll every N seconds\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux status` command.\n\n    This function orchestrates the status check. It validates flags and then\n    dispatches to either the single-run logic or the continuous watch mode\n    based on the presence of the `--watch` flag.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        watch (float | None): If provided, enters watch mode, polling at this\n            interval in seconds. Must be a positive number.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python and platform details in the\n            output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Watch mode only\n            supports \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Exits with a contract-compliant status code and payload\n            upon any error, such as an invalid watch interval.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    emitter = DIContainer.current().resolve(EmitterProtocol)\n    telemetry = DIContainer.current().resolve(TelemetryProtocol)\n    command = \"status\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if watch is not None:\n        try:\n            interval = float(watch)\n            if interval &lt;= 0:\n                raise ValueError\n        except (ValueError, TypeError):\n            emit_error_and_exit(\n                \"Invalid watch interval: must be &gt; 0\",\n                code=2,\n                failure=\"interval\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n        _run_watch_mode(\n            command=command,\n            watch_interval=interval,\n            fmt=fmt_lower,\n            quiet=quiet,\n            verbose=verbose,\n            debug=debug,\n            effective_pretty=pretty,\n            include_runtime=verbose,\n            telemetry=telemetry,\n            emitter=emitter,\n        )\n    else:\n        new_run_command(\n            command_name=command,\n            payload_builder=lambda include: _build_payload(include),\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/utilities.html","title":"Utilities Command API Reference","text":"<p>This section documents the internals of the <code>utilities</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities","title":"bijux_cli.commands.utilities","text":"<p>Provides shared, reusable utilities for Bijux CLI commands.</p> <p>This module centralizes common logic to ensure consistency and reduce code duplication across the various command implementations. It includes a suite of functions for handling standard CLI tasks, such as:</p> <ul> <li>Validation: Functions for validating common CLI flags (like <code>--format</code>)     and checking the environment for non-ASCII characters or malformed     configuration files.</li> <li>Output &amp; Exit: A set of high-level emitters (<code>emit_and_exit</code>,     <code>emit_error_and_exit</code>) that handle payload serialization (JSON/YAML),     pretty-printing, and terminating the application with a contract-compliant     exit code and structured message.</li> <li>Command Orchestration: A primary helper (<code>new_run_command</code>) that     encapsulates the standard lifecycle of a command: validation, payload     construction, and emission.</li> <li>Parsing &amp; Sanitization: Helpers for sanitizing strings to be ASCII-safe     and a pre-parser for global flags (<code>--quiet</code>, <code>--debug</code>, etc.) that     operates before Typer's main dispatch.</li> <li>Plugin Management: Utilities for discovering and listing installed     plugins from the filesystem.</li> </ul>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.ascii_safe","title":"ascii_safe","text":"<pre><code>ascii_safe(text: Any, _field: str = '') -&gt; str\n</code></pre> <p>Converts any value to a string containing only printable ASCII characters.</p> <p>Non-ASCII characters are replaced with '?'. Newlines, carriage returns, and tabs are preserved.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>Any</code>)           \u2013            <p>The value to sanitize.</p> </li> <li> <code>_field</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An unused parameter for potential future use in context or telemetry. Defaults to \"\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>An ASCII-safe string.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def ascii_safe(text: Any, _field: str = \"\") -&gt; str:\n    \"\"\"Converts any value to a string containing only printable ASCII characters.\n\n    Non-ASCII characters are replaced with '?'. Newlines, carriage returns,\n    and tabs are preserved.\n\n    Args:\n        text (Any): The value to sanitize.\n        _field (str, optional): An unused parameter for potential future use\n            in context or telemetry. Defaults to \"\".\n\n    Returns:\n        str: An ASCII-safe string.\n    \"\"\"\n    text_str = text if isinstance(text, str) else str(text)\n\n    return \"\".join(\n        ch if (32 &lt;= ord(ch) &lt;= 126) or ch in _ALLOWED_CTRL else \"?\" for ch in text_str\n    )\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.contains_non_ascii_env","title":"contains_non_ascii_env","text":"<pre><code>contains_non_ascii_env() -&gt; bool\n</code></pre> <p>Checks for non-ASCII characters in the CLI's environment.</p> <p>This function returns True if any of the following are detected: * The <code>BIJUXCLI_CONFIG</code> environment variable contains non-ASCII characters. * The file path pointed to by <code>BIJUXCLI_CONFIG</code> exists and its contents     cannot be decoded as ASCII. * Any environment variable with a name starting with <code>BIJUXCLI_</code> has a     value containing non-ASCII characters.</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a non-ASCII condition is found, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def contains_non_ascii_env() -&gt; bool:\n    \"\"\"Checks for non-ASCII characters in the CLI's environment.\n\n    This function returns True if any of the following are detected:\n    * The `BIJUXCLI_CONFIG` environment variable contains non-ASCII characters.\n    * The file path pointed to by `BIJUXCLI_CONFIG` exists and its contents\n        cannot be decoded as ASCII.\n    * Any environment variable with a name starting with `BIJUXCLI_` has a\n        value containing non-ASCII characters.\n\n    Returns:\n        bool: True if a non-ASCII condition is found, otherwise False.\n    \"\"\"\n    config_path_str = os.environ.get(\"BIJUXCLI_CONFIG\")\n    if config_path_str:\n        if not config_path_str.isascii():\n            return True\n        config_path = Path(config_path_str)\n        if config_path.exists():\n            try:\n                config_path.read_text(encoding=\"ascii\")\n            except UnicodeDecodeError:\n                return True\n            except (IsADirectoryError, PermissionError, FileNotFoundError, OSError):\n                pass\n\n    for k, v in os.environ.items():\n        if k.startswith(\"BIJUXCLI_\") and not v.isascii():\n            return True\n    return False\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.emit_and_exit","title":"emit_and_exit","text":"<pre><code>emit_and_exit(\n    payload: Mapping[str, Any],\n    fmt: OutputFormat,\n    effective_pretty: bool,\n    verbose: bool,\n    debug: bool,\n    quiet: bool,\n    command: str,\n    *,\n    exit_code: int = 0,\n) -&gt; NoReturn\n</code></pre> <p>Serializes and emits a payload, records history, and exits.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Mapping[str, Any]</code>)           \u2013            <p>The data to serialize and print.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The output format (JSON or YAML).</p> </li> <li> <code>effective_pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime info in history records.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, emits a diagnostic message to stderr.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses all output and exits immediately.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The command name, used for history tracking.</p> </li> <li> <code>exit_code</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The exit status code to use.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with <code>exit_code</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def emit_and_exit(\n    payload: Mapping[str, Any],\n    fmt: OutputFormat,\n    effective_pretty: bool,\n    verbose: bool,\n    debug: bool,\n    quiet: bool,\n    command: str,\n    *,\n    exit_code: int = 0,\n) -&gt; NoReturn:\n    \"\"\"Serializes and emits a payload, records history, and exits.\n\n    Args:\n        payload (Mapping[str, Any]): The data to serialize and print.\n        fmt (OutputFormat): The output format (JSON or YAML).\n        effective_pretty (bool): If True, pretty-prints the output.\n        verbose (bool): If True, includes runtime info in history records.\n        debug (bool): If True, emits a diagnostic message to stderr.\n        quiet (bool): If True, suppresses all output and exits immediately.\n        command (str): The command name, used for history tracking.\n        exit_code (int): The exit status code to use.\n\n    Raises:\n        SystemExit: Always exits the process with `exit_code`.\n    \"\"\"\n    if (not quiet) and (not command.startswith(\"history\")):\n        try:\n            from bijux_cli.contracts import HistoryProtocol\n            from bijux_cli.core.di import DIContainer\n\n            hist = DIContainer.current().resolve(HistoryProtocol)\n            hist.add(\n                command=command,\n                params=[],\n                success=(exit_code == 0),\n                return_code=exit_code,\n                duration_ms=0.0,\n            )\n        except PermissionError as exc:\n            print(f\"Permission denied writing history: {exc}\", file=sys.stderr)\n        except OSError as exc:\n            import errno as _errno\n\n            if exc.errno in (_errno.EACCES, _errno.EPERM):\n                print(f\"Permission denied writing history: {exc}\", file=sys.stderr)\n            elif exc.errno in (_errno.ENOSPC, _errno.EDQUOT):\n                print(\n                    f\"No space left on device while writing history: {exc}\",\n                    file=sys.stderr,\n                )\n            else:\n                print(f\"Error writing history: {exc}\", file=sys.stderr)\n        except Exception as exc:\n            print(f\"Error writing history: {exc}\", file=sys.stderr)\n\n    if quiet:\n        sys.exit(exit_code)\n\n    if debug:\n        print(\"Diagnostics: emitted payload\", file=sys.stderr)\n\n    indent = 2 if effective_pretty else None\n    if fmt == OutputFormat.JSON:\n        separators = (\", \", \": \") if effective_pretty else (\",\", \":\")\n        output = json.dumps(payload, indent=indent, separators=separators)\n    else:\n        default_flow_style = None if effective_pretty else True\n        output = yaml.safe_dump(\n            payload,\n            indent=indent,\n            sort_keys=False,\n            default_flow_style=default_flow_style,\n        )\n    cleaned = output.rstrip(\"\\n\")\n    print(cleaned)\n    sys.exit(exit_code)\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.emit_error_and_exit","title":"emit_error_and_exit","text":"<pre><code>emit_error_and_exit(\n    message: str,\n    code: int,\n    failure: str,\n    command: str | None = None,\n    fmt: str | None = None,\n    quiet: bool = False,\n    include_runtime: bool = False,\n    debug: bool = False,\n    extra: dict[str, Any] | None = None,\n) -&gt; NoReturn\n</code></pre> <p>Emits a structured error payload to stderr and exits the process.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The primary error message.</p> </li> <li> <code>code</code>               (<code>int</code>)           \u2013            <p>The exit status code.</p> </li> <li> <code>failure</code>               (<code>str</code>)           \u2013            <p>A short, machine-readable failure code.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The command name where the error occurred.</p> </li> <li> <code>fmt</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format context.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses all output and exits immediately.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, adds runtime info to the error payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, prints a full traceback to stderr.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to merge into the payload.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with the specified <code>code</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def emit_error_and_exit(\n    message: str,\n    code: int,\n    failure: str,\n    command: str | None = None,\n    fmt: str | None = None,\n    quiet: bool = False,\n    include_runtime: bool = False,\n    debug: bool = False,\n    extra: dict[str, Any] | None = None,\n) -&gt; NoReturn:\n    \"\"\"Emits a structured error payload to stderr and exits the process.\n\n    Args:\n        message (str): The primary error message.\n        code (int): The exit status code.\n        failure (str): A short, machine-readable failure code.\n        command (str | None): The command name where the error occurred.\n        fmt (str | None): The output format context.\n        quiet (bool): If True, suppresses all output and exits immediately.\n        include_runtime (bool): If True, adds runtime info to the error payload.\n        debug (bool): If True, prints a full traceback to stderr.\n        extra (dict[str, Any] | None): Additional fields to merge into the payload.\n\n    Raises:\n        SystemExit: Always exits the process with the specified `code`.\n    \"\"\"\n    if quiet:\n        sys.exit(code)\n\n    if debug:\n        import traceback\n\n        traceback.print_exc(file=sys.stderr)\n\n    error_payload = {\"error\": message, \"code\": code}\n    if failure:\n        error_payload[\"failure\"] = failure\n    if command:\n        error_payload[\"command\"] = command\n    if fmt:\n        error_payload[\"fmt\"] = fmt\n    if extra:\n        error_payload.update(extra)\n    if include_runtime:\n        error_payload[\"python\"] = ascii_safe(sys.version.split()[0], \"python_version\")\n        error_payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        error_payload[\"timestamp\"] = str(time.time())\n\n    try:\n        output = json.dumps(error_payload).rstrip(\"\\n\")\n        print(output, file=sys.stderr, flush=True)\n    except Exception:\n        print('{\"error\": \"Unserializable error\"}', file=sys.stderr, flush=True)\n    sys.exit(code)\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.handle_list_plugins","title":"handle_list_plugins","text":"<pre><code>handle_list_plugins(\n    command: str,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None\n</code></pre> <p>Handles the logic for commands that list installed plugins.</p> <p>This function serves as a common handler for <code>plugins list</code> and similar commands. It retrieves the list of plugins and uses <code>new_run_command</code> to emit the result.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The name of the command being executed.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses normal output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in the payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def handle_list_plugins(\n    command: str,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Handles the logic for commands that list installed plugins.\n\n    This function serves as a common handler for `plugins list` and similar\n    commands. It retrieves the list of plugins and uses `new_run_command`\n    to emit the result.\n\n    Args:\n        command (str): The name of the command being executed.\n        quiet (bool): If True, suppresses normal output.\n        verbose (bool): If True, includes runtime metadata in the payload.\n        fmt (str): The requested output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug mode.\n\n    Returns:\n        None:\n    \"\"\"\n    format_lower = validate_common_flags(fmt, command, quiet)\n\n    try:\n        plugins = list_installed_plugins()\n    except RuntimeError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=1,\n            failure=\"dir_error\",\n            command=command,\n            fmt=format_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    else:\n\n        def _build_payload(include: bool) -&gt; dict[str, object]:\n            \"\"\"Constructs a payload describing installed plugins.\n\n            Args:\n                include (bool): If True, includes Python/platform info.\n\n            Returns:\n                dict[str, object]: A dictionary containing a \"plugins\" list\n                    and optional runtime metadata.\n            \"\"\"\n            payload: dict[str, object] = {\"plugins\": plugins}\n            if include:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=_build_payload,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=format_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.list_installed_plugins","title":"list_installed_plugins","text":"<pre><code>list_installed_plugins() -&gt; list[str]\n</code></pre> <p>Scans the plugins directory and returns a list of installed plugin names.</p> <p>A directory is considered a valid plugin if it is a direct child of the plugins directory and contains a <code>plugin.py</code> file.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A sorted list of valid plugin names.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the plugins directory is invalid, inaccessible, is not a directory, or contains a symlink loop.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def list_installed_plugins() -&gt; list[str]:\n    \"\"\"Scans the plugins directory and returns a list of installed plugin names.\n\n    A directory is considered a valid plugin if it is a direct child of the\n    plugins directory and contains a `plugin.py` file.\n\n    Returns:\n        list[str]: A sorted list of valid plugin names.\n\n    Raises:\n        RuntimeError: If the plugins directory is invalid, inaccessible,\n            is not a directory, or contains a symlink loop.\n    \"\"\"\n    plugins_dir = get_plugins_dir()\n\n    try:\n        resolved = plugins_dir.resolve(strict=True)\n    except FileNotFoundError:\n        return []\n    except RuntimeError as e:\n        raise RuntimeError(f\"Symlink loop detected at '{plugins_dir}'.\") from e\n    except Exception as exc:\n        raise RuntimeError(\n            f\"Plugins directory '{plugins_dir}' invalid or inaccessible.\"\n        ) from exc\n\n    if not resolved.is_dir():\n        raise RuntimeError(f\"Plugins directory '{plugins_dir}' is not a directory.\")\n\n    plugins: list[str] = []\n    for entry in resolved.iterdir():\n        with suppress(Exception):\n            p = entry.resolve()\n            if p.is_dir() and (p / \"plugin.py\").is_file():\n                plugins.append(entry.name)\n\n    plugins.sort()\n    return plugins\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.new_run_command","title":"new_run_command","text":"<pre><code>new_run_command(\n    command_name: str,\n    payload_builder: Callable[[bool], Mapping[str, object]],\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n    exit_code: int = 0,\n) -&gt; NoReturn\n</code></pre> <p>Orchestrates the standard execution flow of a CLI command.</p> <p>This function handles dependency resolution, validation, payload construction, and final emission, ensuring a consistent lifecycle for all commands that use it.</p> <p>Parameters:</p> <ul> <li> <code>command_name</code>               (<code>str</code>)           \u2013            <p>The name of the command for telemetry/error context.</p> </li> <li> <code>payload_builder</code>               (<code>Callable[[bool], Mapping[str, object]]</code>)           \u2013            <p>A function that takes a boolean <code>include_runtime</code> and returns the command's structured output payload.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses normal output.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug-level output.</p> </li> <li> <code>exit_code</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The exit code to use on successful execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with the given <code>exit_code</code> or an appropriate error code on failure.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def new_run_command(\n    command_name: str,\n    payload_builder: Callable[[bool], Mapping[str, object]],\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n    exit_code: int = 0,\n) -&gt; NoReturn:\n    \"\"\"Orchestrates the standard execution flow of a CLI command.\n\n    This function handles dependency resolution, validation, payload\n    construction, and final emission, ensuring a consistent lifecycle for all\n    commands that use it.\n\n    Args:\n        command_name (str): The name of the command for telemetry/error context.\n        payload_builder: A function that takes a boolean `include_runtime` and\n            returns the command's structured output payload.\n        quiet (bool): If True, suppresses normal output.\n        verbose (bool): If True, includes runtime metadata in the output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug-level output.\n        exit_code (int): The exit code to use on successful execution.\n\n    Raises:\n        SystemExit: Always exits the process with the given `exit_code` or an\n            appropriate error code on failure.\n    \"\"\"\n    from bijux_cli.contracts import EmitterProtocol, TelemetryProtocol\n    from bijux_cli.core.di import DIContainer\n\n    DIContainer.current().resolve(EmitterProtocol)\n    DIContainer.current().resolve(TelemetryProtocol)\n\n    include_runtime = verbose or debug\n\n    format_lower = validate_common_flags(\n        fmt,\n        command_name,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    output_format = OutputFormat.YAML if format_lower == \"yaml\" else OutputFormat.JSON\n    effective_pretty = debug or pretty\n\n    try:\n        payload = payload_builder(include_runtime)\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command_name,\n            fmt=output_format,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    else:\n        emit_and_exit(\n            payload=payload,\n            fmt=output_format,\n            effective_pretty=effective_pretty,\n            verbose=verbose,\n            debug=debug,\n            quiet=quiet,\n            command=command_name,\n            exit_code=exit_code,\n        )\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.normalize_format","title":"normalize_format","text":"<pre><code>normalize_format(fmt: str | None) -&gt; str\n</code></pre> <p>Normalizes a format string to lowercase and removes whitespace.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str | None</code>)           \u2013            <p>The format string to normalize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The normalized format string, or an empty string if input is None.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def normalize_format(fmt: str | None) -&gt; str:\n    \"\"\"Normalizes a format string to lowercase and removes whitespace.\n\n    Args:\n        fmt (str | None): The format string to normalize.\n\n    Returns:\n        str: The normalized format string, or an empty string if input is None.\n    \"\"\"\n    return (fmt or \"\").strip().lower()\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.parse_global_flags","title":"parse_global_flags","text":"<pre><code>parse_global_flags() -&gt; dict[str, Any]\n</code></pre> <p>Parses global CLI flags from <code>sys.argv</code> before Typer dispatch.</p> <p>This function inspects and consumes known global flags, rewriting <code>sys.argv</code> to contain only the remaining arguments. This allows global settings to be processed independently of the command-specific parsing done by Typer.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary of parsed flag values, such as <code>help</code>, <code>quiet</code>, <code>debug</code>, <code>verbose</code>, <code>format</code>, and <code>pretty</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>If a flag requires an argument that is missing (e.g., <code>--format</code> with no value).</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def parse_global_flags() -&gt; dict[str, Any]:\n    \"\"\"Parses global CLI flags from `sys.argv` before Typer dispatch.\n\n    This function inspects and consumes known global flags, rewriting `sys.argv`\n    to contain only the remaining arguments. This allows global settings to be\n    processed independently of the command-specific parsing done by Typer.\n\n    Returns:\n        dict[str, Any]: A dictionary of parsed flag values, such as `help`,\n            `quiet`, `debug`, `verbose`, `format`, and `pretty`.\n\n    Raises:\n        SystemExit: If a flag requires an argument that is missing (e.g.,\n            `--format` with no value).\n    \"\"\"\n    argv = sys.argv[1:]\n    flags: dict[str, Any] = {\n        \"help\": False,\n        \"quiet\": False,\n        \"debug\": False,\n        \"verbose\": False,\n        \"format\": \"json\",\n        \"pretty\": True,\n    }\n    retained: list[str] = []\n\n    def _bail(msg: str, failure: str) -&gt; NoReturn:\n        \"\"\"Emits a standardized error and exits with code 2.\n\n        Args:\n            msg (str): The error message to report.\n            failure (str): A short failure code (e.g., \"missing_argument\").\n\n        Raises:\n            SystemExit: Always exits the process.\n        \"\"\"\n        emit_error_and_exit(\n            msg,\n            code=2,\n            failure=failure,\n            command=\"global\",\n            fmt=flags[\"format\"],\n            quiet=flags[\"quiet\"],\n            include_runtime=flags[\"verbose\"],\n            debug=flags[\"debug\"],\n        )\n\n    i = 0\n    while i &lt; len(argv):\n        tok = argv[i]\n\n        if tok in (\"-h\", \"--help\"):\n            flags[\"help\"] = True\n            retained.append(tok)\n            i += 1\n        elif tok in (\"-q\", \"--quiet\"):\n            flags[\"quiet\"] = True\n            i += 1\n        elif tok == \"--debug\":\n            flags[\"debug\"] = True\n            flags[\"verbose\"] = True\n            flags[\"pretty\"] = True\n            i += 1\n        elif tok in (\"-v\", \"--verbose\"):\n            flags[\"verbose\"] = True\n            i += 1\n        elif tok == \"--pretty\":\n            flags[\"pretty\"] = True\n            i += 1\n        elif tok == \"--no-pretty\":\n            flags[\"pretty\"] = False\n            i += 1\n        elif tok in (\"-f\", \"--format\"):\n            i += 1\n            if i &gt;= len(argv):\n                _bail(\"Missing argument for --format\", \"missing_argument\")\n            else:\n                value = argv[i].lower()\n                flags[\"format\"] = value\n                if flags[\"help\"]:\n                    retained.append(tok.lstrip(\"-\"))\n                    retained.append(argv[i])\n                if not flags[\"help\"] and value not in (\"json\", \"yaml\"):\n                    _bail(f\"Unsupported format: {value}\", \"invalid_format\")\n                i += 1\n        else:\n            retained.append(tok)\n            i += 1\n\n    if flags[\"help\"]:\n        retained = [\n            arg.lstrip(\"-\") if arg.startswith(\"-\") and arg not in KNOWN else arg\n            for arg in retained\n        ]\n\n    sys.argv = [sys.argv[0], *retained]\n    return flags\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.validate_common_flags","title":"validate_common_flags","text":"<pre><code>validate_common_flags(\n    fmt: str,\n    command: str,\n    quiet: bool,\n    include_runtime: bool = False,\n) -&gt; str\n</code></pre> <p>Validates common CLI flags and environment settings.</p> <p>This function ensures the format is supported and the environment is ASCII-safe, exiting with a structured error if validation fails.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The name of the command for error reporting context.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses output on error before exiting.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, includes runtime info in error payloads.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The validated and normalized format string (\"json\" or \"yaml\").</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with code 2 for an unsupported format or 3 for a non-ASCII environment.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def validate_common_flags(\n    fmt: str,\n    command: str,\n    quiet: bool,\n    include_runtime: bool = False,\n) -&gt; str:\n    \"\"\"Validates common CLI flags and environment settings.\n\n    This function ensures the format is supported and the environment is\n    ASCII-safe, exiting with a structured error if validation fails.\n\n    Args:\n        fmt (str): The requested output format.\n        command (str): The name of the command for error reporting context.\n        quiet (bool): If True, suppresses output on error before exiting.\n        include_runtime (bool): If True, includes runtime info in error payloads.\n\n    Returns:\n        str: The validated and normalized format string (\"json\" or \"yaml\").\n\n    Raises:\n        SystemExit: Exits with code 2 for an unsupported format or 3 for\n            a non-ASCII environment.\n    \"\"\"\n    format_lower = (fmt or \"\").lower()\n    if format_lower not in (\"json\", \"yaml\"):\n        emit_error_and_exit(\n            f\"Unsupported format: {fmt}\",\n            code=2,\n            failure=\"format\",\n            command=command,\n            fmt=format_lower or \"json\",\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=False,\n        )\n\n    if contains_non_ascii_env():\n        emit_error_and_exit(\n            \"Non-ASCII in configuration or environment\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=format_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=False,\n        )\n\n    return format_lower\n</code></pre>"},{"location":"reference/commands/utilities.html#bijux_cli.commands.utilities.validate_env_file_if_present","title":"validate_env_file_if_present","text":"<pre><code>validate_env_file_if_present(path_str: str) -&gt; None\n</code></pre> <p>Validates the syntax of an environment configuration file if it exists.</p> <p>Checks that every non-comment, non-blank line conforms to a <code>KEY=VALUE</code> pattern.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>The path to the environment file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the file cannot be read or contains a malformed line.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/utilities.py</code> <pre><code>def validate_env_file_if_present(path_str: str) -&gt; None:\n    \"\"\"Validates the syntax of an environment configuration file if it exists.\n\n    Checks that every non-comment, non-blank line conforms to a `KEY=VALUE`\n    pattern.\n\n    Args:\n        path_str (str): The path to the environment file.\n\n    Raises:\n        ValueError: If the file cannot be read or contains a malformed line.\n    \"\"\"\n    if not path_str or not Path(path_str).exists():\n        return\n    try:\n        text = Path(path_str).read_text(encoding=\"utf-8\", errors=\"strict\")\n    except Exception as exc:\n        raise ValueError(f\"Cannot read config file: {exc}\") from exc\n\n    for i, line in enumerate(text.splitlines(), start=1):\n        s = line.strip()\n        if s and not s.startswith(\"#\") and not _ENV_LINE_RX.match(s):\n            raise ValueError(f\"Malformed line {i} in config: {line!r}\")\n</code></pre>"},{"location":"reference/commands/version.html","title":"Version Command API Reference","text":"<p>This section documents the internals of the <code>version</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/version.html#bijux_cli.commands.version","title":"bijux_cli.commands.version","text":"<p>Implements the <code>version</code> command for the Bijux CLI.</p> <p>This module reports the CLI's version and runtime environment information. The output is machine-readable, available in JSON or YAML, and is designed to be safe for automation and scripting by adhering to a strict output contract and ASCII hygiene.</p> Output Contract <ul> <li>Success: <code>{\"version\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str, \"timestamp\": float}</code>.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: Internal or fatal error.</li> <li><code>2</code>: CLI argument, flag, or format error.</li> <li><code>3</code>: ASCII or encoding error.</li> </ul>"},{"location":"reference/commands/version.html#bijux_cli.commands.version.version","title":"version","text":"<pre><code>version(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint and logic for the <code>bijux version</code> command.</p> <p>This function orchestrates the version reporting process by validating flags and then using the shared <code>new_run_command</code> helper to build and emit the final payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output; the exit code is the primary indicator of the outcome.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python, platform, and timestamp details in the output payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, either \"json\" or \"yaml\". Defaults to \"json\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output for human readability.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics, implying <code>verbose</code> and <code>pretty</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/version.py</code> <pre><code>@version_app.callback(invoke_without_command=True)\ndef version(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint and logic for the `bijux version` command.\n\n    This function orchestrates the version reporting process by validating\n    flags and then using the shared `new_run_command` helper to build and\n    emit the final payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output; the exit code is the\n            primary indicator of the outcome.\n        verbose (bool): If True, includes Python, platform, and timestamp\n            details in the output payload.\n        fmt (str): The output format, either \"json\" or \"yaml\". Defaults to \"json\".\n        pretty (bool): If True, pretty-prints the output for human readability.\n        debug (bool): If True, enables debug diagnostics, implying `verbose`\n            and `pretty`.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    DIContainer.current().resolve(EmitterProtocol)\n    DIContainer.current().resolve(TelemetryProtocol)\n    command = \"version\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/index.html","title":"Reference / Commands / Config Index","text":"<ul> <li>Clear Command</li> <li>Export Command</li> <li>Get Command</li> <li>List_cmd Command</li> <li>Load Command</li> <li>Reload Command</li> <li>Service Command</li> <li>Set Command</li> <li>Unset Command</li> </ul>"},{"location":"reference/commands/config/clear.html","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/clear.html#bijux_cli.commands.config.clear","title":"bijux_cli.commands.config.clear","text":"<p>Implements the <code>config clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for completely erasing all key-value pairs from the active configuration store. This action is irreversible and effectively resets the configuration to an empty state. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while clearing the configuration.</li> </ul>"},{"location":"reference/commands/config/clear.html#bijux_cli.commands.config.clear.clear_config","title":"clear_config","text":"<pre><code>clear_config(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Clears all configuration settings from the active store.</p> <p>This command erases all key-value pairs, effectively resetting the configuration. It emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/clear.py</code> <pre><code>def clear_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Clears all configuration settings from the active store.\n\n    This command erases all key-value pairs, effectively resetting the\n    configuration. It emits a structured payload to confirm the operation.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config clear\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear config: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration clear.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"cleared\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/export.html","title":"Export Command API Reference","text":"<p>This section documents the internals of the <code>export</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/export.html#bijux_cli.commands.config.export","title":"bijux_cli.commands.config.export","text":"<p>Implements the <code>config export</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for exporting the application's entire current configuration to a specified destination, which can be a file or standard output. The output format can be explicitly set to 'env', 'json', or 'yaml', or it can be inferred from the destination file's extension.</p> Output Contract <ul> <li>Success (to file):   <code>{\"status\": \"exported\", \"file\": str, \"format\": str}</code></li> <li>Success (to stdout): The raw exported configuration data is printed directly.</li> <li>Verbose (to file):   Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:               <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code> or <code>2</code>: An error occurred during the export process, such as a file   write error or invalid format request.</li> </ul>"},{"location":"reference/commands/config/export.html#bijux_cli.commands.config.export.export_config","title":"export_config","text":"<pre><code>export_config(\n    ctx: Context,\n    path: str = Argument(\n        ...,\n        help=\"Destination file \u2013 use \u201c-\u201d to write to STDOUT\",\n    ),\n    out_fmt: str = Option(\n        None,\n        \"--out-format\",\n        help=\"Force output format: env | json | yaml\",\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Exports the current configuration to a file or standard output.</p> <p>This function writes all configuration key-value pairs to a specified destination. If the destination is a file path, a structured JSON/YAML confirmation message is printed to stdout upon success. If the destination is \"-\", the raw exported configuration is printed directly to stdout.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Destination file \u2013 use \u201c-\u201d to write to STDOUT')</code> )           \u2013            <p>The destination file path, or \"-\" for standard output.</p> </li> <li> <code>out_fmt</code>               (<code>str</code>, default:                   <code>Option(None, '--out-format', help='Force output format: env | json | yaml')</code> )           \u2013            <p>The desired output format ('env', 'json', 'yaml'). If unspecified, it is inferred from the file extension.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the confirmation payload (file export only).</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The format for the confirmation payload (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the confirmation payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/export.py</code> <pre><code>def export_config(\n    ctx: typer.Context,\n    path: str = typer.Argument(\n        ..., help=\"Destination file \u2013 use \u201c-\u201d to write to STDOUT\"\n    ),\n    out_fmt: str = typer.Option(\n        None, \"--out-format\", help=\"Force output format: env | json | yaml\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Exports the current configuration to a file or standard output.\n\n    This function writes all configuration key-value pairs to a specified\n    destination. If the destination is a file path, a structured JSON/YAML\n    confirmation message is printed to stdout upon success. If the destination\n    is \"-\", the raw exported configuration is printed directly to stdout.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        path (str): The destination file path, or \"-\" for standard output.\n        out_fmt (str): The desired output format ('env', 'json', 'yaml'). If\n            unspecified, it is inferred from the file extension.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the\n            confirmation payload (file export only).\n        fmt (str): The format for the confirmation payload (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the confirmation payload.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config export\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.export(path, out_fmt)\n    except CommandError as exc:\n        code = 2 if getattr(exc, \"http_status\", 0) == 400 else 1\n        emit_error_and_exit(\n            f\"Failed to export config: {exc}\",\n            code=code,\n            failure=\"export_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if path != \"-\":\n\n        def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n            \"\"\"Builds the payload confirming a successful export to a file.\n\n            Args:\n                include_runtime (bool): If True, includes Python and platform info.\n\n            Returns:\n                dict[str, object]: The structured payload.\n            \"\"\"\n            payload: dict[str, object] = {\n                \"status\": \"exported\",\n                \"file\": path,\n                \"format\": out_fmt or \"auto\",\n            }\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/config/get.html","title":"Get Command API Reference","text":"<p>This section documents the internals of the <code>get</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/get.html#bijux_cli.commands.config.get","title":"bijux_cli.commands.config.get","text":"<p>Implements the <code>config get</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for retrieving the value of a specific key from the active configuration store. It provides a structured, machine-readable response containing the value or an error if the key is not found.</p> Output Contract <ul> <li>Success: <code>{\"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> <li><code>2</code>: The specified key was not found in the configuration.</li> </ul>"},{"location":"reference/commands/config/get.html#bijux_cli.commands.config.get.get_config","title":"get_config","text":"<pre><code>get_config(\n    ctx: Context,\n    key: str = Argument(\n        ..., help=\"Configuration key to look up\"\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Retrieves the value for a given configuration key.</p> <p>This function fetches the value for the specified key from the configuration service and uses the <code>new_run_command</code> helper to emit it in a structured payload. It handles errors, such as the key not being found.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Configuration key to look up')</code> )           \u2013            <p>The configuration key whose value should be retrieved.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/get.py</code> <pre><code>def get_config(\n    ctx: typer.Context,\n    key: str = typer.Argument(..., help=\"Configuration key to look up\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Retrieves the value for a given configuration key.\n\n    This function fetches the value for the specified key from the configuration\n    service and uses the `new_run_command` helper to emit it in a structured\n    payload. It handles errors, such as the key not being found.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        key (str): The configuration key whose value should be retrieved.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config get\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        value = config_svc.get(key)\n    except CommandError as exc:\n        if str(exc).startswith(\"Config key not found\"):\n            emit_error_and_exit(\n                f\"Config key not found: {key}\",\n                code=2,\n                failure=\"not_found\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n                extra={\"key\": key},\n            )\n        emit_error_and_exit(\n            f\"Failed to get config: {exc}\",\n            code=1,\n            failure=\"get_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds a payload containing the retrieved configuration value.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: A dictionary containing the key's value and\n                optional runtime metadata.\n        \"\"\"\n        payload: dict[str, object] = {\"value\": value}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/list_cmd.html","title":"List_cmd Command API Reference","text":"<p>This section documents the internals of the <code>list_cmd</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/list_cmd.html#bijux_cli.commands.config.list_cmd","title":"bijux_cli.commands.config.list_cmd","text":"<p>Implements the <code>config list</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for listing all keys currently defined in the active configuration store. It retrieves the keys and presents them in a structured, machine-readable list format.</p> Output Contract <ul> <li>Success: <code>{\"items\": [{\"key\": str}, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> </ul>"},{"location":"reference/commands/config/list_cmd.html#bijux_cli.commands.config.list_cmd.list_config","title":"list_config","text":"<pre><code>list_config(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Lists all configuration keys from the active configuration store.</p> <p>This function retrieves all defined keys, sorts them, and then uses the <code>new_run_command</code> helper to emit them in a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/list_cmd.py</code> <pre><code>def list_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all configuration keys from the active configuration store.\n\n    This function retrieves all defined keys, sorts them, and then uses the\n    `new_run_command` helper to emit them in a structured payload.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config list\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        keys = config_svc.list_keys()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list config: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; Mapping[str, object]:\n        \"\"\"Builds a payload containing the list of configuration keys.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, object]: A dictionary containing a sorted list of\n                keys under an \"items\" field, plus optional runtime metadata.\n        \"\"\"\n        payload: dict[str, object] = {\n            \"items\": [{\"key\": k} for k in sorted(keys, key=str.lower)]\n        }\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/load.html","title":"Load Command API Reference","text":"<p>This section documents the internals of the <code>load</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/load.html#bijux_cli.commands.config.load","title":"bijux_cli.commands.config.load","text":"<p>Implements the <code>config load</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for replacing the application's entire configuration with the contents of a specified file. It discards any in-memory settings and loads the new configuration, emitting a structured confirmation upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"loaded\", \"file\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>2</code>: The specified file could not be found, read, or parsed.</li> </ul>"},{"location":"reference/commands/config/load.html#bijux_cli.commands.config.load.load_config","title":"load_config","text":"<pre><code>load_config(\n    ctx: Context,\n    path: str = Argument(..., help=\"Path to load from\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Loads configuration from a specified file.</p> <p>This function replaces the current in-memory configuration with the contents of the file at the given path. It provides a structured payload to confirm the operation was successful.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Path to load from')</code> )           \u2013            <p>The path to the configuration file to load.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/load.py</code> <pre><code>def load_config(\n    ctx: typer.Context,\n    path: str = typer.Argument(..., help=\"Path to load from\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Loads configuration from a specified file.\n\n    This function replaces the current in-memory configuration with the\n    contents of the file at the given path. It provides a structured payload\n    to confirm the operation was successful.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        path (str): The path to the configuration file to load.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config load\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.load(path)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to load config: {exc}\",\n            code=2,\n            failure=\"load_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"path\": path},\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration load.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"loaded\", \"file\": path}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/reload.html","title":"Reload Command API Reference","text":"<p>This section documents the internals of the <code>reload</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/reload.html#bijux_cli.commands.config.reload","title":"bijux_cli.commands.config.reload","text":"<p>Implements the <code>config reload</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for manually reloading the application's configuration from its source file on disk. It discards any in-memory settings and replaces them with the content of the configuration file, emitting a structured confirmation upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"reloaded\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>2</code>: The configuration file could not be read or parsed.</li> </ul>"},{"location":"reference/commands/config/reload.html#bijux_cli.commands.config.reload.reload_config","title":"reload_config","text":"<pre><code>reload_config(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Reloads the configuration from disk and emits a structured result.</p> <p>This function forces a refresh of the application's configuration from its persistent storage file. It is useful when the configuration has been modified externally. A success or error payload is always emitted.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/reload.py</code> <pre><code>def reload_config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Reloads the configuration from disk and emits a structured result.\n\n    This function forces a refresh of the application's configuration from its\n    persistent storage file. It is useful when the configuration has been\n    modified externally. A success or error payload is always emitted.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config reload\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.reload()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to reload config: {exc}\",\n            code=2,\n            failure=\"reload_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a successful configuration reload.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"reloaded\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/service.html","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/service.html#bijux_cli.commands.config.service","title":"bijux_cli.commands.config.service","text":"<p>Implements the root callback for the <code>bijux config</code> command group.</p> <p>This module defines the default action for the <code>bijux config</code> command. When invoked without a subcommand (like <code>get</code>, <code>set</code>, or <code>unset</code>), it lists all key-value pairs currently stored in the active configuration, presenting them in a structured, machine-readable format.</p> Output Contract <ul> <li>Success: <code>{\"KEY_1\": \"VALUE_1\", \"KEY_2\": \"VALUE_2\", ...}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> </ul>"},{"location":"reference/commands/config/service.html#bijux_cli.commands.config.service.config","title":"config","text":"<pre><code>config(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint for the <code>bijux config</code> command group.</p> <p>This function serves as the default action when <code>bijux config</code> is run without a subcommand. It retrieves and displays all key-value pairs from the current configuration. If a subcommand (<code>get</code>, <code>set</code>, etc.) is invoked, this function yields control to it.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/commands/config/service.py</code> <pre><code>def config(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux config` command group.\n\n    This function serves as the default action when `bijux config` is run\n    without a subcommand. It retrieves and displays all key-value pairs from\n    the current configuration. If a subcommand (`get`, `set`, etc.) is\n    invoked, this function yields control to it.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    fmt_lower = fmt.lower()\n\n    command = \"config\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload containing all configuration values.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: A dictionary of all configuration key-value\n                pairs and optional runtime metadata.\n        \"\"\"\n        data = config_svc.all()\n        payload: dict[str, object] = dict(data)\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/set.html","title":"Set Command API Reference","text":"<p>This section documents the internals of the <code>set</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/set.html#bijux_cli.commands.config.set","title":"bijux_cli.commands.config.set","text":"<p>Implements the <code>config set</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for creating or updating a key-value pair in the active configuration store. It accepts input either as a direct argument or from stdin, performs strict validation on keys and values, and provides a structured, machine-readable response.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"updated\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred, such as a file lock or write failure.</li> <li><code>2</code>: An invalid argument was provided (e.g., malformed pair, invalid key).</li> <li><code>3</code>: The key, value, or configuration path contained non-ASCII or forbidden   control characters.</li> </ul>"},{"location":"reference/commands/config/set.html#bijux_cli.commands.config.set.set_config","title":"set_config","text":"<pre><code>set_config(\n    ctx: Context,\n    pair: str | None = Argument(\n        None,\n        help=\"KEY=VALUE to set; if omitted, read from stdin\",\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Sets or updates a configuration key-value pair.</p> <p>This function orchestrates the <code>set</code> operation. It accepts a <code>KEY=VALUE</code> pair from either a command-line argument or standard input. It performs extensive validation on the key and value for format and content, handles file locking to prevent race conditions, and emits a structured payload confirming the update.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>pair</code>               (<code>str | None</code>, default:                   <code>Argument(None, help='KEY=VALUE to set; if omitted, read from stdin')</code> )           \u2013            <p>A string in \"KEY=VALUE\" format. If None, the pair is read from stdin.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/set.py</code> <pre><code>def set_config(\n    ctx: typer.Context,\n    pair: str | None = typer.Argument(\n        None, help=\"KEY=VALUE to set; if omitted, read from stdin\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Sets or updates a configuration key-value pair.\n\n    This function orchestrates the `set` operation. It accepts a `KEY=VALUE`\n    pair from either a command-line argument or standard input. It performs\n    extensive validation on the key and value for format and content, handles\n    file locking to prevent race conditions, and emits a structured payload\n    confirming the update.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        pair (str | None): A string in \"KEY=VALUE\" format. If None, the pair\n            is read from stdin.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    cfg_path = os.environ.get(\"BIJUXCLI_CONFIG\", \"\") or \"\"\n    if cfg_path:\n        try:\n            cfg_path.encode(\"ascii\")\n        except UnicodeEncodeError:\n            emit_error_and_exit(\n                \"Non-ASCII characters in config path\",\n                code=3,\n                failure=\"ascii\",\n                command=\"config set\",\n                fmt=\"json\",\n                quiet=False,\n                include_runtime=False,\n                debug=False,\n                extra={\"path\": \"[non-ascii path provided]\"},\n            )\n    flags = parse_global_flags()\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n    command = \"config set\"\n    if os.name == \"posix\":\n        with suppress(Exception):\n            import fcntl\n\n            with open(cfg_path, \"a+\") as fh:\n                try:\n                    fcntl.flock(fh, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                except OSError:\n                    emit_error_and_exit(\n                        \"Config file is locked\",\n                        code=1,\n                        failure=\"file_locked\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=include_runtime,\n                        debug=debug,\n                        extra={\"path\": cfg_path},\n                    )\n                finally:\n                    with suppress(Exception):\n                        fcntl.flock(fh, fcntl.LOCK_UN)\n    if pair is None:\n        if sys.stdin.isatty():\n            emit_error_and_exit(\n                \"Missing argument: KEY=VALUE required\",\n                code=2,\n                failure=\"missing_argument\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n        pair = sys.stdin.read().rstrip(\"\\n\")\n    if not pair or \"=\" not in pair:\n        emit_error_and_exit(\n            \"Invalid argument: KEY=VALUE required\",\n            code=2,\n            failure=\"invalid_argument\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    raw_key, raw_value = pair.split(\"=\", 1)\n    key = raw_key.strip()\n    service_value_str = raw_value\n    if len(service_value_str) &gt;= 2 and (\n        (service_value_str[0] == service_value_str[-1] == '\"')\n        or (service_value_str[0] == service_value_str[-1] == \"'\")\n    ):\n        import codecs\n\n        service_value_str = codecs.decode(service_value_str[1:-1], \"unicode_escape\")\n    if not key:\n        emit_error_and_exit(\n            \"Key cannot be empty\",\n            code=2,\n            failure=\"empty_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n    if not all(ord(c) &lt; 128 for c in key + service_value_str):\n        emit_error_and_exit(\n            \"Non-ASCII characters are not allowed in keys or values.\",\n            code=3,\n            failure=\"ascii_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    if not re.match(r\"^[A-Za-z0-9_]+$\", key):\n        emit_error_and_exit(\n            \"Invalid key: only alphanumerics and underscore allowed.\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    if not all(\n        c in string.printable and c not in \"\\r\\n\\t\\x0b\\x0c\" for c in service_value_str\n    ):\n        emit_error_and_exit(\n            \"Control characters are not allowed in config values.\",\n            code=3,\n            failure=\"control_char_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n    try:\n        config_svc.set(key, service_value_str)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to set config: {exc}\",\n            code=1,\n            failure=\"set_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a key was set or updated.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\n            \"status\": \"updated\",\n            \"key\": key,\n            \"value\": service_value_str,\n        }\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/config/unset.html","title":"Unset Command API Reference","text":"<p>This section documents the internals of the <code>unset</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/config/unset.html#bijux_cli.commands.config.unset","title":"bijux_cli.commands.config.unset","text":"<p>Implements the <code>config unset</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for removing a key-value pair from the active configuration store. It provides a structured, machine-readable response to confirm the deletion or report an error, such as if the key does not exist.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"deleted\", \"key\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred while accessing the configuration.</li> <li><code>2</code>: The specified key was not found in the configuration.</li> </ul>"},{"location":"reference/commands/config/unset.html#bijux_cli.commands.config.unset.unset_config","title":"unset_config","text":"<pre><code>unset_config(\n    ctx: Context,\n    key: str = Argument(..., help=\"Key to remove\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Removes a key from the active configuration store.</p> <p>This function orchestrates the <code>unset</code> operation. It manually parses global flags, resolves the configuration service, attempts to remove the specified key, and then uses the <code>new_run_command</code> helper to emit a structured payload confirming the action.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to remove')</code> )           \u2013            <p>The configuration key to remove.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing the error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/config/unset.py</code> <pre><code>def unset_config(\n    ctx: typer.Context,\n    key: str = typer.Argument(..., help=\"Key to remove\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes a key from the active configuration store.\n\n    This function orchestrates the `unset` operation. It manually parses global\n    flags, resolves the configuration service, attempts to remove the specified\n    key, and then uses the `new_run_command` helper to emit a structured\n    payload confirming the action.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        key (str): The configuration key to remove.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing the error.\n    \"\"\"\n    flags = parse_global_flags()\n\n    quiet = flags[\"quiet\"]\n    verbose = flags[\"verbose\"]\n    fmt = flags[\"format\"]\n    pretty = flags[\"pretty\"]\n    debug = flags[\"debug\"]\n\n    include_runtime = verbose\n    fmt_lower = fmt.lower()\n\n    command = \"config unset\"\n\n    config_svc = DIContainer.current().resolve(ConfigProtocol)\n\n    try:\n        config_svc.unset(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Config key not found: {key}\",\n            code=2,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n            extra={\"key\": key},\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to unset config: {exc}\",\n            code=1,\n            failure=\"unset_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; dict[str, object]:\n        \"\"\"Builds the payload confirming a key was deleted.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            dict[str, object]: The structured payload.\n        \"\"\"\n        payload: dict[str, object] = {\"status\": \"deleted\", \"key\": key}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/dev/index.html","title":"Reference / Commands / Dev Index","text":"<ul> <li>Di Command</li> <li>List_plugins Command</li> <li>Service Command</li> </ul>"},{"location":"reference/commands/dev/di.html","title":"Di Command API Reference","text":"<p>This section documents the internals of the <code>di</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/di.html#bijux_cli.commands.dev.di","title":"bijux_cli.commands.dev.di","text":"<p>Implements the <code>dev di</code> subcommand for the Bijux CLI.</p> <p>This module provides a developer-focused command to introspect the internal Dependency Injection (DI) container. It outputs a graph of all registered service and factory protocols, which is useful for debugging the application's architecture and service resolution.</p> Output Contract <ul> <li>Success: <code>{\"factories\": list, \"services\": list}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal internal error occurred (e.g., during serialization).</li> <li><code>2</code>: An invalid argument or environment setting was provided (e.g.,   bad output path, unreadable config, invalid limit).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/di.html#bijux_cli.commands.dev.di.dev_di_graph","title":"dev_di_graph","text":"<pre><code>dev_di_graph(\n    quiet: bool = QUIET_OPTION,\n    verbose: bool = VERBOSE_OPTION,\n    fmt: str = FORMAT_OPTION,\n    pretty: bool = PRETTY_OPTION,\n    debug: bool = DEBUG_OPTION,\n    output: list[Path] = OUTPUT_OPTION,\n) -&gt; None\n</code></pre> <p>Generates and outputs the Dependency Injection (DI) container graph.</p> <p>This developer tool inspects the DI container, validates environment settings, and outputs the registration graph to stdout and/or one or more files.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>QUIET_OPTION</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>VERBOSE_OPTION</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>FORMAT_OPTION</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>PRETTY_OPTION</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>DEBUG_OPTION</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> <li> <code>output</code>               (<code>list[Path]</code>, default:                   <code>OUTPUT_OPTION</code> )           \u2013            <p>A list of file paths to write the output to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/di.py</code> <pre><code>def dev_di_graph(\n    quiet: bool = QUIET_OPTION,\n    verbose: bool = VERBOSE_OPTION,\n    fmt: str = FORMAT_OPTION,\n    pretty: bool = PRETTY_OPTION,\n    debug: bool = DEBUG_OPTION,\n    output: list[Path] = OUTPUT_OPTION,\n) -&gt; None:\n    \"\"\"Generates and outputs the Dependency Injection (DI) container graph.\n\n    This developer tool inspects the DI container, validates environment\n    settings, and outputs the registration graph to stdout and/or one or more\n    files.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n        output (list[Path]): A list of file paths to write the output to.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"dev di\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    limit_env = os.environ.get(\"BIJUXCLI_DI_LIMIT\")\n    limit: int | None = None\n    if limit_env is not None:\n        try:\n            limit = int(limit_env)\n            if limit &lt; 0:\n                emit_error_and_exit(\n                    f\"Invalid BIJUXCLI_DI_LIMIT value: '{limit_env}'\",\n                    code=2,\n                    failure=\"limit\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n        except (ValueError, TypeError):\n            emit_error_and_exit(\n                f\"Invalid BIJUXCLI_DI_LIMIT value: '{limit_env}'\",\n                code=2,\n                failure=\"limit\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    config_env = os.environ.get(\"BIJUXCLI_CONFIG\")\n    if config_env and not config_env.isascii():\n        emit_error_and_exit(\n            f\"Config path contains non-ASCII characters: {config_env!r}\",\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    if config_env:\n        cfg_path = Path(config_env)\n        if cfg_path.exists() and not os.access(cfg_path, os.R_OK):\n            emit_error_and_exit(\n                f\"Config path not readable: {cfg_path}\",\n                code=2,\n                failure=\"config_unreadable\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=effective_include_runtime,\n                debug=debug,\n            )\n\n    try:\n        payload = _build_dev_di_payload(effective_include_runtime)\n        if limit is not None:\n            payload[\"factories\"] = payload[\"factories\"][:limit]\n            payload[\"services\"] = payload[\"services\"][:limit]\n    except ValueError as exc:\n        emit_error_and_exit(\n            str(exc),\n            code=3,\n            failure=\"ascii\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    outputs = output\n    if outputs:\n        for p in outputs:\n            if p.is_dir():\n                emit_error_and_exit(\n                    f\"Output path is a directory: {p}\",\n                    code=2,\n                    failure=\"output_dir\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n            p.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                if fmt_lower == \"json\":\n                    p.write_text(\n                        json.dumps(payload, indent=2 if effective_pretty else None)\n                        + \"\\n\",\n                        encoding=\"utf-8\",\n                    )\n                else:\n                    p.write_text(\n                        yaml.safe_dump(\n                            payload,\n                            default_flow_style=False,\n                            indent=2 if effective_pretty else None,\n                        ),\n                        encoding=\"utf-8\",\n                    )\n            except OSError as exc:\n                emit_error_and_exit(\n                    f\"Failed to write output file '{p}': {exc}\",\n                    code=2,\n                    failure=\"output_write\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=effective_include_runtime,\n                    debug=debug,\n                )\n\n        if quiet:\n            raise typer.Exit(0)\n\n    if os.environ.get(\"BIJUXCLI_TEST_FORCE_SERIALIZE_FAIL\") == \"1\":\n        emit_error_and_exit(\n            \"Forced serialization failure\",\n            code=1,\n            failure=\"serialize\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=effective_include_runtime,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda _: payload,\n        quiet=quiet,\n        verbose=effective_include_runtime,\n        fmt=fmt_lower,\n        pretty=effective_pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/dev/list_plugins.html","title":"List_plugins Command API Reference","text":"<p>This section documents the internals of the <code>list_plugins</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/list_plugins.html#bijux_cli.commands.dev.list_plugins","title":"bijux_cli.commands.dev.list_plugins","text":"<p>Implements the <code>dev list-plugins</code> subcommand for the Bijux CLI.</p> <p>This module provides a developer-focused command to list all installed CLI plugins. It delegates its core logic to the shared <code>handle_list_plugins</code> utility, which scans the filesystem and returns a structured list.</p> Output Contract <ul> <li>Success: <code>{\"plugins\": [str, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An error occurred while accessing the plugins directory.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/list_plugins.html#bijux_cli.commands.dev.list_plugins.dev_list_plugins","title":"dev_list_plugins","text":"<pre><code>dev_list_plugins(\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Lists all installed CLI plugins.</p> <p>This command acts as a wrapper around the shared <code>handle_list_plugins</code> utility to provide a consistent interface for developers.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/list_plugins.py</code> <pre><code>def dev_list_plugins(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all installed CLI plugins.\n\n    This command acts as a wrapper around the shared `handle_list_plugins`\n    utility to provide a consistent interface for developers.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"dev list-plugins\"\n\n    validate_common_flags(fmt, command, quiet)\n\n    handle_list_plugins(command, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/dev/service.html","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/dev/service.html#bijux_cli.commands.dev.service","title":"bijux_cli.commands.dev.service","text":"<p>Implements the root callback for the <code>bijux dev</code> command group.</p> <p>This module defines the default action for the <code>bijux dev</code> command. This command group is intended for developers of the CLI. When invoked without a subcommand, it provides a simple status confirmation.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\"}</code></li> <li>With Env Var: Adds <code>{\"mode\": str}</code> if <code>BIJUXCLI_DEV_MODE</code> is set.</li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An internal or unexpected error occurred.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/dev/service.html#bijux_cli.commands.dev.service.dev","title":"dev","text":"<pre><code>dev(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint for the <code>bijux dev</code> command group.</p> <p>This function serves as the default action when <code>bijux dev</code> is run without a subcommand. It emits a simple status payload. If a subcommand is invoked, this function yields control to it.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/dev/service.py</code> <pre><code>def dev(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux dev` command group.\n\n    This function serves as the default action when `bijux dev` is run\n    without a subcommand. It emits a simple status payload. If a subcommand\n    is invoked, this function yields control to it.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"dev\"\n    effective_include_runtime = (verbose or debug) and not quiet\n    effective_pretty = True if (debug and not quiet) else pretty\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=effective_include_runtime,\n    )\n\n    mode = os.environ.get(\"BIJUXCLI_DEV_MODE\")\n\n    def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload for the dev status command.\n\n        The payload indicates an \"ok\" status and includes optional mode and\n        runtime information based on the parent function's scope.\n\n        Args:\n            _ (bool): An unused parameter to match the expected signature of\n                the `payload_builder` in `new_run_command`.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"status\": \"ok\"}\n        if mode:\n            payload[\"mode\"] = mode\n        if effective_include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=effective_include_runtime,\n        fmt=fmt_lower,\n        pretty=effective_pretty,\n        debug=(debug and not quiet),\n    )\n</code></pre>"},{"location":"reference/commands/history/index.html","title":"Reference / Commands / History Index","text":"<ul> <li>Clear Command</li> <li>Service Command</li> </ul>"},{"location":"reference/commands/history/clear.html","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/history/clear.html#bijux_cli.commands.history.clear","title":"bijux_cli.commands.history.clear","text":"<p>Implements the <code>history clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently erasing all entries from the command history store. This action is irreversible. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\"}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred, such as the history service being   unavailable or a failure during the clear operation.</li> </ul>"},{"location":"reference/commands/history/clear.html#bijux_cli.commands.history.clear.clear_history","title":"clear_history","text":"<pre><code>clear_history(\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Erases all stored command history.</p> <p>This command permanently removes all entries from the history store and emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/clear.py</code> <pre><code>def clear_history(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Erases all stored command history.\n\n    This command permanently removes all entries from the history store and\n    emits a structured payload to confirm the operation.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"history clear\"\n    if debug:\n        verbose = True\n        pretty = True\n    include_runtime = verbose\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    history_svc = resolve_history_service(\n        command, fmt_lower, quiet, include_runtime, debug\n    )\n\n    try:\n        history_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear history: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def payload_builder(include_runtime: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload confirming the history was cleared.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"status\": \"cleared\"}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/history/clear.html#bijux_cli.commands.history.clear.resolve_history_service","title":"resolve_history_service","text":"<pre><code>resolve_history_service(\n    command: str,\n    fmt_lower: str,\n    quiet: bool,\n    include_runtime: bool,\n    debug: bool,\n) -&gt; HistoryProtocol\n</code></pre> <p>Resolves the HistoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"history clear\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HistoryProtocol</code> (              <code>HistoryProtocol</code> )          \u2013            <p>An instance of the history service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/clear.py</code> <pre><code>def resolve_history_service(\n    command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool\n) -&gt; HistoryProtocol:\n    \"\"\"Resolves the HistoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"history clear\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        HistoryProtocol: An instance of the history service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(HistoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"History service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/history/service.html","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/history/service.html#bijux_cli.commands.history.service","title":"bijux_cli.commands.history.service","text":"<p>Implements the <code>history</code> command for the Bijux CLI.</p> <p>This module provides functionality to interact with the persistent command history. It allows for listing, filtering, sorting, grouping, importing, and exporting history entries. All operations produce structured, machine-readable output.</p> <p>The command has three primary modes of operation: 1.  Listing (Default): When no import/export flags are used, it lists     history entries, which can be filtered, sorted, and grouped. 2.  Import: The <code>--import</code> flag replaces the current history with data     from a specified JSON file. 3.  Export: The <code>--export</code> flag writes the entire current history to a     specified JSON file.</p> Output Contract <ul> <li>List Success:   <code>{\"entries\": list}</code></li> <li>Import Success: <code>{\"status\": \"imported\", \"file\": str}</code></li> <li>Export Success: <code>{\"status\": \"exported\", \"file\": str}</code></li> <li>Verbose:        Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:          <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., history service unavailable).</li> <li><code>2</code>: An invalid argument was provided or an I/O error occurred during   import/export.</li> </ul>"},{"location":"reference/commands/history/service.html#bijux_cli.commands.history.service.history","title":"history","text":"<pre><code>history(\n    ctx: Context,\n    limit: int = Option(\n        20,\n        \"--limit\",\n        \"-l\",\n        help=\"Maximum number of entries (0 means none).\",\n    ),\n    group_by: str | None = Option(\n        None,\n        \"--group-by\",\n        \"-g\",\n        help=\"Group entries by a field (e.g., 'command').\",\n    ),\n    filter_cmd: str | None = Option(\n        None,\n        \"--filter\",\n        \"-F\",\n        help=\"Return only entries whose command contains TEXT.\",\n    ),\n    sort: str | None = Option(\n        None,\n        \"--sort\",\n        help=\"Sort key; currently only 'timestamp' is recognized.\",\n    ),\n    export_path: str = Option(\n        None,\n        \"--export\",\n        help=\"Write entire history to FILE (JSON). Overwrites.\",\n    ),\n    import_path: str = Option(\n        None,\n        \"--import\",\n        help=\"Load history from FILE (JSON), replacing current store.\",\n    ),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Lists, imports, or exports the command history.</p> <p>This function orchestrates all history-related operations. It first checks for an import or export action. If neither is specified, it proceeds to list the history, applying any specified filtering, grouping, or sorting.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>limit</code>               (<code>int</code>, default:                   <code>Option(20, '--limit', '-l', help='Maximum number of entries (0 means none).')</code> )           \u2013            <p>The maximum number of entries to return for a list operation.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>Option(None, '--group-by', '-g', help=\"Group entries by a field (e.g., 'command').\")</code> )           \u2013            <p>The field to group history entries by ('command').</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>Option(None, '--filter', '-F', help='Return only entries whose command contains TEXT.')</code> )           \u2013            <p>A substring to filter command names by.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>Option(None, '--sort', help=\"Sort key; currently only 'timestamp' is recognized.\")</code> )           \u2013            <p>The key to sort entries by ('timestamp').</p> </li> <li> <code>export_path</code>               (<code>str</code>, default:                   <code>Option(None, '--export', help='Write entire history to FILE (JSON). Overwrites.')</code> )           \u2013            <p>The path to export history to. This is an exclusive action.</p> </li> <li> <code>import_path</code>               (<code>str</code>, default:                   <code>Option(None, '--import', help='Load history from FILE (JSON), replacing current store.')</code> )           \u2013            <p>The path to import history from. This is an exclusive action.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format (\"json\" or \"yaml\").</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/service.py</code> <pre><code>def history(\n    ctx: typer.Context,\n    limit: int = typer.Option(\n        20, \"--limit\", \"-l\", help=\"Maximum number of entries (0 means none).\"\n    ),\n    group_by: str | None = typer.Option(\n        None, \"--group-by\", \"-g\", help=\"Group entries by a field (e.g., 'command').\"\n    ),\n    filter_cmd: str | None = typer.Option(\n        None, \"--filter\", \"-F\", help=\"Return only entries whose command contains TEXT.\"\n    ),\n    sort: str | None = typer.Option(\n        None, \"--sort\", help=\"Sort key; currently only 'timestamp' is recognized.\"\n    ),\n    export_path: str = typer.Option(\n        None, \"--export\", help=\"Write entire history to FILE (JSON). Overwrites.\"\n    ),\n    import_path: str = typer.Option(\n        None, \"--import\", help=\"Load history from FILE (JSON), replacing current store.\"\n    ),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists, imports, or exports the command history.\n\n    This function orchestrates all history-related operations. It first checks\n    for an import or export action. If neither is specified, it proceeds to\n    list the history, applying any specified filtering, grouping, or sorting.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        limit (int): The maximum number of entries to return for a list operation.\n        group_by (str | None): The field to group history entries by ('command').\n        filter_cmd (str | None): A substring to filter command names by.\n        sort (str | None): The key to sort entries by ('timestamp').\n        export_path (str): The path to export history to. This is an exclusive action.\n        import_path (str): The path to import history from. This is an exclusive action.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format (\"json\" or \"yaml\").\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    if ctx.invoked_subcommand:\n        return\n\n    command = \"history\"\n    if debug:\n        verbose = True\n        pretty = True\n    include_runtime = verbose\n\n    fmt_lower = validate_common_flags(\n        fmt,\n        command,\n        quiet,\n        include_runtime=include_runtime,\n    )\n\n    history_svc = resolve_history_service(\n        command, fmt_lower, quiet, include_runtime, debug\n    )\n\n    if limit &lt; 0:\n        emit_error_and_exit(\n            \"Invalid value for --limit: must be non-negative.\",\n            code=2,\n            failure=\"limit\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if sort and sort != \"timestamp\":\n        emit_error_and_exit(\n            \"Invalid sort key: only 'timestamp' is supported.\",\n            code=2,\n            failure=\"sort\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if group_by and group_by != \"command\":\n        emit_error_and_exit(\n            \"Invalid group_by: only 'command' is supported.\",\n            code=2,\n            failure=\"group_by\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    if import_path:\n        try:\n            text = Path(import_path).read_text(encoding=\"utf-8\").strip()\n            data = json.loads(text or \"[]\")\n            if not isinstance(data, list):\n                raise ValueError(\"Import file must contain a JSON array.\")\n            history_svc.clear()\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n                cmd = str(item.get(\"command\") or item.get(\"cmd\", \"\"))\n                cmd = ascii_safe(cmd, \"command\")\n                if not cmd:\n                    continue\n                history_svc.add(\n                    command=cmd,\n                    params=item.get(\"params\", []),\n                    success=bool(item.get(\"success\", True)),\n                    return_code=item.get(\"return_code\", 0),\n                    duration_ms=item.get(\"duration_ms\", 0.0),\n                )\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to import history: {exc}\",\n                code=2,\n                failure=\"import_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n\n        def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n            \"\"\"Builds the payload confirming a successful import.\n\n            Args:\n                _ (bool): Unused parameter to match the expected signature.\n\n            Returns:\n                Mapping[str, Any]: The structured payload.\n            \"\"\"\n            payload: dict[str, Any] = {\"status\": \"imported\", \"file\": import_path}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n\n    if export_path:\n        try:\n            entries = history_svc.list()\n            Path(export_path).write_text(\n                json.dumps(entries, indent=2 if pretty else None) + \"\\n\",\n                encoding=\"utf-8\",\n            )\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to export history: {exc}\",\n                code=2,\n                failure=\"export_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=include_runtime,\n                debug=debug,\n            )\n\n        def payload_builder(_: bool) -&gt; Mapping[str, Any]:\n            \"\"\"Builds the payload confirming a successful export.\n\n            Args:\n                _ (bool): Unused parameter to match the expected signature.\n\n            Returns:\n                Mapping[str, Any]: The structured payload.\n            \"\"\"\n            payload: dict[str, Any] = {\"status\": \"exported\", \"file\": export_path}\n            if include_runtime:\n                payload[\"python\"] = ascii_safe(\n                    platform.python_version(), \"python_version\"\n                )\n                payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n            return payload\n\n        new_run_command(\n            command_name=command,\n            payload_builder=payload_builder,\n            quiet=quiet,\n            verbose=verbose,\n            fmt=fmt_lower,\n            pretty=pretty,\n            debug=debug,\n        )\n\n    try:\n        entries = history_svc.list()\n        if filter_cmd:\n            entries = [e for e in entries if filter_cmd in e.get(\"command\", \"\")]\n        if sort == \"timestamp\":\n            entries = sorted(entries, key=lambda e: e.get(\"timestamp\", 0))\n        if group_by == \"command\":\n            groups: dict[str, list[dict[str, Any]]] = {}\n            for e in entries:\n                groups.setdefault(e.get(\"command\", \"\"), []).append(e)\n            entries = [\n                {\"group\": k, \"count\": len(v), \"entries\": v} for k, v in groups.items()\n            ]\n        if limit == 0:\n            entries = []\n        elif limit &gt; 0:\n            entries = entries[-limit:]\n\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list history: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n\n    def list_payload_builder(include_runtime: bool) -&gt; Mapping[str, Any]:\n        \"\"\"Builds the payload containing a list of history entries.\n\n        Args:\n            include_runtime (bool): If True, includes Python and platform info.\n\n        Returns:\n            Mapping[str, Any]: The structured payload.\n        \"\"\"\n        payload: dict[str, Any] = {\"entries\": entries}\n        if include_runtime:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=list_payload_builder,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/history/service.html#bijux_cli.commands.history.service.resolve_history_service","title":"resolve_history_service","text":"<pre><code>resolve_history_service(\n    command: str,\n    fmt_lower: str,\n    quiet: bool,\n    include_runtime: bool,\n    debug: bool,\n) -&gt; HistoryProtocol\n</code></pre> <p>Resolves the HistoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"history\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HistoryProtocol</code> (              <code>HistoryProtocol</code> )          \u2013            <p>An instance of the history service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/history/service.py</code> <pre><code>def resolve_history_service(\n    command: str, fmt_lower: str, quiet: bool, include_runtime: bool, debug: bool\n) -&gt; HistoryProtocol:\n    \"\"\"Resolves the HistoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"history\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        HistoryProtocol: An instance of the history service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(HistoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"History service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/commands/memory/index.html","title":"Reference / Commands / Memory Index","text":"<ul> <li>Clear Command</li> <li>Delete Command</li> <li>Get Command</li> <li>List Command</li> <li>Service Command</li> <li>Set Command</li> <li>Utils Command</li> </ul>"},{"location":"reference/commands/memory/clear.html","title":"Clear Command API Reference","text":"<p>This section documents the internals of the <code>clear</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/clear.html#bijux_cli.commands.memory.clear","title":"bijux_cli.commands.memory.clear","text":"<p>Implements the <code>memory clear</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently erasing all entries from the transient, in-memory data store. This action is irreversible for the current process. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"cleared\", \"count\": 0}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, clear failed).</li> </ul>"},{"location":"reference/commands/memory/clear.html#bijux_cli.commands.memory.clear.clear_memory","title":"clear_memory","text":"<pre><code>clear_memory(\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Removes all key-value pairs from the transient in-memory store.</p> <p>This command erases all entries from the memory service and emits a structured payload to confirm the operation.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/clear.py</code> <pre><code>def clear_memory(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes all key-value pairs from the transient in-memory store.\n\n    This command erases all entries from the memory service and emits a\n    structured payload to confirm the operation.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory clear\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.clear()\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to clear memory: {exc}\",\n            code=1,\n            failure=\"clear_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/delete.html","title":"Delete Command API Reference","text":"<p>This section documents the internals of the <code>delete</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/delete.html#bijux_cli.commands.memory.delete","title":"bijux_cli.commands.memory.delete","text":"<p>Implements the <code>memory delete</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for removing a specific key and its associated value from the transient, in-memory data store. It provides a structured, machine-readable confirmation of the deletion.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"deleted\", \"key\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The key was not found, or another unexpected error occurred.</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/delete.html#bijux_cli.commands.memory.delete.delete_memory","title":"delete_memory","text":"<pre><code>delete_memory(\n    key: str = Argument(..., help=\"Key to delete\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Deletes a key from the transient in-memory store.</p> <p>This command validates the key's format and then removes the corresponding key-value pair from the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to delete')</code> )           \u2013            <p>The memory key to remove. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/delete.py</code> <pre><code>def delete_memory(\n    key: str = typer.Argument(..., help=\"Key to delete\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Deletes a key from the transient in-memory store.\n\n    This command validates the key's format and then removes the corresponding\n    key-value pair from the memory service.\n\n    Args:\n        key (str): The memory key to remove. Must be between 1 and 4096\n            printable, non-whitespace characters.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory delete\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.delete(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Key not found: {key}\",\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to delete memory key: {exc}\",\n            code=1,\n            failure=\"delete_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/get.html","title":"Get Command API Reference","text":"<p>This section documents the internals of the <code>get</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/get.html#bijux_cli.commands.memory.get","title":"bijux_cli.commands.memory.get","text":"<p>Implements the <code>memory get</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for retrieving the value of a specific key from the transient, in-memory data store. It provides a structured, machine-readable response containing the value or an error if the key is not found.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The key was not found, or another unexpected error occurred.</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/get.html#bijux_cli.commands.memory.get.get_memory","title":"get_memory","text":"<pre><code>get_memory(\n    key: str = Argument(..., help=\"Key to retrieve\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Retrieves a value by key from the transient in-memory store.</p> <p>This command validates the key's format and then fetches the corresponding value from the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to retrieve')</code> )           \u2013            <p>The memory key to look up. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/get.py</code> <pre><code>def get_memory(\n    key: str = typer.Argument(..., help=\"Key to retrieve\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Retrieves a value by key from the transient in-memory store.\n\n    This command validates the key's format and then fetches the corresponding\n    value from the memory service.\n\n    Args:\n        key (str): The memory key to look up. Must be between 1 and 4096\n            printable, non-whitespace characters.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory get\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        value = memory_svc.get(key)\n    except KeyError:\n        emit_error_and_exit(\n            f\"Key not found: {key}\",\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to get memory: {exc}\",\n            code=1,\n            failure=\"get_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key, value),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/list.html","title":"List Command API Reference","text":"<p>This section documents the internals of the <code>list</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/list.html#bijux_cli.commands.memory.list","title":"bijux_cli.commands.memory.list","text":"<p>Implements the <code>memory list</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for listing all keys currently held in the transient, in-memory data store. It retrieves the keys and presents them in a structured, machine-readable list format.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"keys\": list, \"count\": int}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, list failed).</li> </ul>"},{"location":"reference/commands/memory/list.html#bijux_cli.commands.memory.list.list_memory","title":"list_memory","text":"<pre><code>list_memory(\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Lists all keys currently stored in the transient in-memory store.</p> <p>This command retrieves all defined keys from the memory service, sorts them, and then emits them in a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/list.py</code> <pre><code>def list_memory(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all keys currently stored in the transient in-memory store.\n\n    This command retrieves all defined keys from the memory service, sorts them,\n    and then emits them in a structured payload.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory list\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        keys = sorted(memory_svc.keys())\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to list memory keys: {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, keys),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/service.html","title":"Service Command API Reference","text":"<p>This section documents the internals of the <code>service</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/service.html#bijux_cli.commands.memory.service","title":"bijux_cli.commands.memory.service","text":"<p>Implements the root callback for the <code>bijux memory</code> command group.</p> <p>This module defines the default action for the <code>bijux memory</code> command. When invoked without a subcommand, it provides a summary of the transient, in-memory data store, including the number of keys currently set.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"ok\", \"count\": int|None, \"message\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/memory/service.html#bijux_cli.commands.memory.service.memory","title":"memory","text":"<pre><code>memory(\n    ctx: Context,\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Defines the entrypoint for the <code>bijux memory</code> command group.</p> <p>This function serves as the main callback. It handles <code>--help</code> requests and, if no subcommand is invoked, delegates to the <code>memory_summary</code> function to display the default summary view.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>Exit</code>             \u2013            <p>Exits after displaying help text.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/service.py</code> <pre><code>def memory(\n    ctx: typer.Context,\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Defines the entrypoint for the `bijux memory` command group.\n\n    This function serves as the main callback. It handles `--help` requests and,\n    if no subcommand is invoked, delegates to the `memory_summary` function to\n    display the default summary view.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        typer.Exit: Exits after displaying help text.\n    \"\"\"\n    if any(arg in (\"-h\", \"--help\") for arg in sys.argv):\n        if ctx.invoked_subcommand:\n            cmd = getattr(ctx.command, \"get_command\", None)\n            sub_cmd = cmd(ctx, ctx.invoked_subcommand) if callable(cmd) else None\n            if sub_cmd and hasattr(sub_cmd, \"get_help\"):\n                typer.echo(\n                    sub_cmd.get_help(ctx)  # pyright: ignore[reportAttributeAccessIssue]\n                )\n            else:\n                typer.echo(ctx.get_help())\n        else:\n            typer.echo(ctx.get_help())\n        raise typer.Exit()\n    if ctx.invoked_subcommand is None:\n        memory_summary(ctx, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/memory/service.html#bijux_cli.commands.memory.service.memory_summary","title":"memory_summary","text":"<pre><code>memory_summary(\n    ctx: Context,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None\n</code></pre> <p>Handles the logic for the default <code>bijux memory</code> command action.</p> <p>This function is called by the main Typer callback when no subcommand is specified. It resolves the memory service, gets the key count, and then executes the one-shot summary.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The Typer context for the CLI.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload upon completion or error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/service.py</code> <pre><code>def memory_summary(\n    ctx: typer.Context,\n    quiet: bool,\n    verbose: bool,\n    fmt: str,\n    pretty: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Handles the logic for the default `bijux memory` command action.\n\n    This function is called by the main Typer callback when no subcommand is\n    specified. It resolves the memory service, gets the key count, and then\n    executes the one-shot summary.\n\n    Args:\n        ctx (typer.Context): The Typer context for the CLI.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload upon completion or error.\n    \"\"\"\n    command = \"memory\"\n    include_runtime = verbose or debug\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    output_format = OutputFormat.YAML if fmt_lower == \"yaml\" else OutputFormat.JSON\n    effective_pretty = debug or pretty\n\n    svc = resolve_memory_service(command, fmt_lower, quiet, include_runtime, debug)\n\n    keys_count = None\n    with contextlib.suppress(Exception):\n        keys_count = len(svc.keys())\n\n    _run_one_shot_mode(\n        command=command,\n        fmt=fmt_lower,\n        output_format=output_format,\n        quiet=quiet,\n        verbose=verbose,\n        debug=debug,\n        effective_pretty=effective_pretty,\n        include_runtime=include_runtime,\n        keys_count=keys_count,\n    )\n</code></pre>"},{"location":"reference/commands/memory/set.html","title":"Set Command API Reference","text":"<p>This section documents the internals of the <code>set</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/set.html#bijux_cli.commands.memory.set","title":"bijux_cli.commands.memory.set","text":"<p>Implements the <code>memory set</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for storing a key-value pair in a transient, in-memory data store. The data persists only for the lifetime of the application's parent process. A structured confirmation is emitted upon success.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"updated\", \"key\": str, \"value\": str}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An unexpected error occurred (e.g., service unavailable, set failed).</li> <li><code>2</code>: The provided key was invalid.</li> </ul>"},{"location":"reference/commands/memory/set.html#bijux_cli.commands.memory.set.set_memory","title":"set_memory","text":"<pre><code>set_memory(\n    key: str = Argument(..., help=\"Key to set\"),\n    value: str = Argument(..., help=\"Value to set\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Sets a key-value pair in the transient in-memory store.</p> <p>This command validates the key's format and then stores the key-value pair using the memory service.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>, default:                   <code>Argument(..., help='Key to set')</code> )           \u2013            <p>The memory key to set. Must be between 1 and 4096 printable, non-whitespace characters.</p> </li> <li> <code>value</code>               (<code>str</code>, default:                   <code>Argument(..., help='Value to set')</code> )           \u2013            <p>The value to associate with the key.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/set.py</code> <pre><code>def set_memory(\n    key: str = typer.Argument(..., help=\"Key to set\"),\n    value: str = typer.Argument(..., help=\"Value to set\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Sets a key-value pair in the transient in-memory store.\n\n    This command validates the key's format and then stores the key-value\n    pair using the memory service.\n\n    Args:\n        key (str): The memory key to set. Must be between 1 and 4096 printable,\n            non-whitespace characters.\n        value (str): The value to associate with the key.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"memory set\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if not (\n        1 &lt;= len(key) &lt;= 4096 and all(c.isprintable() and not c.isspace() for c in key)\n    ):\n        emit_error_and_exit(\n            \"Invalid key: must be 1-4096 printable non-space characters\",\n            code=2,\n            failure=\"invalid_key\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    memory_svc = resolve_memory_service(command, fmt_lower, quiet, verbose, debug)\n\n    try:\n        memory_svc.set(key, value)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Failed to set memory: {exc}\",\n            code=1,\n            failure=\"set_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, key, value),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/memory/utils.html","title":"Utils Command API Reference","text":"<p>This section documents the internals of the <code>utils</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/memory/utils.html#bijux_cli.commands.memory.utils","title":"bijux_cli.commands.memory.utils","text":"<p>Provides shared utilities for the <code>bijux memory</code> command group.</p> <p>This module centralizes common logic used by the memory-related subcommands. Its primary responsibility is to provide a consistent way to resolve the <code>MemoryProtocol</code> service from the Dependency Injection (DI) container, including standardized error handling for cases where the service is unavailable.</p>"},{"location":"reference/commands/memory/utils.html#bijux_cli.commands.memory.utils.resolve_memory_service","title":"resolve_memory_service","text":"<pre><code>resolve_memory_service(\n    command: str,\n    fmt_lower: str,\n    quiet: bool,\n    include_runtime: bool,\n    debug: bool,\n) -&gt; MemoryProtocol\n</code></pre> <p>Resolves the MemoryProtocol implementation from the DI container.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command name (e.g., \"memory list\").</p> </li> <li> <code>fmt_lower</code>               (<code>str</code>)           \u2013            <p>The chosen output format, lowercased.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses non-error output.</p> </li> <li> <code>include_runtime</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime metadata in errors.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MemoryProtocol</code> (              <code>MemoryProtocol</code> )          \u2013            <p>An instance of the memory service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Exits with a structured error if the service cannot be resolved from the container.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/memory/utils.py</code> <pre><code>def resolve_memory_service(\n    command: str,\n    fmt_lower: str,\n    quiet: bool,\n    include_runtime: bool,\n    debug: bool,\n) -&gt; MemoryProtocol:\n    \"\"\"Resolves the MemoryProtocol implementation from the DI container.\n\n    Args:\n        command (str): The full command name (e.g., \"memory list\").\n        fmt_lower (str): The chosen output format, lowercased.\n        quiet (bool): If True, suppresses non-error output.\n        include_runtime (bool): If True, includes runtime metadata in errors.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        MemoryProtocol: An instance of the memory service.\n\n    Raises:\n        SystemExit: Exits with a structured error if the service cannot be\n            resolved from the container.\n    \"\"\"\n    try:\n        return DIContainer.current().resolve(MemoryProtocol)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Memory service unavailable: {exc}\",\n            code=1,\n            failure=\"service_unavailable\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=include_runtime,\n        )\n</code></pre>"},{"location":"reference/commands/plugins/index.html","title":"Reference / Commands / Plugins Index","text":"<ul> <li>Check Command</li> <li>Info Command</li> <li>Install Command</li> <li>List Command</li> <li>Scaffold Command</li> <li>Uninstall Command</li> <li>Utils Command</li> </ul>"},{"location":"reference/commands/plugins/check.html","title":"Check Command API Reference","text":"<p>This section documents the internals of the <code>check</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/check.html#bijux_cli.commands.plugins.check","title":"bijux_cli.commands.plugins.check","text":"<p>Implements the <code>plugins check</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for performing a health check on a specific installed plugin. It validates the plugin's files, dynamically imports its code, and executes a <code>health()</code> hook function if available. The result is reported in a structured, machine-readable format.</p> Output Contract <ul> <li>Healthy:   <code>{\"plugin\": str, \"status\": \"healthy\"}</code></li> <li>Unhealthy: <code>{\"plugin\": str, \"status\": \"unhealthy\"}</code> (exits with code 1)</li> <li>Verbose:   Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:     <code>{\"error\": \"...\", \"code\": int}</code> (for pre-check failures)</li> </ul> Exit Codes <ul> <li><code>0</code>: The plugin is healthy.</li> <li><code>1</code>: The plugin is unhealthy, could not be found, or an error occurred   during import or execution.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/check.html#bijux_cli.commands.plugins.check.check_plugin","title":"check_plugin","text":"<pre><code>check_plugin(\n    name: str = Argument(..., help=\"Plugin name\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Runs a health check on a specific installed plugin.</p> <p>This function validates a plugin's structure, dynamically imports its <code>plugin.py</code> file, and executes its <code>health()</code> hook to determine its operational status. The final status is emitted as a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name of the plugin to check.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating the health status or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/check.py</code> <pre><code>def check_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Runs a health check on a specific installed plugin.\n\n    This function validates a plugin's structure, dynamically imports its\n    `plugin.py` file, and executes its `health()` hook to determine its\n    operational status. The final status is emitted as a structured payload.\n\n    Args:\n        name (str): The name of the plugin to check.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating the health status or detailing an error.\n    \"\"\"\n    command = \"plugins check\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    plug_dir = get_plugins_dir() / name\n    plug_py = plug_dir / \"plugin.py\"\n    meta_json = plug_dir / \"plugin.json\"\n\n    if not plug_py.is_file():\n        emit_error_and_exit(\n            f'Plugin \"{name}\" not found',\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n            extra={\"plugin\": name},\n        )\n\n    if not meta_json.is_file():\n        emit_error_and_exit(\n            f'Plugin \"{name}\" metadata (plugin.json) is missing',\n            code=1,\n            failure=\"metadata_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    try:\n        meta = json.loads(meta_json.read_text(\"utf-8\"))\n        if not (isinstance(meta, dict) and meta.get(\"name\") and meta.get(\"desc\")):\n            raise ValueError(\"Incomplete metadata\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f'Plugin \"{name}\" metadata is corrupt: {exc}',\n            code=1,\n            failure=\"metadata_corrupt\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    mod_name = f\"_bijux_cli_plugin_{name}\"\n    try:\n        spec = importlib.util.spec_from_file_location(mod_name, plug_py)\n        if not spec or not spec.loader:\n            raise ImportError(\"Cannot create import spec\")\n        module = types.ModuleType(mod_name)\n        sys.modules[mod_name] = module\n        spec.loader.exec_module(module)\n    except Exception as exc:\n        err = f\"Import error: {exc}\"\n        if debug:\n            err += \"\\n\" + traceback.format_exc()\n        emit_error_and_exit(\n            err,\n            code=1,\n            failure=\"import_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    async def _run_health() -&gt; dict[str, Any]:\n        \"\"\"Isolates and executes the plugin's `health()` hook.\n\n        This function finds and calls the `health()` function within the\n        imported plugin module. It handles both synchronous and asynchronous\n        hooks, validates their signatures, and safely captures any exceptions\n        during execution.\n\n        Returns:\n            dict[str, Any]: A dictionary containing the health check result,\n                which includes the plugin name and a status ('healthy' or\n                'unhealthy'), or an error message.\n        \"\"\"\n        hook = getattr(module, \"health\", None)\n        if not callable(hook):\n            return {\"plugin\": name, \"error\": \"No health() hook\"}\n        try:\n            sig = inspect.signature(hook)\n            if len(sig.parameters) != 1:\n                return {\n                    \"plugin\": name,\n                    \"error\": \"health() hook must take exactly one argument (di)\",\n                }\n        except Exception as exc1:\n            return {\"plugin\": name, \"error\": f\"health() signature error: {exc1}\"}\n        try:\n            if asyncio.iscoroutinefunction(hook):\n                res = await hook(None)\n            else:\n                loop = asyncio.get_running_loop()\n                res = await loop.run_in_executor(None, hook, None)\n        except BaseException as exc2:\n            return {\"plugin\": name, \"error\": str(exc2) or exc2.__class__.__name__}\n\n        if res is True:\n            return {\"plugin\": name, \"status\": \"healthy\"}\n        if res is False:\n            return {\"plugin\": name, \"status\": \"unhealthy\"}\n        if isinstance(res, dict) and res.get(\"status\") in (\"healthy\", \"unhealthy\"):\n            return {\"plugin\": name, \"status\": res[\"status\"]}\n        return {\"plugin\": name, \"status\": \"unhealthy\"}\n\n    result = asyncio.run(_run_health())\n    sys.modules.pop(mod_name, None)\n    exit_code = 1 if result.get(\"status\") == \"unhealthy\" else 0\n\n    if result.get(\"error\"):\n        emit_error_and_exit(\n            result[\"error\"],\n            code=1,\n            failure=\"health_error\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    def _build_payload(include: bool) -&gt; Mapping[str, object]:\n        \"\"\"Constructs the final result payload.\n\n        Args:\n            include (bool): If True, adds Python and platform info to the payload.\n\n        Returns:\n            Mapping[str, object]: The payload containing the health check\n                result and optional runtime metadata.\n        \"\"\"\n        payload = result\n        if include:\n            payload[\"python\"] = ascii_safe(platform.python_version(), \"python_version\")\n            payload[\"platform\"] = ascii_safe(platform.platform(), \"platform\")\n        return payload\n\n    new_run_command(\n        command_name=command,\n        payload_builder=_build_payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n        exit_code=exit_code,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/info.html","title":"Info Command API Reference","text":"<p>This section documents the internals of the <code>info</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/info.html#bijux_cli.commands.plugins.info","title":"bijux_cli.commands.plugins.info","text":"<p>Implements the <code>plugins info</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for displaying detailed metadata about a single installed plugin. It locates the plugin by name, reads its <code>plugin.json</code> manifest file, and presents the contents in a structured, machine-readable format.</p> Output Contract <ul> <li>Success: <code>{\"name\": str, \"path\": str, ... (plugin.json contents)}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: The plugin was not found, or its metadata file was corrupt.</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/info.html#bijux_cli.commands.plugins.info.info_plugin","title":"info_plugin","text":"<pre><code>info_plugin(\n    name: str = Argument(..., help=\"Plugin name\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Shows detailed metadata for a specific installed plugin.</p> <p>This function locates an installed plugin by its directory name, parses its <code>plugin.json</code> manifest file, and emits the contents as a structured payload.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The case-sensitive name of the plugin to inspect.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/info.py</code> <pre><code>def info_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Shows detailed metadata for a specific installed plugin.\n\n    This function locates an installed plugin by its directory name, parses its\n    `plugin.json` manifest file, and emits the contents as a structured\n    payload.\n\n    Args:\n        name (str): The case-sensitive name of the plugin to inspect.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins info\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    plug_dir = get_plugins_dir() / name\n    if not (plug_dir.is_dir() and (plug_dir / \"plugin.py\").is_file()):\n        emit_error_and_exit(\n            f'Plugin \"{name}\" not found',\n            code=1,\n            failure=\"not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    meta_file = plug_dir / \"plugin.json\"\n    meta: dict[str, Any] = {}\n    if meta_file.is_file():\n        try:\n            meta = json.loads(meta_file.read_text(\"utf-8\"))\n            if not meta.get(\"name\"):\n                raise ValueError(\"Missing required fields\")\n        except Exception as exc:\n            emit_error_and_exit(\n                f'Plugin \"{name}\" metadata is corrupt: {exc}',\n                code=1,\n                failure=\"metadata_corrupt\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    payload = {\"name\": name, \"path\": str(plug_dir), **meta}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: _build_payload(include, payload),\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/install.html","title":"Install Command API Reference","text":"<p>This section documents the internals of the <code>install</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/install.html#bijux_cli.commands.plugins.install","title":"bijux_cli.commands.plugins.install","text":"<p>Implements the <code>plugins install</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for installing a new plugin by copying its source directory into the CLI's plugins folder. The process is designed to be atomic and safe, incorporating validation of the plugin's name and metadata, version compatibility checks against the current CLI version, and file locking to prevent race conditions during installation.</p> Output Contract <ul> <li>Install Success: <code>{\"status\": \"installed\", \"plugin\": str, \"dest\": str}</code></li> <li>Dry Run Success: <code>{\"status\": \"dry-run\", \"plugin\": str, ...}</code></li> <li>Error:           <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., source not found, invalid name,   version incompatibility, filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/install.html#bijux_cli.commands.plugins.install.install_plugin","title":"install_plugin","text":"<pre><code>install_plugin(\n    path: str = Argument(\n        ..., help=\"Path to plugin directory\"\n    ),\n    dry_run: bool = Option(False, \"--dry-run\"),\n    force: bool = Option(False, \"--force\", \"-F\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        False, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Installs a plugin from a local source directory.</p> <p>This function orchestrates the plugin installation process. It validates the source path and plugin name, checks for version compatibility, handles pre-existing plugins via the <code>--force</code> flag, and performs an atomic copy into the plugins directory using a file lock and temporary directory.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>, default:                   <code>Argument(..., help='Path to plugin directory')</code> )           \u2013            <p>The source path to the plugin directory to install.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>Option(False, '--dry-run')</code> )           \u2013            <p>If True, simulates the installation without making changes.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>Option(False, '--force', '-F')</code> )           \u2013            <p>If True, overwrites an existing plugin of the same name.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in error payloads.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(False, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/install.py</code> <pre><code>def install_plugin(\n    path: str = typer.Argument(..., help=\"Path to plugin directory\"),\n    dry_run: bool = typer.Option(False, \"--dry-run\"),\n    force: bool = typer.Option(False, \"--force\", \"-F\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(False, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Installs a plugin from a local source directory.\n\n    This function orchestrates the plugin installation process. It validates\n    the source path and plugin name, checks for version compatibility, handles\n    pre-existing plugins via the `--force` flag, and performs an atomic copy\n    into the plugins directory using a file lock and temporary directory.\n\n    Args:\n        path (str): The source path to the plugin directory to install.\n        dry_run (bool): If True, simulates the installation without making changes.\n        force (bool): If True, overwrites an existing plugin of the same name.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in error payloads.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    from packaging.specifiers import SpecifierSet\n\n    from bijux_cli.__version__ import version as cli_version\n\n    command = \"plugins install\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n\n    src = Path(path).expanduser()\n    try:\n        src = src.resolve()\n    except (FileNotFoundError, OSError, RuntimeError):\n        src = src.absolute()\n    if not src.exists() or not src.is_dir():\n        emit_error_and_exit(\n            \"Source not found\",\n            code=1,\n            failure=\"source_not_found\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plugin_name = src.name\n\n    if not PLUGIN_NAME_RE.fullmatch(plugin_name) or not plugin_name.isascii():\n        emit_error_and_exit(\n            \"Invalid plugin name: only ASCII letters, digits, dash and underscore are allowed.\",\n            code=1,\n            failure=\"invalid_name\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    dest = plugins_dir / plugin_name\n\n    try:\n        plugins_dir.mkdir(parents=True, exist_ok=True)\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Cannot create plugins dir '{plugins_dir}': {exc}\",\n            code=1,\n            failure=\"create_dir_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    lock_file = plugins_dir / \".bijux_install.lock\"\n\n    @contextlib.contextmanager\n    def _lock(fp: Path) -&gt; Iterator[None]:\n        \"\"\"Provides an exclusive, non-blocking file lock.\n\n        This context manager attempts to acquire a lock on the specified file.\n        It is used to ensure atomic filesystem operations within the plugins\n        directory.\n\n        Args:\n            fp (Path): The path to the file to lock.\n\n        Yields:\n            None: Yields control to the `with` block once the lock is acquired.\n        \"\"\"\n        with fp.open(\"w\") as fh:\n            fcntl.flock(fh, fcntl.LOCK_EX)\n            try:\n                yield\n            finally:\n                fcntl.flock(fh, fcntl.LOCK_UN)\n\n    with _lock(lock_file):\n        if plugins_dir.is_symlink():\n            emit_error_and_exit(\n                f\"Refusing to install: plugins dir '{plugins_dir}' is a symlink.\",\n                code=1,\n                failure=\"symlink_dir\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n        if dest.exists():\n            if not force:\n                emit_error_and_exit(\n                    f\"Plugin '{plugin_name}' already installed. Use --force.\",\n                    code=1,\n                    failure=\"already_installed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n            try:\n                if dest.is_dir():\n                    shutil.rmtree(dest)\n                else:\n                    dest.unlink()\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Unable to remove existing '{dest}': {exc}\",\n                    code=1,\n                    failure=\"remove_failed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n        plugin_py = src / \"plugin.py\"\n        if not plugin_py.exists():\n            emit_error_and_exit(\n                \"plugin.py not found in plugin directory\",\n                code=1,\n                failure=\"plugin_py_missing\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        version_spec = parse_required_cli_version(plugin_py)\n        if version_spec:\n            try:\n                spec = SpecifierSet(version_spec)\n                if not spec.contains(cli_version, prereleases=True):\n                    emit_error_and_exit(\n                        f\"Incompatible CLI version: plugin requires '{version_spec}', but you have '{cli_version}'\",\n                        code=1,\n                        failure=\"incompatible_version\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Invalid version specifier in plugin: '{version_spec}'. {exc}\",\n                    code=1,\n                    failure=\"invalid_specifier\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n        if dry_run:\n            payload = {\n                \"status\": \"dry-run\",\n                \"plugin\": plugin_name,\n                \"source\": str(src),\n                \"dest\": str(dest),\n            }\n        else:\n            with tempfile.TemporaryDirectory(dir=plugins_dir) as td:\n                tmp_dst = Path(td) / plugin_name\n                try:\n                    shutil.copytree(\n                        src,\n                        tmp_dst,\n                        symlinks=True,\n                        ignore=ignore_hidden_and_broken_symlinks,\n                    )\n                except OSError as exc:\n                    if exc.errno == errno.ENOSPC or \"No space left on device\" in str(\n                        exc\n                    ):\n                        emit_error_and_exit(\n                            \"Disk full during plugin install\",\n                            code=1,\n                            failure=\"disk_full\",\n                            command=command,\n                            fmt=fmt_lower,\n                            quiet=quiet,\n                            include_runtime=verbose,\n                            debug=debug,\n                        )\n                    if exc.errno == errno.EACCES or \"Permission denied\" in str(exc):\n                        emit_error_and_exit(\n                            \"Permission denied during plugin install\",\n                            code=1,\n                            failure=\"permission_denied\",\n                            command=command,\n                            fmt=fmt_lower,\n                            quiet=quiet,\n                            include_runtime=verbose,\n                            debug=debug,\n                        )\n                    emit_error_and_exit(\n                        f\"OSError during plugin install: {exc!r}\",\n                        code=1,\n                        failure=\"os_error\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n                if not (tmp_dst / \"plugin.py\").is_file():\n                    emit_error_and_exit(\n                        f\"plugin.py not found in '{tmp_dst}'\",\n                        code=1,\n                        failure=\"plugin_py_missing_after_copy\",\n                        command=command,\n                        fmt=fmt_lower,\n                        quiet=quiet,\n                        include_runtime=verbose,\n                        debug=debug,\n                    )\n                shutil.move(str(tmp_dst), dest)\n            payload = {\"status\": \"installed\", \"plugin\": plugin_name, \"dest\": str(dest)}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/list.html","title":"List Command API Reference","text":"<p>This section documents the internals of the <code>list</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/list.html#bijux_cli.commands.plugins.list","title":"bijux_cli.commands.plugins.list","text":"<p>Implements the <code>plugins list</code> subcommand for the Bijux CLI.</p> <p>This module provides the primary command for listing all installed CLI plugins. It performs security checks on the plugins directory and then delegates its core logic to the shared <code>handle_list_plugins</code> utility, which scans the filesystem and returns a structured list.</p> Output Contract <ul> <li>Success: <code>{\"plugins\": [str, ...]}</code></li> <li>Verbose: Adds <code>{\"python\": str, \"platform\": str}</code> to the payload.</li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: An error occurred while accessing the plugins directory (e.g.,   it is a symlink or inaccessible).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/list.html#bijux_cli.commands.plugins.list.list_plugin","title":"list_plugin","text":"<pre><code>list_plugin(\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Lists all installed CLI plugins.</p> <p>This command first performs security checks on the plugins directory, such as ensuring it is not a symbolic link. It then delegates to the shared <code>handle_list_plugins</code> utility to perform the filesystem scan and emit the structured output.</p> <p>Parameters:</p> <ul> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in the output.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format, \"json\" or \"yaml\".</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/list.py</code> <pre><code>def list_plugin(\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Lists all installed CLI plugins.\n\n    This command first performs security checks on the plugins directory, such\n    as ensuring it is not a symbolic link. It then delegates to the shared\n    `handle_list_plugins` utility to perform the filesystem scan and emit the\n    structured output.\n\n    Args:\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in the output.\n        fmt (str): The output format, \"json\" or \"yaml\".\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins list\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n    handle_list_plugins(command, quiet, verbose, fmt, pretty, debug)\n</code></pre>"},{"location":"reference/commands/plugins/scaffold.html","title":"Scaffold Command API Reference","text":"<p>This section documents the internals of the <code>scaffold</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/scaffold.html#bijux_cli.commands.plugins.scaffold","title":"bijux_cli.commands.plugins.scaffold","text":"<p>Implements the <code>plugins scaffold</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for creating a new plugin project from a <code>cookiecutter</code> template. It validates the proposed plugin name, handles the destination directory setup (including forcing overwrites), and invokes <code>cookiecutter</code> to generate the project structure.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"created\", \"plugin\": str, \"dir\": str}</code></li> <li>Error:   <code>{\"error\": \"...\", \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., cookiecutter not installed, invalid   template, name conflict, filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/scaffold.html#bijux_cli.commands.plugins.scaffold.scaffold_plugin","title":"scaffold_plugin","text":"<pre><code>scaffold_plugin(\n    name: str = Argument(..., help=\"Plugin name\"),\n    output_dir: str = Option(\".\", \"--output-dir\", \"-o\"),\n    template: str | None = Option(\n        None,\n        \"--template\",\n        \"-t\",\n        help=\"Path or URL to a cookiecutter template (required)\",\n    ),\n    force: bool = Option(False, \"--force\", \"-F\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Creates a new plugin project from a cookiecutter template.</p> <p>This function orchestrates the scaffolding process. It performs numerous validations on the plugin name and output directory, handles existing directories with the <code>--force</code> flag, invokes the <code>cookiecutter</code> library to generate the project, and validates the resulting plugin metadata.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name for the new plugin (e.g., 'my-plugin').</p> </li> <li> <code>output_dir</code>               (<code>str</code>, default:                   <code>Option('.', '--output-dir', '-o')</code> )           \u2013            <p>The directory where the new plugin project will be created.</p> </li> <li> <code>template</code>               (<code>str | None</code>, default:                   <code>Option(None, '--template', '-t', help='Path or URL to a cookiecutter template (required)')</code> )           \u2013            <p>The path or URL to the <code>cookiecutter</code> template.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>Option(False, '--force', '-F')</code> )           \u2013            <p>If True, overwrites the output directory if it exists.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes runtime metadata in error payloads.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/scaffold.py</code> <pre><code>def scaffold_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    output_dir: str = typer.Option(\".\", \"--output-dir\", \"-o\"),\n    template: str | None = typer.Option(\n        None,\n        \"--template\",\n        \"-t\",\n        help=\"Path or URL to a cookiecutter template (required)\",\n    ),\n    force: bool = typer.Option(False, \"--force\", \"-F\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Creates a new plugin project from a cookiecutter template.\n\n    This function orchestrates the scaffolding process. It performs numerous\n    validations on the plugin name and output directory, handles existing\n    directories with the `--force` flag, invokes the `cookiecutter` library\n    to generate the project, and validates the resulting plugin metadata.\n\n    Args:\n        name (str): The name for the new plugin (e.g., 'my-plugin').\n        output_dir (str): The directory where the new plugin project will be\n            created.\n        template (str | None): The path or URL to the `cookiecutter` template.\n        force (bool): If True, overwrites the output directory if it exists.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes runtime metadata in error payloads.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins scaffold\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n\n    if name in keyword.kwlist:\n        emit_error_and_exit(\n            f\"Invalid plugin name: '{name}' is a reserved Python keyword.\",\n            code=1,\n            failure=\"reserved_keyword\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not PLUGIN_NAME_RE.fullmatch(name) or not name.isascii():\n        emit_error_and_exit(\n            \"Invalid plugin name: only ASCII letters, digits, dash and underscore are allowed.\",\n            code=1,\n            failure=\"invalid_name\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not template:\n        emit_error_and_exit(\n            \"No plugin template found. Please specify --template (path or URL).\",\n            code=1,\n            failure=\"no_template\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    slug = unicodedata.normalize(\"NFC\", name)\n    parent = Path(output_dir).expanduser().resolve()\n    target = parent / slug\n\n    if not parent.exists():\n        try:\n            parent.mkdir(parents=True, exist_ok=True)\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to create output directory '{parent}': {exc}\",\n                code=1,\n                failure=\"create_dir_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n    elif not parent.is_dir():\n        emit_error_and_exit(\n            f\"Output directory '{parent}' is not a directory.\",\n            code=1,\n            failure=\"not_dir\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    normalized = name.lower()\n    for existing in parent.iterdir():\n        if (\n            (existing.is_dir() or existing.is_symlink())\n            and existing.name.lower() == normalized\n            and existing.resolve() != target.resolve()\n        ):\n            emit_error_and_exit(\n                f\"Plugin name '{name}' conflicts with existing directory '{existing.name}'. \"\n                \"Plugin names must be unique (case-insensitive).\",\n                code=1,\n                failure=\"name_conflict\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    if target.exists() or target.is_symlink():\n        if not force:\n            emit_error_and_exit(\n                f\"Directory '{target}' is not empty \u2013 use --force to overwrite.\",\n                code=1,\n                failure=\"dir_not_empty\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        try:\n            if target.is_symlink():\n                target.unlink()\n            elif target.is_dir():\n                shutil.rmtree(target)\n            else:\n                target.unlink()\n        except Exception as exc:\n            emit_error_and_exit(\n                f\"Failed to remove existing '{target}': {exc}\",\n                code=1,\n                failure=\"remove_failed\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n\n    try:\n        from cookiecutter.main import cookiecutter\n\n        cookiecutter(\n            template,\n            no_input=True,\n            output_dir=str(parent),\n            extra_context={\"project_name\": name, \"project_slug\": slug},\n        )\n        if not target.is_dir():\n            raise RuntimeError(\"Template copy failed\")\n    except ModuleNotFoundError:\n        emit_error_and_exit(\n            \"cookiecutter is required but not installed.\",\n            code=1,\n            failure=\"cookiecutter_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    except Exception as exc:\n        msg = f\"Scaffold failed: {exc} (template not found or invalid)\"\n        emit_error_and_exit(\n            msg,\n            code=1,\n            failure=\"scaffold_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plugin_json = target / \"plugin.json\"\n    if not plugin_json.is_file():\n        emit_error_and_exit(\n            f\"Scaffold failed: plugin.json not found in '{target}'.\",\n            code=1,\n            failure=\"plugin_json_missing\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n    try:\n        meta = json.loads(plugin_json.read_text(\"utf-8\"))\n        if not (\n            isinstance(meta, dict)\n            and meta.get(\"name\")\n            and (meta.get(\"desc\") or meta.get(\"description\"))\n        ):\n            raise ValueError(\"Missing required fields\")\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Scaffold failed: plugin.json invalid: {exc}\",\n            code=1,\n            failure=\"plugin_json_invalid\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    payload = {\"status\": \"created\", \"plugin\": name, \"dir\": str(target)}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/uninstall.html","title":"Uninstall Command API Reference","text":"<p>This section documents the internals of the <code>uninstall</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/uninstall.html#bijux_cli.commands.plugins.uninstall","title":"bijux_cli.commands.plugins.uninstall","text":"<p>Implements the <code>plugins uninstall</code> subcommand for the Bijux CLI.</p> <p>This module contains the logic for permanently removing an installed plugin from the filesystem. The operation locates the plugin directory by its exact name, performs security checks (e.g., refusing to act on symbolic links), and uses a file lock to ensure atomicity before deleting the directory.</p> Output Contract <ul> <li>Success: <code>{\"status\": \"uninstalled\", \"plugin\": str}</code></li> <li>Error:   <code>{\"error\": str, \"code\": int}</code></li> </ul> Exit Codes <ul> <li><code>0</code>: Success.</li> <li><code>1</code>: A fatal error occurred (e.g., plugin not found, permission denied,   filesystem error).</li> <li><code>2</code>: An invalid flag was provided (e.g., bad format).</li> <li><code>3</code>: An ASCII or encoding error was detected in the environment.</li> </ul>"},{"location":"reference/commands/plugins/uninstall.html#bijux_cli.commands.plugins.uninstall.uninstall_plugin","title":"uninstall_plugin","text":"<pre><code>uninstall_plugin(\n    name: str = Argument(..., help=\"Plugin name\"),\n    quiet: bool = Option(\n        False, \"-q\", \"--quiet\", help=HELP_QUIET\n    ),\n    verbose: bool = Option(\n        False, \"-v\", \"--verbose\", help=HELP_VERBOSE\n    ),\n    fmt: str = Option(\n        \"json\", \"-f\", \"--format\", help=HELP_FORMAT\n    ),\n    pretty: bool = Option(\n        True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY\n    ),\n    debug: bool = Option(\n        False, \"-d\", \"--debug\", help=HELP_DEBUG\n    ),\n) -&gt; None\n</code></pre> <p>Removes an installed plugin by deleting its directory.</p> <p>This function locates the plugin directory by name, performs several safety checks, acquires a file lock to ensure atomicity, and then permanently removes the plugin from the filesystem.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>, default:                   <code>Argument(..., help='Plugin name')</code> )           \u2013            <p>The name of the plugin to uninstall. The match is case-sensitive and Unicode-aware.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>Option(False, '-q', '--quiet', help=HELP_QUIET)</code> )           \u2013            <p>If True, suppresses all output except for errors.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>Option(False, '-v', '--verbose', help=HELP_VERBOSE)</code> )           \u2013            <p>If True, includes Python/platform details in error outputs.</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>Option('json', '-f', '--format', help=HELP_FORMAT)</code> )           \u2013            <p>The output format for confirmation or error messages.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>Option(True, '--pretty/--no-pretty', help=HELP_NO_PRETTY)</code> )           \u2013            <p>If True, pretty-prints the output.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>Option(False, '-d', '--debug', help=HELP_DEBUG)</code> )           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits with a contract-compliant status code and payload, indicating success or detailing an error.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/uninstall.py</code> <pre><code>def uninstall_plugin(\n    name: str = typer.Argument(..., help=\"Plugin name\"),\n    quiet: bool = typer.Option(False, \"-q\", \"--quiet\", help=HELP_QUIET),\n    verbose: bool = typer.Option(False, \"-v\", \"--verbose\", help=HELP_VERBOSE),\n    fmt: str = typer.Option(\"json\", \"-f\", \"--format\", help=HELP_FORMAT),\n    pretty: bool = typer.Option(True, \"--pretty/--no-pretty\", help=HELP_NO_PRETTY),\n    debug: bool = typer.Option(False, \"-d\", \"--debug\", help=HELP_DEBUG),\n) -&gt; None:\n    \"\"\"Removes an installed plugin by deleting its directory.\n\n    This function locates the plugin directory by name, performs several safety\n    checks, acquires a file lock to ensure atomicity, and then permanently\n    removes the plugin from the filesystem.\n\n    Args:\n        name (str): The name of the plugin to uninstall. The match is\n            case-sensitive and Unicode-aware.\n        quiet (bool): If True, suppresses all output except for errors.\n        verbose (bool): If True, includes Python/platform details in error outputs.\n        fmt (str): The output format for confirmation or error messages.\n        pretty (bool): If True, pretty-prints the output.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits with a contract-compliant status code and\n            payload, indicating success or detailing an error.\n    \"\"\"\n    command = \"plugins uninstall\"\n\n    fmt_lower = validate_common_flags(fmt, command, quiet)\n    plugins_dir = get_plugins_dir()\n    refuse_on_symlink(plugins_dir, command, fmt_lower, quiet, verbose, debug)\n\n    lock_file = plugins_dir / \".bijux_install.lock\"\n\n    plugin_dirs: list[Path] = []\n    try:\n        plugin_dirs = [\n            p\n            for p in plugins_dir.iterdir()\n            if p.is_dir()\n            and unicodedata.normalize(\"NFC\", p.name)\n            == unicodedata.normalize(\"NFC\", name)\n        ]\n    except Exception as exc:\n        emit_error_and_exit(\n            f\"Could not list plugins dir '{plugins_dir}': {exc}\",\n            code=1,\n            failure=\"list_failed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    if not plugin_dirs:\n        emit_error_and_exit(\n            f\"Plugin '{name}' is not installed.\",\n            code=1,\n            failure=\"not_installed\",\n            command=command,\n            fmt=fmt_lower,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n\n    plug_path = plugin_dirs[0]\n\n    @contextlib.contextmanager\n    def _lock(fp: Path) -&gt; Iterator[None]:\n        \"\"\"Provides an exclusive, non-blocking file lock.\n\n        This context manager attempts to acquire a lock on the specified file.\n        It is used to ensure atomic filesystem operations within the plugins\n        directory.\n\n        Args:\n            fp (Path): The path to the file to lock.\n\n        Yields:\n            None: Yields control to the `with` block once the lock is acquired.\n        \"\"\"\n        fp.parent.mkdir(parents=True, exist_ok=True)\n        with fp.open(\"w\") as fh:\n            fcntl.flock(fh, fcntl.LOCK_EX)\n            try:\n                yield\n            finally:\n                fcntl.flock(fh, fcntl.LOCK_UN)\n\n    with _lock(lock_file):\n        if not plug_path.exists():\n            pass\n        elif plug_path.is_symlink():\n            emit_error_and_exit(\n                f\"Plugin path '{plug_path}' is a symlink. Refusing to uninstall.\",\n                code=1,\n                failure=\"symlink_path\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        elif not plug_path.is_dir():\n            emit_error_and_exit(\n                f\"Plugin path '{plug_path}' is not a directory.\",\n                code=1,\n                failure=\"not_dir\",\n                command=command,\n                fmt=fmt_lower,\n                quiet=quiet,\n                include_runtime=verbose,\n                debug=debug,\n            )\n        else:\n            try:\n                shutil.rmtree(plug_path)\n            except PermissionError:\n                emit_error_and_exit(\n                    f\"Permission denied removing '{plug_path}'\",\n                    code=1,\n                    failure=\"permission_denied\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n            except Exception as exc:\n                emit_error_and_exit(\n                    f\"Failed to remove '{plug_path}': {exc}\",\n                    code=1,\n                    failure=\"remove_failed\",\n                    command=command,\n                    fmt=fmt_lower,\n                    quiet=quiet,\n                    include_runtime=verbose,\n                    debug=debug,\n                )\n\n    payload = {\"status\": \"uninstalled\", \"plugin\": name}\n\n    new_run_command(\n        command_name=command,\n        payload_builder=lambda include: payload,\n        quiet=quiet,\n        verbose=verbose,\n        fmt=fmt_lower,\n        pretty=pretty,\n        debug=debug,\n    )\n</code></pre>"},{"location":"reference/commands/plugins/utils.html","title":"Utils Command API Reference","text":"<p>This section documents the internals of the <code>utils</code> command in Bijux CLI, including all arguments, options, and output structure. </p>"},{"location":"reference/commands/plugins/utils.html#bijux_cli.commands.plugins.utils","title":"bijux_cli.commands.plugins.utils","text":"<p>Provides shared utilities for the <code>bijux plugins</code> command group.</p> <p>This module centralizes common logic for managing CLI plugins. It offers helper functions for tasks such as:</p> <ul> <li>Safely traversing plugin directories for copy operations.</li> <li>Parsing metadata from <code>plugin.py</code> files without code execution by     using the Abstract Syntax Tree (AST).</li> <li>Performing security checks, like refusing to operate on directories     that are symbolic links.</li> <li>Validating plugin names against a standard pattern.</li> </ul>"},{"location":"reference/commands/plugins/utils.html#bijux_cli.commands.plugins.utils.ignore_hidden_and_broken_symlinks","title":"ignore_hidden_and_broken_symlinks","text":"<pre><code>ignore_hidden_and_broken_symlinks(\n    dirpath: str, names: list[str]\n) -&gt; list[str]\n</code></pre> <p>Creates a list of files and directories to ignore during a copy operation.</p> <p>This function is designed to be used as the <code>ignore</code> callable for <code>shutil.copytree</code>. It skips hidden files (starting with \".\"), the <code>plugin.py</code> file, and any broken symbolic links.</p> <p>Parameters:</p> <ul> <li> <code>dirpath</code>               (<code>str</code>)           \u2013            <p>The path to the directory being scanned.</p> </li> <li> <code>names</code>               (<code>list[str]</code>)           \u2013            <p>A list of names of items within <code>dirpath</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of item names to be ignored by <code>shutil.copytree</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def ignore_hidden_and_broken_symlinks(dirpath: str, names: list[str]) -&gt; list[str]:\n    \"\"\"Creates a list of files and directories to ignore during a copy operation.\n\n    This function is designed to be used as the `ignore` callable for\n    `shutil.copytree`. It skips hidden files (starting with \".\"), the\n    `plugin.py` file, and any broken symbolic links.\n\n    Args:\n        dirpath (str): The path to the directory being scanned.\n        names (list[str]): A list of names of items within `dirpath`.\n\n    Returns:\n        list[str]: A list of item names to be ignored by `shutil.copytree`.\n    \"\"\"\n    skip = []\n    base = Path(dirpath)\n    for name in names:\n        if name == \"plugin.py\":\n            continue\n        if name.startswith(\".\"):\n            skip.append(name)\n            continue\n        entry = base / name\n        if entry.is_symlink():\n            try:\n                entry.resolve(strict=True)\n            except (FileNotFoundError, OSError):\n                skip.append(name)\n    return skip\n</code></pre>"},{"location":"reference/commands/plugins/utils.html#bijux_cli.commands.plugins.utils.parse_required_cli_version","title":"parse_required_cli_version","text":"<pre><code>parse_required_cli_version(plugin_py: Path) -&gt; str | None\n</code></pre> <p>Parses <code>requires_cli_version</code> from a plugin file without executing it.</p> <p>This function safely inspects a Python file using the Abstract Syntax Tree (AST) to find the value of a top-level or class-level variable named <code>requires_cli_version</code>. This avoids the security risks of importing or executing untrusted code.</p> <p>Parameters:</p> <ul> <li> <code>plugin_py</code>               (<code>Path</code>)           \u2013            <p>The path to the <code>plugin.py</code> file to parse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>str | None: The version specifier string if found, otherwise None.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def parse_required_cli_version(plugin_py: Path) -&gt; str | None:\n    \"\"\"Parses `requires_cli_version` from a plugin file without executing it.\n\n    This function safely inspects a Python file using the Abstract Syntax Tree\n    (AST) to find the value of a top-level or class-level variable named\n    `requires_cli_version`. This avoids the security risks of importing or\n    executing untrusted code.\n\n    Args:\n        plugin_py (Path): The path to the `plugin.py` file to parse.\n\n    Returns:\n        str | None: The version specifier string if found, otherwise None.\n    \"\"\"\n    import ast\n\n    try:\n        with plugin_py.open(\"r\") as f:\n            tree = ast.parse(f.read(), filename=str(plugin_py))\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Assign):\n                for target in node.targets:\n                    if (\n                        (\n                            (\n                                isinstance(target, ast.Attribute)\n                                and target.attr == \"requires_cli_version\"\n                            )\n                            or (\n                                isinstance(target, ast.Name)\n                                and target.id == \"requires_cli_version\"\n                            )\n                        )\n                        and isinstance(node.value, ast.Constant)\n                        and isinstance(node.value.value, str)\n                    ):\n                        return node.value.value\n            if isinstance(node, ast.ClassDef) and node.name == \"Plugin\":\n                for stmt in node.body:\n                    if (\n                        isinstance(stmt, ast.Assign)\n                        and any(\n                            isinstance(t, ast.Name) and t.id == \"requires_cli_version\"\n                            for t in stmt.targets\n                        )\n                        and isinstance(stmt.value, ast.Constant)\n                        and isinstance(stmt.value.value, str)\n                    ):\n                        return stmt.value.value\n\n        return None\n    except (\n        FileNotFoundError,\n        PermissionError,\n        SyntaxError,\n        UnicodeDecodeError,\n        OSError,\n    ):\n        return None\n</code></pre>"},{"location":"reference/commands/plugins/utils.html#bijux_cli.commands.plugins.utils.refuse_on_symlink","title":"refuse_on_symlink","text":"<pre><code>refuse_on_symlink(\n    directory: Path,\n    command: str,\n    fmt: str,\n    quiet: bool,\n    verbose: bool,\n    debug: bool,\n) -&gt; None\n</code></pre> <p>Emits an error and exits if the given directory is a symbolic link.</p> <p>This serves as a security precaution to prevent plugin operations on unexpected filesystem locations.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>Path</code>)           \u2013            <p>The path to check.</p> </li> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The invoking command name for the error payload.</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>The requested output format for the error payload.</p> </li> <li> <code>quiet</code>               (<code>bool</code>)           \u2013            <p>If True, suppresses output before exiting.</p> </li> <li> <code>verbose</code>               (<code>bool</code>)           \u2013            <p>If True, includes runtime info in the error payload.</p> </li> <li> <code>debug</code>               (<code>bool</code>)           \u2013            <p>If True, enables debug diagnostics.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>SystemExit</code>             \u2013            <p>Always exits the process with code 1 if <code>directory</code> is a symbolic link.</p> </li> </ul> Source code in <code>src/bijux_cli/commands/plugins/utils.py</code> <pre><code>def refuse_on_symlink(\n    directory: Path,\n    command: str,\n    fmt: str,\n    quiet: bool,\n    verbose: bool,\n    debug: bool,\n) -&gt; None:\n    \"\"\"Emits an error and exits if the given directory is a symbolic link.\n\n    This serves as a security precaution to prevent plugin operations on\n    unexpected filesystem locations.\n\n    Args:\n        directory (Path): The path to check.\n        command (str): The invoking command name for the error payload.\n        fmt (str): The requested output format for the error payload.\n        quiet (bool): If True, suppresses output before exiting.\n        verbose (bool): If True, includes runtime info in the error payload.\n        debug (bool): If True, enables debug diagnostics.\n\n    Returns:\n        None:\n\n    Raises:\n        SystemExit: Always exits the process with code 1 if `directory` is\n            a symbolic link.\n    \"\"\"\n    if directory.is_symlink():\n        from bijux_cli.commands.utilities import emit_error_and_exit\n\n        verb = command.split()[-1]\n        emit_error_and_exit(\n            f\"Refusing to {verb}: plugins dir {directory.name!r} is a symlink.\",\n            code=1,\n            failure=\"symlink_dir\",\n            command=command,\n            fmt=fmt,\n            quiet=quiet,\n            include_runtime=verbose,\n            debug=debug,\n        )\n</code></pre>"},{"location":"reference/contracts/index.html","title":"Reference / Contracts Index","text":"<ul> <li>Audit Module</li> <li>Config Module</li> <li>Context Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>Emitter Module</li> <li>History Module</li> <li>Memory Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Registry Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul>"},{"location":"reference/contracts/audit.html","title":"Audit Module API Reference","text":"<p>This section documents the internals of the <code>audit</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/audit.html#bijux_cli.contracts.audit","title":"bijux_cli.contracts.audit","text":"<p>Defines the contract for the audit logging and diagnostics service.</p> <p>This module specifies the <code>AuditProtocol</code>, a formal interface that any auditing service within the application must implement. This ensures a consistent API for logging command executions and performing system health checks, promoting modularity and testability.</p>"},{"location":"reference/contracts/audit.html#bijux_cli.contracts.audit.AuditProtocol","title":"AuditProtocol","text":"<p>               Bases: <code>ProcessPoolProtocol</code>, <code>Protocol</code></p> <p>Defines the contract for audit logging and system diagnostics.</p> <p>This interface specifies the methods required for securely logging command executions, retrieving audit trails, and performing diagnostic checks on the CLI environment. It inherits from <code>ProcessPoolProtocol</code> to manage command execution.</p>"},{"location":"reference/contracts/audit.html#bijux_cli.contracts.audit.AuditProtocol.cli_audit","title":"cli_audit","text":"<pre><code>cli_audit() -&gt; None\n</code></pre> <p>Performs a CLI-specific audit and status check.</p> <p>This method is the entry point for the <code>bijux audit</code> command. Implementations should gather and log the current audit status without raising exceptions or executing external commands.</p> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Performs a CLI-specific audit and status check.\n\n    This method is the entry point for the `bijux audit` command.\n    Implementations should gather and log the current audit status without\n    raising exceptions or executing external commands.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/audit.html#bijux_cli.contracts.audit.AuditProtocol.get_commands","title":"get_commands","text":"<pre><code>get_commands() -&gt; list[dict[str, Any]]\n</code></pre> <p>Returns a copy of all recorded audit commands.</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of dictionaries, where each dictionary represents a logged command execution.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def get_commands(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns a copy of all recorded audit commands.\n\n    Returns:\n        list[dict[str, Any]]: A list of dictionaries, where each dictionary\n            represents a logged command execution.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/audit.html#bijux_cli.contracts.audit.AuditProtocol.log","title":"log","text":"<pre><code>log(cmd: list[str], *, executor: str) -&gt; None\n</code></pre> <p>Logs a command execution for auditing purposes.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and its arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name or identifier of the entity that executed the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs a command execution for auditing purposes.\n\n    Args:\n        cmd (list[str]): The command and its arguments to log.\n        executor (str): The name or identifier of the entity that executed\n            the command.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html","title":"Config Module API Reference","text":"<p>This section documents the internals of the <code>config</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config","title":"bijux_cli.contracts.config","text":"<p>Defines the contract for the application configuration service.</p> <p>This module specifies the <code>ConfigProtocol</code>, a formal interface that any configuration management service within the application must implement. This ensures a consistent API for loading, accessing, modifying, and persisting key-value settings, promoting modularity and testability.</p>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol","title":"ConfigProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for application configuration management.</p> <p>This interface specifies the methods for loading, accessing, modifying, and persisting configuration data from various sources (e.g., .env, JSON, or YAML files).</p>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.all","title":"all","text":"<pre><code>all() -&gt; dict[str, str]\n</code></pre> <p>Returns all configuration key-value pairs.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary of all configuration data.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def all(self) -&gt; dict[str, str]:\n    \"\"\"Returns all configuration key-value pairs.\n\n    Returns:\n        dict[str, str]: A dictionary of all configuration data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears all configuration data from memory.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all configuration data from memory.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to delete.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a configuration key and persists the change.\n\n    Args:\n        key (str): The key to delete.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.export","title":"export","text":"<pre><code>export(\n    path: str | Path, out_format: str | None = None\n) -&gt; None\n</code></pre> <p>Exports the current configuration to a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The path to the destination file.</p> </li> <li> <code>out_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The desired output format (e.g., 'env'). If None, the format may be inferred from the path.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def export(self, path: str | Path, out_format: str | None = None) -&gt; None:\n    \"\"\"Exports the current configuration to a file.\n\n    Args:\n        path (str | Path): The path to the destination file.\n        out_format (str | None): The desired output format (e.g., 'env').\n            If None, the format may be inferred from the path.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.get","title":"get","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Retrieves a configuration value by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The value to return if the key is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The configuration value or the provided default.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieves a configuration value by its key.\n\n    Args:\n        key (str): The key of the value to retrieve.\n        default (Any): The value to return if the key is not found.\n\n    Returns:\n        Any: The configuration value or the provided default.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.list_keys","title":"list_keys","text":"<pre><code>list_keys() -&gt; list[str]\n</code></pre> <p>Returns a list of all configuration keys.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all keys present in the configuration.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def list_keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all configuration keys.\n\n    Returns:\n        list[str]: A list of all keys present in the configuration.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.load","title":"load","text":"<pre><code>load(path: str | Path | None = None) -&gt; None\n</code></pre> <p>Loads configuration from a specified file path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the configuration file. If None, the service may load from a default location.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def load(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Loads configuration from a specified file path.\n\n    Args:\n        path (str | Path | None): The path to the configuration file. If\n            None, the service may load from a default location.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.reload","title":"reload","text":"<pre><code>reload() -&gt; None\n</code></pre> <p>Reloads the configuration from its last-known source file.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reloads the configuration from its last-known source file.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Saves the current in-memory configuration state to its source file.</p> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Saves the current in-memory configuration state to its source file.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set or update.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a configuration key and persists the change.\n\n    Args:\n        key (str): The key to set or update.\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/config.html#bijux_cli.contracts.config.ConfigProtocol.unset","title":"unset","text":"<pre><code>unset(key: str) -&gt; None\n</code></pre> <p>Removes a configuration key from the current in-memory session.</p> <p>Unlike <code>delete</code>, this operation may not be immediately persisted to the source file.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to remove from the in-memory configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/config.py</code> <pre><code>def unset(self, key: str) -&gt; None:\n    \"\"\"Removes a configuration key from the current in-memory session.\n\n    Unlike `delete`, this operation may not be immediately persisted to the\n    source file.\n\n    Args:\n        key (str): The key to remove from the in-memory configuration.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context.html","title":"Context Module API Reference","text":"<p>This section documents the internals of the <code>context</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/context.html#bijux_cli.contracts.context","title":"bijux_cli.contracts.context","text":"<p>Defines the contract for the request-scoped context service.</p> <p>This module specifies the <code>ContextProtocol</code>, a formal interface for services that manage contextual data associated with a specific operation or request. This pattern allows for state to be carried implicitly through an application's call stack.</p>"},{"location":"reference/contracts/context.html#bijux_cli.contracts.context.ContextProtocol","title":"ContextProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a request-scoped context object.</p> <p>This interface specifies methods for a context that can store arbitrary key-value data and supports both synchronous (<code>with</code>) and asynchronous (<code>async with</code>) context management patterns.</p>"},{"location":"reference/contracts/context.html#bijux_cli.contracts.context.ContextProtocol.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears all data from the context.</p> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all data from the context.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context.html#bijux_cli.contracts.context.ContextProtocol.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieves a value by key from the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by key from the context.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/context.html#bijux_cli.contracts.context.ContextProtocol.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a key-value pair in the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/context.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair in the context.\n\n    Args:\n        key (str): The key to set.\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs.html","title":"Docs Module API Reference","text":"<p>This section documents the internals of the <code>docs</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/docs.html#bijux_cli.contracts.docs","title":"bijux_cli.contracts.docs","text":"<p>Defines the contract for the API specification writing service.</p> <p>This module specifies the <code>DocsProtocol</code>, a formal interface that any service responsible for generating and writing API specification documents (e.g., OpenAPI, JSON Schema) must implement.</p>"},{"location":"reference/contracts/docs.html#bijux_cli.contracts.docs.DocsProtocol","title":"DocsProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for writing API specifications.</p> <p>This interface specifies methods for serializing and writing specification documents, such as OpenAPI or JSON Schema, in various formats.</p>"},{"location":"reference/contracts/docs.html#bijux_cli.contracts.docs.DocsProtocol.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the writer and releases any associated resources.</p> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the writer and releases any associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs.html#bijux_cli.contracts.docs.DocsProtocol.write","title":"write","text":"<pre><code>write(\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = JSON,\n    name: str = \"spec\",\n) -&gt; str\n</code></pre> <p>Writes a specification to a file.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'spec'</code> )           \u2013            <p>The base name for the output file. Defaults to 'spec'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The path to the written file as a string.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def write(\n    self,\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    name: str = \"spec\",\n) -&gt; str:\n    \"\"\"Writes a specification to a file.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        name (str): The base name for the output file. Defaults to 'spec'.\n\n    Returns:\n        str: The path to the written file as a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/docs.html#bijux_cli.contracts.docs.DocsProtocol.write_sync","title":"write_sync","text":"<pre><code>write_sync(\n    spec: dict[Any, Any],\n    fmt: OutputFormat,\n    name: str | Path,\n) -&gt; Path\n</code></pre> <p>Writes the specification to a file synchronously.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[Any, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The output format (e.g., JSON, YAML).</p> </li> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The path or name for the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>The <code>Path</code> object pointing to the written file.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/docs.py</code> <pre><code>def write_sync(\n    self, spec: dict[Any, Any], fmt: OutputFormat, name: str | Path\n) -&gt; Path:\n    \"\"\"Writes the specification to a file synchronously.\n\n    Args:\n        spec (dict[Any, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format (e.g., JSON, YAML).\n        name (str | Path): The path or name for the output file.\n\n    Returns:\n        Path: The `Path` object pointing to the written file.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/doctor.html","title":"Doctor Module API Reference","text":"<p>This section documents the internals of the <code>doctor</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/doctor.html#bijux_cli.contracts.doctor","title":"bijux_cli.contracts.doctor","text":"<p>Defines the contract for the CLI health check and diagnostics service.</p> <p>This module specifies the <code>DoctorProtocol</code>, a formal interface that any service responsible for running diagnostic health checks on the CLI and its environment must implement.</p>"},{"location":"reference/contracts/doctor.html#bijux_cli.contracts.doctor.DoctorProtocol","title":"DoctorProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for CLI health checks.</p> <p>This interface specifies the methods for performing system health checks and gathering diagnostic information about the CLI and its environment.</p>"},{"location":"reference/contracts/doctor.html#bijux_cli.contracts.doctor.DoctorProtocol.check_health","title":"check_health","text":"<pre><code>check_health() -&gt; str\n</code></pre> <p>Performs health checks and returns a status string.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string describing the overall health status of the CLI.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/doctor.py</code> <pre><code>def check_health(self) -&gt; str:\n    \"\"\"Performs health checks and returns a status string.\n\n    Returns:\n        str: A string describing the overall health status of the CLI.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/emitter.html","title":"Emitter Module API Reference","text":"<p>This section documents the internals of the <code>emitter</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/emitter.html#bijux_cli.contracts.emitter","title":"bijux_cli.contracts.emitter","text":"<p>Defines the contract for the structured output emission service.</p> <p>This module specifies the <code>EmitterProtocol</code>, a formal interface that any service responsible for serializing data payloads (e.g., to JSON or YAML) and emitting them to an output stream must implement.</p>"},{"location":"reference/contracts/emitter.html#bijux_cli.contracts.emitter.EmitterProtocol","title":"EmitterProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for emitting structured output.</p> <p>This interface specifies the methods for serializing and emitting data in various formats, often integrating with a logging or telemetry system.</p>"},{"location":"reference/contracts/emitter.html#bijux_cli.contracts.emitter.EmitterProtocol.emit","title":"emit","text":"<pre><code>emit(\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None\n</code></pre> <p>Serializes and emits a structured data payload.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Any</code>)           \u2013            <p>The data payload to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format for serialization.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, pretty-prints the output with indentation.</p> </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'info'</code> )           \u2013            <p>The log level for any accompanying message.</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>'Emitting output'</code> )           \u2013            <p>A descriptive message for logging.</p> </li> <li> <code>output</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional pre-formatted string to emit instead of serializing the payload.</p> </li> <li> <code>**context</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key-value pairs for structured logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/emitter.py</code> <pre><code>def emit(\n    self,\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None:\n    \"\"\"Serializes and emits a structured data payload.\n\n    Args:\n        payload (Any): The data payload to serialize and emit.\n        fmt (OutputFormat | None): The output format for serialization.\n        pretty (bool): If True, pretty-prints the output with indentation.\n        level (str): The log level for any accompanying message.\n        message (str): A descriptive message for logging.\n        output (str | None): An optional pre-formatted string to emit\n            instead of serializing the payload.\n        **context (Any): Additional key-value pairs for structured logging.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/emitter.html#bijux_cli.contracts.emitter.EmitterProtocol.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Flushes any buffered output to its destination stream.</p> Source code in <code>src/bijux_cli/contracts/emitter.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered output to its destination stream.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html","title":"History Module API Reference","text":"<p>This section documents the internals of the <code>history</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history","title":"bijux_cli.contracts.history","text":"<p>Defines the contract for the command history management service.</p> <p>This module specifies the <code>HistoryProtocol</code>, a formal interface that any service responsible for recording, retrieving, and managing CLI command history events must implement.</p>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol","title":"HistoryProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for command history management.</p> <p>This interface specifies the methods for recording, retrieving, and managing command history events, including persistence and import/export functionality.</p>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.add","title":"add","text":"<pre><code>add(\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None\n</code></pre> <p>Records a command execution event.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The full command string (e.g., \"status --verbose\").</p> </li> <li> <code>params</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The raw argument vector as executed.</p> </li> <li> <code>success</code>               (<code>bool | None</code>, default:                   <code>True</code> )           \u2013            <p>True if the command was successful.</p> </li> <li> <code>return_code</code>               (<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>The integer exit code of the command.</p> </li> <li> <code>duration_ms</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Total execution time in milliseconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def add(\n    self,\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None:\n    \"\"\"Records a command execution event.\n\n    Args:\n        command (str): The full command string (e.g., \"status --verbose\").\n        params (Sequence[str] | None): The raw argument vector as executed.\n        success (bool | None): True if the command was successful.\n        return_code (int | None): The integer exit code of the command.\n        duration_ms (float | None): Total execution time in milliseconds.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Erases all command history events from the store.</p> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Erases all command history events from the store.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.export","title":"export","text":"<pre><code>export(path: Path) -&gt; None\n</code></pre> <p>Exports all history entries to a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The target file path, which will be overwritten.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def export(self, path: Path) -&gt; None:\n    \"\"\"Exports all history entries to a file.\n\n    Args:\n        path (Path): The target file path, which will be overwritten.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Persists any in-memory history data to permanent storage.</p> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Persists any in-memory history data to permanent storage.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.import_","title":"import_","text":"<pre><code>import_(path: Path) -&gt; None\n</code></pre> <p>Imports history entries from a file, replacing existing entries.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The source file path containing history data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def import_(self, path: Path) -&gt; None:\n    \"\"\"Imports history entries from a file, replacing existing entries.\n\n    Args:\n        path (Path): The source file path containing history data.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/history.html#bijux_cli.contracts.history.HistoryProtocol.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Retrieves command history events.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>20</code> )           \u2013            <p>The maximum number of events to return.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A field name to group events by.</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A substring to filter commands by.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A field name to sort the results by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of history event dictionaries.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/history.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Retrieves command history events.\n\n    Args:\n        limit (int | None): The maximum number of events to return.\n        group_by (str | None): A field name to group events by.\n        filter_cmd (str | None): A substring to filter commands by.\n        sort (str | None): A field name to sort the results by.\n\n    Returns:\n        list[dict[str, Any]]: A list of history event dictionaries.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory.html","title":"Memory Module API Reference","text":"<p>This section documents the internals of the <code>memory</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory","title":"bijux_cli.contracts.memory","text":"<p>Defines the contract for the transient in-memory key-value service.</p> <p>This module specifies the <code>MemoryProtocol</code>, a formal interface that any service providing a non-persistent, in-memory key-value store must implement. This is used for managing ephemeral state within the CLI.</p>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol","title":"MemoryProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a simple in-memory key-value store.</p> <p>This interface specifies the essential methods for a basic key-value data storage service. It is used for managing ephemeral state within the CLI that does not need to persist across sessions.</p>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Removes all key-value pairs from the store.</p> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all key-value pairs from the store.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a key-value pair by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a key-value pair by its key.\n\n    Args:\n        key (str): The key of the value to delete.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieves a value by its key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by its key.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>Returns a list of all keys currently in the store.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all string keys.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all keys currently in the store.\n\n    Returns:\n        list[str]: A list of all string keys.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/memory.html#bijux_cli.contracts.memory.MemoryProtocol.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a key-value pair in the store.</p> <p>If the key already exists, its value will be overwritten.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value being set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/memory.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair in the store.\n\n    If the key already exists, its value will be overwritten.\n\n    Args:\n        key (str): The key for the value being set.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html","title":"Observability Module API Reference","text":"<p>This section documents the internals of the <code>observability</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability","title":"bijux_cli.contracts.observability","text":"<p>Defines the contract for the structured logging and observability service.</p> <p>This module specifies the <code>ObservabilityProtocol</code>, a formal interface that any service providing structured logging capabilities must implement. It ensures a consistent API for configuring loggers, binding contextual data, and emitting log messages throughout the application.</p>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol","title":"ObservabilityProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a structured logging facade.</p> <p>This interface specifies methods for configuring logging, binding contextual data, and emitting log messages in a structured format.</p>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.bind","title":"bind","text":"<pre><code>bind(**_kv: Any) -&gt; Self\n</code></pre> <p>Binds context key-value pairs to the logger for future log entries.</p> <p>Parameters:</p> <ul> <li> <code>**_kv</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Key-value pairs to bind to the logging context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def bind(self, **_kv: Any) -&gt; Self:\n    \"\"\"Binds context key-value pairs to the logger for future log entries.\n\n    Args:\n        **_kv (Any): Key-value pairs to bind to the logging context.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the logger and releases any associated resources.</p> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the logger and releases any associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.get_logger","title":"get_logger","text":"<pre><code>get_logger() -&gt; FilteringBoundLogger | None\n</code></pre> <p>Returns the underlying logger instance.</p> <p>Returns:</p> <ul> <li> <code>FilteringBoundLogger | None</code>           \u2013            <p>FilteringBoundLogger | None: The logger instance (e.g., from <code>structlog</code>) or None if it has not been configured.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def get_logger(self) -&gt; FilteringBoundLogger | None:\n    \"\"\"Returns the underlying logger instance.\n\n    Returns:\n        FilteringBoundLogger | None: The logger instance (e.g., from\n            `structlog`) or None if it has not been configured.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.log","title":"log","text":"<pre><code>log(\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self\n</code></pre> <p>Logs a message with the specified level and context.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The log level (e.g., 'debug', 'info', 'error').</p> </li> <li> <code>msg</code>               (<code>str</code>)           \u2013            <p>The message to log.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional dictionary of additional context to include in the log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def log(\n    self,\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Logs a message with the specified level and context.\n\n    Args:\n        level (str): The log level (e.g., 'debug', 'info', 'error').\n        msg (str): The message to log.\n        extra (dict[str, Any] | None): An optional dictionary of\n            additional context to include in the log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.set_telemetry","title":"set_telemetry","text":"<pre><code>set_telemetry(telemetry: TelemetryProtocol) -&gt; Self\n</code></pre> <p>Sets the telemetry service instance for integration.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>An instance of the telemetry service.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>def set_telemetry(self, telemetry: TelemetryProtocol) -&gt; Self:\n    \"\"\"Sets the telemetry service instance for integration.\n\n    Args:\n        telemetry (TelemetryProtocol): An instance of the telemetry service.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/observability.html#bijux_cli.contracts.observability.ObservabilityProtocol.setup","title":"setup  <code>classmethod</code>","text":"<pre><code>setup(*, debug: bool = False) -&gt; Self\n</code></pre> <p>Creates and configures a new instance of the observability service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, configures the logger for debug-level output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>A new, configured instance of the service.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/observability.py</code> <pre><code>@classmethod\ndef setup(cls, *, debug: bool = False) -&gt; Self:\n    \"\"\"Creates and configures a new instance of the observability service.\n\n    Args:\n        debug (bool): If True, configures the logger for debug-level output.\n\n    Returns:\n        Self: A new, configured instance of the service.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process.html","title":"Process Module API Reference","text":"<p>This section documents the internals of the <code>process</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/process.html#bijux_cli.contracts.process","title":"bijux_cli.contracts.process","text":"<p>Defines the contract for a worker process pool service.</p> <p>This module specifies the <code>ProcessPoolProtocol</code>, a formal interface that any service managing a pool of worker processes for command execution must implement. This allows for abstracting the details of subprocess management.</p>"},{"location":"reference/contracts/process.html#bijux_cli.contracts.process.ProcessPoolProtocol","title":"ProcessPoolProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for a worker process pool.</p> <p>This interface specifies the methods for running commands in isolated worker processes and managing the lifecycle of the pool.</p>"},{"location":"reference/contracts/process.html#bijux_cli.contracts.process.ProcessPoolProtocol.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; dict[str, Any]\n</code></pre> <p>Returns the current status of the process pool.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary containing status information, such as the number of active workers, queue size, etc.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def get_status(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the current status of the process pool.\n\n    Returns:\n        dict[str, Any]: A dictionary containing status information, such as\n            the number of active workers, queue size, etc.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process.html#bijux_cli.contracts.process.ProcessPoolProtocol.run","title":"run","text":"<pre><code>run(\n    cmd: list[str], *, executor: str\n) -&gt; tuple[int, bytes, bytes]\n</code></pre> <p>Executes a command in a worker process.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>A list of command arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name or identifier of the executor to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the return code, standard output (stdout), and standard error (stderr) as bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Executes a command in a worker process.\n\n    Args:\n        cmd (list[str]): A list of command arguments to execute.\n        executor (str): The name or identifier of the executor to use.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the return code,\n            standard output (stdout), and standard error (stderr) as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/process.html#bijux_cli.contracts.process.ProcessPoolProtocol.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shuts down the process pool and releases all associated resources.</p> Source code in <code>src/bijux_cli/contracts/process.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shuts down the process pool and releases all associated resources.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html","title":"Registry Module API Reference","text":"<p>This section documents the internals of the <code>registry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry","title":"bijux_cli.contracts.registry","text":"<p>Defines the contract for the plugin registry service.</p> <p>This module specifies the <code>RegistryProtocol</code>, a formal interface that any service responsible for managing the lifecycle of CLI plugins must implement. This includes registering, retrieving, and invoking hooks on plugins.</p>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol","title":"RegistryProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for plugin management.</p> <p>This interface specifies the methods for registering, deregistering, and interacting with plugins, as well as for invoking plugin hooks.</p>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.call_hook","title":"call_hook  <code>async</code>","text":"<pre><code>call_hook(hook: str, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Invokes a hook on all registered plugins that implement it.</p> <p>Parameters:</p> <ul> <li> <code>hook</code>               (<code>str</code>)           \u2013            <p>The name of the hook to invoke.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the hook.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the hook.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the hook invocation. The exact return type depends on the specific hook's definition and implementation.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>async def call_hook(self, hook: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Invokes a hook on all registered plugins that implement it.\n\n    Args:\n        hook (str): The name of the hook to invoke.\n        *args (Any): Positional arguments to pass to the hook.\n        **kwargs (Any): Keyword arguments to pass to the hook.\n\n    Returns:\n        Any: The result of the hook invocation. The exact return type\n            depends on the specific hook's definition and implementation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.deregister","title":"deregister","text":"<pre><code>deregister(name: str) -&gt; None\n</code></pre> <p>Deregisters a plugin from the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to deregister.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def deregister(self, name: str) -&gt; None:\n    \"\"\"Deregisters a plugin from the registry.\n\n    Args:\n        name (str): The name or alias of the plugin to deregister.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.get","title":"get","text":"<pre><code>get(name: str) -&gt; object\n</code></pre> <p>Retrieves a plugin by its name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>object</code> (              <code>object</code> )          \u2013            <p>The registered plugin object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no plugin with the given name or alias is registered.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def get(self, name: str) -&gt; object:\n    \"\"\"Retrieves a plugin by its name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        object: The registered plugin object.\n\n    Raises:\n        KeyError: If no plugin with the given name or alias is registered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.has","title":"has","text":"<pre><code>has(name: str) -&gt; bool\n</code></pre> <p>Checks if a plugin exists in the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the plugin is registered, False otherwise.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def has(self, name: str) -&gt; bool:\n    \"\"\"Checks if a plugin exists in the registry.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        bool: True if the plugin is registered, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.meta","title":"meta","text":"<pre><code>meta(name: str) -&gt; dict[str, str]\n</code></pre> <p>Returns metadata for a specific plugin.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary containing the plugin's metadata, such as its version and alias.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def meta(self, name: str) -&gt; dict[str, str]:\n    \"\"\"Returns metadata for a specific plugin.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        dict[str, str]: A dictionary containing the plugin's metadata, such\n            as its version and alias.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.names","title":"names","text":"<pre><code>names() -&gt; list[str]\n</code></pre> <p>Returns all registered plugin names.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of the primary names of all registered plugins.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def names(self) -&gt; list[str]:\n    \"\"\"Returns all registered plugin names.\n\n    Returns:\n        list[str]: A list of the primary names of all registered plugins.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/registry.html#bijux_cli.contracts.registry.RegistryProtocol.register","title":"register","text":"<pre><code>register(\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None\n</code></pre> <p>Registers a plugin with the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The primary name of the plugin.</p> </li> <li> <code>plugin</code>               (<code>object</code>)           \u2013            <p>The plugin object to register.</p> </li> <li> <code>alias</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional alias for the plugin.</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/registry.py</code> <pre><code>def register(\n    self,\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a plugin with the registry.\n\n    Args:\n        name (str): The primary name of the plugin.\n        plugin (object): The plugin object to register.\n        alias (str | None): An optional alias for the plugin.\n        version (str | None): An optional version string for the plugin.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/retry.html","title":"Retry Module API Reference","text":"<p>This section documents the internals of the <code>retry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/retry.html#bijux_cli.contracts.retry","title":"bijux_cli.contracts.retry","text":"<p>Defines the contract for operation retry policies.</p> <p>This module specifies the <code>RetryPolicyProtocol</code>, a formal interface that any service providing retry logic for potentially failing operations must implement. This is particularly useful for handling transient errors in network requests or other I/O-bound tasks.</p>"},{"location":"reference/contracts/retry.html#bijux_cli.contracts.retry.RetryPolicyProtocol","title":"RetryPolicyProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for retry policies in asynchronous operations.</p> <p>This interface specifies the methods for executing an operation with retry logic (e.g., exponential backoff) and for resetting the policy's internal state.</p>"},{"location":"reference/contracts/retry.html#bijux_cli.contracts.retry.RetryPolicyProtocol.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the internal state of the retry policy.</p> <p>This is useful for reusing a policy instance for a new, independent operation.</p> Source code in <code>src/bijux_cli/contracts/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the internal state of the retry policy.\n\n    This is useful for reusing a policy instance for a new, independent\n    operation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/retry.html#bijux_cli.contracts.retry.RetryPolicyProtocol.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n) -&gt; T\n</code></pre> <p>Runs an asynchronous operation with a retry policy.</p> <p>Implementations of this method will repeatedly call the <code>supplier</code> until it succeeds or the retry policy is exhausted.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>A no-argument function that returns an awaitable (e.g., a coroutine).</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout for each attempt in seconds.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The successful result of the operation.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/retry.py</code> <pre><code>async def run(\n    self, supplier: Callable[[], Awaitable[T]], seconds: float = 1.0\n) -&gt; T:\n    \"\"\"Runs an asynchronous operation with a retry policy.\n\n    Implementations of this method will repeatedly call the `supplier`\n    until it succeeds or the retry policy is exhausted.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): A no-argument function that\n            returns an awaitable (e.g., a coroutine).\n        seconds (float): The timeout for each attempt in seconds.\n\n    Returns:\n        T: The successful result of the operation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer.html","title":"Serializer Module API Reference","text":"<p>This section documents the internals of the <code>serializer</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer","title":"bijux_cli.contracts.serializer","text":"<p>Defines the contract for the object serialization service.</p> <p>This module specifies the <code>SerializerProtocol</code>, a formal interface that any service responsible for serializing objects to strings or bytes (e.g., in JSON or YAML format) and deserializing them back must implement.</p>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer.SerializerProtocol","title":"SerializerProtocol","text":"<p>               Bases: <code>Protocol[T]</code></p> <p>Defines the contract for stateless, thread-safe object serialization.</p> <p>This interface specifies methods for serializing and deserializing objects to and from strings or bytes in various formats, such as JSON or YAML.</p>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer.SerializerProtocol.dumps","title":"dumps","text":"<pre><code>dumps(\n    obj: T,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; str\n</code></pre> <p>Serializes an object to a string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>T</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized object as a string.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: T,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a string.\n\n    Args:\n        obj (T): The object to serialize.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        str: The serialized object as a string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer.SerializerProtocol.dumps_bytes","title":"dumps_bytes","text":"<pre><code>dumps_bytes(\n    obj: T,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; bytes\n</code></pre> <p>Serializes an object to bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>T</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized object as bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: T,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to bytes.\n\n    Args:\n        obj (T): The object to serialize.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        bytes: The serialized object as bytes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer.SerializerProtocol.emit","title":"emit","text":"<pre><code>emit(\n    payload: T,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; None\n</code></pre> <p>Serializes and emits a payload to standard output.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>T</code>)           \u2013            <p>The object to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def emit(\n    self, payload: T, *, fmt: OutputFormat = OutputFormat.JSON, pretty: bool = False\n) -&gt; None:\n    \"\"\"Serializes and emits a payload to standard output.\n\n    Args:\n        payload (T): The object to serialize and emit.\n        fmt (OutputFormat): The output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        None:\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/serializer.html#bijux_cli.contracts.serializer.SerializerProtocol.loads","title":"loads","text":"<pre><code>loads(\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; T\n</code></pre> <p>Deserializes data from a string or bytes into an object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The format of the input data. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing, though often unused during deserialization.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; T:\n    \"\"\"Deserializes data from a string or bytes into an object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input data. Defaults to\n            `OutputFormat.JSON`.\n        pretty (bool): A hint that may affect parsing, though often unused\n            during deserialization.\n\n    Returns:\n        T: The deserialized object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry.html","title":"Telemetry Module API Reference","text":"<p>This section documents the internals of the <code>telemetry</code> module in Bijux CLI. </p>"},{"location":"reference/contracts/telemetry.html#bijux_cli.contracts.telemetry","title":"bijux_cli.contracts.telemetry","text":"<p>Defines the contract for the fire-and-forget telemetry service.</p> <p>This module specifies the <code>TelemetryProtocol</code>, a formal interface that any service responsible for collecting and managing \"fire-and-forget\" telemetry or analytics events must implement.</p>"},{"location":"reference/contracts/telemetry.html#bijux_cli.contracts.telemetry.TelemetryProtocol","title":"TelemetryProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Defines the contract for fire-and-forget analytics collection.</p> <p>This interface specifies the methods for recording telemetry events and managing the lifecycle of the telemetry service.</p>"},{"location":"reference/contracts/telemetry.html#bijux_cli.contracts.telemetry.TelemetryProtocol.enable","title":"enable","text":"<pre><code>enable() -&gt; None\n</code></pre> <p>Enables the collection of telemetry data.</p> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Enables the collection of telemetry data.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry.html#bijux_cli.contracts.telemetry.TelemetryProtocol.event","title":"event","text":"<pre><code>event(\n    name: str, payload: dict[str, Any]\n) -&gt; None | Coroutine[Any, Any, None]\n</code></pre> <p>Records a telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the event (e.g., \"COMMAND_START\").</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary of key-value pairs containing the event data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | Coroutine[Any, Any, None]</code>           \u2013            <p>Either None (sync) or an awaitable resolving to None (async).</p> </li> </ul> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def event(\n    self, name: str, payload: dict[str, Any]\n) -&gt; None | Coroutine[Any, Any, None]:\n    \"\"\"Records a telemetry event.\n\n    Args:\n        name (str): The name of the event (e.g., \"COMMAND_START\").\n        payload (dict[str, Any]): A dictionary of key-value pairs\n            containing the event data.\n\n    Returns:\n        Either None (sync) or an awaitable resolving to None (async).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/contracts/telemetry.html#bijux_cli.contracts.telemetry.TelemetryProtocol.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Flushes any buffered telemetry events to their destination.</p> Source code in <code>src/bijux_cli/contracts/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered telemetry events to their destination.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/core/index.html","title":"Reference / Core Index","text":"<ul> <li>Constants Module</li> <li>Context Module</li> <li>Di Module</li> <li>Engine Module</li> <li>Enums Module</li> <li>Exceptions Module</li> <li>Paths Module</li> </ul>"},{"location":"reference/core/constants.html","title":"Constants Module API Reference","text":"<p>This section documents the internals of the <code>constants</code> module in Bijux CLI. </p>"},{"location":"reference/core/constants.html#bijux_cli.core.constants","title":"bijux_cli.core.constants","text":"<p>Defines shared constants and help text for the Bijux CLI.</p> <p>This module centralizes constant values used throughout the application, such as default timeouts and standardized help messages for common CLI flags. This practice avoids magic strings and numbers, improving maintainability and ensuring consistency across all commands.</p>"},{"location":"reference/core/context.html","title":"Context Module API Reference","text":"<p>This section documents the internals of the <code>context</code> module in Bijux CLI. </p>"},{"location":"reference/core/context.html#bijux_cli.core.context","title":"bijux_cli.core.context","text":"<p>Provides a concrete implementation for request-scoped context management.</p> <p>This module defines the <code>Context</code> class, which implements the <code>ContextProtocol</code>. It uses Python's <code>contextvars</code> to provide a thread-safe and async-safe mechanism for storing and retrieving key-value data associated with a specific command execution or request. This allows state to be passed through the application's call stack without explicit argument passing.</p>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context","title":"Context","text":"<pre><code>Context(di: DIContainer)\n</code></pre> <p>               Bases: <code>ContextProtocol</code></p> <p>Provides thread-safe, request-scoped storage for CLI commands.</p> <p>This class uses <code>contextvars</code> to manage a dictionary of data that is isolated to the current task or thread. It is intended to be used as both a synchronous and asynchronous context manager.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary storing the context's data.</p> </li> <li> <code>_token</code>               (<code>Token | None</code>)           \u2013            <p>The token for resetting the <code>ContextVar</code>.</p> </li> </ul> <p>Initializes a new Context instance.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container used to resolve the logging service.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@inject\ndef __init__(self, di: DIContainer) -&gt; None:\n    \"\"\"Initializes a new Context instance.\n\n    Args:\n        di (DIContainer): The dependency injection container used to\n            resolve the logging service.\n    \"\"\"\n    self._di = di\n    self._log: ObservabilityProtocol = di.resolve(ObservabilityProtocol)\n    self._data: dict[str, Any] = {}\n    self._token: Token[dict[str, Any] | None] | None = None\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context initialized\", extra={})\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Removes all values from the context's data.</p> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all values from the context's data.\"\"\"\n    self._data.clear()\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\"debug\", \"Context cleared\", extra={})\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.current_data","title":"current_data  <code>classmethod</code>","text":"<pre><code>current_data() -&gt; dict[str, Any]\n</code></pre> <p>Returns the dictionary for the currently active CLI context.</p> <p>This provides direct access to the data stored in the underlying <code>contextvar</code> for the current execution scope.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: The active context data dictionary.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\ndef current_data(cls) -&gt; dict[str, Any]:\n    \"\"\"Returns the dictionary for the currently active CLI context.\n\n    This provides direct access to the data stored in the underlying\n    `contextvar` for the current execution scope.\n\n    Returns:\n        dict[str, Any]: The active context data dictionary.\n    \"\"\"\n    data = _current_context.get()\n    if data is None:\n        data = {}\n        _current_context.set(data)\n    return data\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Gets a value from the current context's data.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key is not found in the context.</p> </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Gets a value from the current context's data.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key is not found in the context.\n    \"\"\"\n    if key not in self._data:\n        if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n            self._log.log(\"warning\", \"Context key not found\", extra={\"key\": key})\n        raise KeyError(f\"Key '{key}' not found in context\")\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\n            \"debug\",\n            \"Context get\",\n            extra={\"key\": key, \"value\": str(self._data[key])},\n        )\n    return self._data[key]\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a value in the current context's data.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a value in the current context's data.\n\n    Args:\n        key (str): The key for the value.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    self._data[key] = value\n    if os.getenv(\"VERBOSE_DI\") and not os.getenv(\"BIJUXCLI_TEST_MODE\"):\n        self._log.log(\n            \"debug\", \"Context set\", extra={\"key\": key, \"value\": str(value)}\n        )\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.set_current_data","title":"set_current_data  <code>classmethod</code>","text":"<pre><code>set_current_data(data: dict[str, Any]) -&gt; None\n</code></pre> <p>Sets the dictionary for the currently active CLI context.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The data to use for the active context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\ndef set_current_data(cls, data: dict[str, Any]) -&gt; None:\n    \"\"\"Sets the dictionary for the currently active CLI context.\n\n    Args:\n        data (dict[str, Any]): The data to use for the active context.\n\n    Returns:\n        None:\n    \"\"\"\n    _current_context.set(data)\n</code></pre>"},{"location":"reference/core/context.html#bijux_cli.core.context.Context.use_context","title":"use_context  <code>classmethod</code>","text":"<pre><code>use_context(data: dict[str, Any]) -&gt; Iterator[None]\n</code></pre> <p>Temporarily replaces the current context data within a <code>with</code> block.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The dictionary to use as the context for the duration of the <code>with</code> block.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/context.py</code> <pre><code>@classmethod\n@contextmanager\ndef use_context(cls, data: dict[str, Any]) -&gt; Iterator[None]:\n    \"\"\"Temporarily replaces the current context data within a `with` block.\n\n    Args:\n        data (dict[str, Any]): The dictionary to use as the context for\n            the duration of the `with` block.\n\n    Yields:\n        None:\n    \"\"\"\n    token = _current_context.set(data)\n    try:\n        yield\n    finally:\n        _current_context.reset(token)\n</code></pre>"},{"location":"reference/core/di.html","title":"Di Module API Reference","text":"<p>This section documents the internals of the <code>di</code> module in Bijux CLI. </p>"},{"location":"reference/core/di.html#bijux_cli.core.di","title":"bijux_cli.core.di","text":"<p>Provides the central dependency injection container for the Bijux CLI.</p> <p>This module defines the <code>DIContainer</code> class, a thread-safe singleton that manages the registration, resolution, and lifecycle of all services within the application. It allows components to be loosely coupled by requesting dependencies based on abstract protocols rather than concrete classes.</p> Key features include <ul> <li>Singleton pattern for global access via <code>DIContainer.current()</code>.</li> <li>Thread-safe operations for concurrent environments.</li> <li>Lazy instantiation of services upon first request.</li> <li>Support for named registrations to allow multiple implementations of the     same protocol.</li> <li>Both synchronous (<code>resolve</code>) and asynchronous (<code>resolve_async</code>) service     resolution.</li> <li>Circular dependency detection.</li> </ul>"},{"location":"reference/core/di.html#bijux_cli.core.di.AppConfigModule","title":"AppConfigModule","text":"<p>               Bases: <code>Module</code></p> <p>An <code>injector</code> module for configuring core CLI dependencies.</p>"},{"location":"reference/core/di.html#bijux_cli.core.di.AppConfigModule.configure","title":"configure","text":"<pre><code>configure(binder: Binder) -&gt; None\n</code></pre> <p>Binds the <code>ConfigProtocol</code> to its default <code>Config</code> implementation.</p> <p>Parameters:</p> <ul> <li> <code>binder</code>               (<code>Binder</code>)           \u2013            <p>The <code>injector</code> binder instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def configure(self, binder: Binder) -&gt; None:\n    \"\"\"Binds the `ConfigProtocol` to its default `Config` implementation.\n\n    Args:\n        binder (Binder): The `injector` binder instance.\n\n    Returns:\n        None:\n    \"\"\"\n    binder.bind(ConfigProtocol, to=Config, scope=singleton)\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer","title":"DIContainer","text":"<pre><code>DIContainer()\n</code></pre> <p>A thread-safe, singleton dependency injection container.</p> <p>This class manages the lifecycle of services, including registration of factories, lazy instantiation, and resolution. It integrates with an underlying <code>injector</code> for basic services and handles custom named registrations and circular dependency detection.</p> <p>Attributes:</p> <ul> <li> <code>_instance</code>               (<code>DIContainer | None</code>)           \u2013            <p>The singleton instance of the container.</p> </li> <li> <code>_lock</code>               (<code>RLock</code>)           \u2013            <p>A reentrant lock to ensure thread safety.</p> </li> <li> <code>_resolving</code>               (<code>ContextVar</code>)           \u2013            <p>A context variable to track services currently being resolved, used for circular dependency detection.</p> </li> <li> <code>_obs</code>               (<code>ObservabilityProtocol | None</code>)           \u2013            <p>A cached reference to the logging service for internal use.</p> </li> <li> <code>_injector</code>               (<code>Injector</code>)           \u2013            <p>The underlying <code>injector</code> library instance.</p> </li> <li> <code>_store</code>               (<code>dict</code>)           \u2013            <p>A mapping of (key, name) tuples to registered factories or values.</p> </li> <li> <code>_services</code>               (<code>dict</code>)           \u2013            <p>A cache of resolved service instances.</p> </li> </ul> <p>Initializes the container's internal stores.</p> <p>This method is idempotent; it does nothing if the container has already been initialized.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the container's internal stores.\n\n    This method is idempotent; it does nothing if the container has already\n    been initialized.\n    \"\"\"\n    if getattr(self, \"_initialised\", False):\n        return\n    self._injector = Injector(AppConfigModule())\n    self._store: dict[\n        tuple[type[Any] | str, str | None], Callable[[], Any | Awaitable[Any]] | Any\n    ] = {}\n    self._services: dict[tuple[type[Any] | str, str | None], Any] = {}\n    self._obs: ObservabilityProtocol | None = None\n    self._initialised = True\n    self._log_static(logging.INFO, \"DIContainer initialised\")\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.current","title":"current  <code>classmethod</code>","text":"<pre><code>current() -&gt; DIContainer\n</code></pre> <p>Returns the active singleton instance of the <code>DIContainer</code>.</p> <p>Returns:</p> <ul> <li> <code>DIContainer</code> (              <code>DIContainer</code> )          \u2013            <p>The singleton instance.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\ndef current(cls) -&gt; DIContainer:\n    \"\"\"Returns the active singleton instance of the `DIContainer`.\n\n    Returns:\n        DIContainer: The singleton instance.\n    \"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = cls()\n            cls._log_static(\n                logging.WARNING, \"DIContainer.current auto-initialized singleton\"\n            )\n        return cls._instance\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.factories","title":"factories","text":"<pre><code>factories() -&gt; Sequence[tuple[type[Any] | str, str | None]]\n</code></pre> <p>Returns a list of all registered factory keys.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple[type[Any] | str, str | None]]</code>           \u2013            <p>Sequence[tuple[type[Any] | str, str | None]]: A sequence of (key, name) tuples for all registered factories.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def factories(self) -&gt; Sequence[tuple[type[Any] | str, str | None]]:\n    \"\"\"Returns a list of all registered factory keys.\n\n    Returns:\n        Sequence[tuple[type[Any] | str, str | None]]: A sequence of\n            (key, name) tuples for all registered factories.\n    \"\"\"\n    with self._lock:\n        return list(self._store.keys())\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.override","title":"override","text":"<pre><code>override(\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; Iterator[None]\n</code></pre> <p>Temporarily overrides a service registration within a context block.</p> <p>This is primarily useful for testing, allowing a service to be replaced with a mock or stub. The original registration is restored upon exiting the context.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to override.</p> </li> <li> <code>factory_or_value</code>               (<code>Callable[[], T | Awaitable[T]] | T</code>)           \u2013            <p>The temporary factory or value.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@contextmanager\ndef override(\n    self,\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; Iterator[None]:\n    \"\"\"Temporarily overrides a service registration within a context block.\n\n    This is primarily useful for testing, allowing a service to be replaced\n    with a mock or stub. The original registration is restored upon exiting\n    the context.\n\n    Args:\n        key (type[T] | str): The service key to override.\n        factory_or_value: The temporary factory or value.\n        name (str | None): An optional name for the registration.\n\n    Yields:\n        None:\n    \"\"\"\n    with self._lock:\n        store_key = (key, name)\n        original_factory = self._store.get(store_key)\n        original_instance = self._services.get(store_key)\n        self.register(key, factory_or_value, name)\n        if store_key in self._services:\n            del self._services[store_key]\n        self._log(\n            logging.DEBUG,\n            \"Overriding service\",\n            extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n        )\n    try:\n        yield\n    finally:\n        with self._lock:\n            if original_factory is not None:\n                self._store[store_key] = original_factory\n                if original_instance is not None:\n                    self._services[store_key] = original_instance\n                else:\n                    self._services.pop(store_key, None)\n                self._log(\n                    logging.DEBUG,\n                    \"Restored service\",\n                    extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n                )\n            else:\n                self.unregister(key, name)\n                self._log(\n                    logging.DEBUG,\n                    \"Removed service override\",\n                    extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n                )\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.register","title":"register","text":"<pre><code>register(\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; None\n</code></pre> <p>Registers a factory or a pre-resolved value for a given service key.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key, which can be a protocol type or a unique string identifier.</p> </li> <li> <code>factory_or_value</code>               (<code>Callable[[], T | Awaitable[T]] | T</code>)           \u2013            <p>The factory function that creates the service, or the service instance itself.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration, allowing multiple implementations of the same key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the registration key is invalid or conflicts with an existing registration.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def register(\n    self,\n    key: type[T] | str,\n    factory_or_value: Callable[[], T | Awaitable[T]] | T,\n    name: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a factory or a pre-resolved value for a given service key.\n\n    Args:\n        key (type[T] | str): The service key, which can be a protocol type\n            or a unique string identifier.\n        factory_or_value: The factory function that creates the service,\n            or the service instance itself.\n        name (str | None): An optional name for the registration, allowing\n            multiple implementations of the same key.\n\n    Returns:\n        None:\n\n    Raises:\n        BijuxError: If the registration key is invalid or conflicts with an\n            existing registration.\n    \"\"\"\n    if not (isinstance(key, str) or inspect.isclass(key)):\n        raise BijuxError(\"Service key must be a type or str\", http_status=400)\n    try:\n        store_key = (key, name)\n        if isinstance(key, str) and any(\n            isinstance(k, type) and k.__name__ == key for k, _ in self._store\n        ):\n            raise BijuxError(\n                f\"Key {key} conflicts with existing type name\", http_status=400\n            )\n        if isinstance(key, type) and any(k == key.__name__ for k, _ in self._store):\n            raise BijuxError(\n                f\"Type {key.__name__} conflicts with existing string key\",\n                http_status=400,\n            )\n        self._store[store_key] = factory_or_value\n        if isinstance(factory_or_value, ObservabilityProtocol) and not isinstance(\n            factory_or_value, type\n        ):\n            self._obs = factory_or_value\n        self._log(\n            logging.DEBUG,\n            \"Registered service\",\n            extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n        )\n    except (TypeError, KeyError) as exc:\n        self._log(\n            logging.ERROR,\n            f\"Failed to register service: {exc}\",\n            extra={\"service_name\": _key_name(key), \"name\": name},\n        )\n        raise BijuxError(\n            f\"Failed to register service {_key_name(key)}: {exc}\", http_status=400\n        ) from exc\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.reset","title":"reset  <code>classmethod</code>","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the singleton instance, shutting down all services.</p> <p>This method is intended for use in testing environments to ensure a clean state between tests. It clears all registered services and factories.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\ndef reset(cls) -&gt; None:\n    \"\"\"Resets the singleton instance, shutting down all services.\n\n    This method is intended for use in testing environments to ensure a\n    clean state between tests. It clears all registered services and\n    factories.\n    \"\"\"\n    inst = None\n    with cls._lock:\n        inst = cls._instance\n        cls._instance = None\n        cls._obs = None\n    if inst is None:\n        cls._log_static(logging.DEBUG, \"DIContainer reset (no instance)\")\n        return\n    try:\n        asyncio.run(inst.shutdown())\n    except Exception as exc:\n        cls._log_static(logging.ERROR, f\"Error during shutdown: {exc}\")\n    inst._services.clear()\n    inst._store.clear()\n    inst._obs = None\n    cls._log_static(logging.DEBUG, \"DIContainer reset\")\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.reset_async","title":"reset_async  <code>async</code> <code>classmethod</code>","text":"<pre><code>reset_async() -&gt; None\n</code></pre> <p>Asynchronously resets the singleton instance.</p> <p>This method is intended for use in testing environments. All services and factories are cleared.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>@classmethod\nasync def reset_async(cls) -&gt; None:\n    \"\"\"Asynchronously resets the singleton instance.\n\n    This method is intended for use in testing environments. All services\n    and factories are cleared.\n    \"\"\"\n    instance = None\n    with cls._lock:\n        if cls._instance is not None:\n            instance = cls._instance\n            cls._instance = None\n            cls._obs = None\n    if instance is not None:\n        await instance.shutdown()\n        instance._services.clear()\n        instance._store.clear()\n        instance._obs = None\n    cls._log_static(logging.DEBUG, \"DIContainer reset\")\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.resolve","title":"resolve","text":"<pre><code>resolve(key: type[T] | str, name: str | None = None) -&gt; T\n</code></pre> <p>Resolves and returns a service instance synchronously.</p> <p>If the service factory is asynchronous, this method will run the async factory to completion.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to resolve.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The resolved service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the service is not registered.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the factory fails, returns None, or a circular dependency is detected.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def resolve(self, key: type[T] | str, name: str | None = None) -&gt; T:\n    \"\"\"Resolves and returns a service instance synchronously.\n\n    If the service factory is asynchronous, this method will run the\n    async factory to completion.\n\n    Args:\n        key (type[T] | str): The service key to resolve.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        T: The resolved service instance.\n\n    Raises:\n        KeyError: If the service is not registered.\n        BijuxError: If the factory fails, returns None, or a circular\n            dependency is detected.\n    \"\"\"\n    return self._resolve_common(key, name, async_mode=False)\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.resolve_async","title":"resolve_async  <code>async</code>","text":"<pre><code>resolve_async(\n    key: type[T] | str, name: str | None = None\n) -&gt; T\n</code></pre> <p>Resolves and returns a service instance asynchronously.</p> <p>This method should be used when the caller is in an async context. It can resolve both synchronous and asynchronous factories.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[T] | str</code>)           \u2013            <p>The service key to resolve.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The resolved service instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the service is not registered.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the factory fails, returns None, or a circular dependency is detected.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>async def resolve_async(self, key: type[T] | str, name: str | None = None) -&gt; T:\n    \"\"\"Resolves and returns a service instance asynchronously.\n\n    This method should be used when the caller is in an async context. It\n    can resolve both synchronous and asynchronous factories.\n\n    Args:\n        key (type[T] | str): The service key to resolve.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        T: The resolved service instance.\n\n    Raises:\n        KeyError: If the service is not registered.\n        BijuxError: If the factory fails, returns None, or a circular\n            dependency is detected.\n    \"\"\"\n    result = self._resolve_common(key, name, async_mode=True)\n    if asyncio.iscoroutine(result):\n        return await cast(Awaitable[T], result)\n    else:\n        return cast(T, result)\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.services","title":"services","text":"<pre><code>services() -&gt; Sequence[tuple[type[Any] | str, str | None]]\n</code></pre> <p>Returns a list of all resolved and cached service keys.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple[type[Any] | str, str | None]]</code>           \u2013            <p>Sequence[tuple[type[Any] | str, str | None]]: A sequence of (key, name) tuples for all currently resolved services.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def services(self) -&gt; Sequence[tuple[type[Any] | str, str | None]]:\n    \"\"\"Returns a list of all resolved and cached service keys.\n\n    Returns:\n        Sequence[tuple[type[Any] | str, str | None]]: A sequence of\n            (key, name) tuples for all currently resolved services.\n    \"\"\"\n    with self._lock:\n        return list(self._services.keys())\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Shuts down all resolved services that have a cleanup method.</p> <p>Iterates through all cached services and calls a <code>shutdown()</code> or <code>close()</code> method if one exists, handling both sync and async methods.</p> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shuts down all resolved services that have a cleanup method.\n\n    Iterates through all cached services and calls a `shutdown()` or\n    `close()` method if one exists, handling both sync and async methods.\n    \"\"\"\n    services = []\n    with self._lock:\n        services = list(self._services.items())\n        obs_ref = self._obs\n        self._services.clear()\n        self._store.clear()\n        self._obs = None\n    for key, instance in services:\n        try:\n            shutdown_func = getattr(instance, \"shutdown\", None)\n            if shutdown_func and callable(shutdown_func):\n                is_async_shutdown = asyncio.iscoroutinefunction(shutdown_func)\n                if is_async_shutdown:\n                    await asyncio.wait_for(shutdown_func(), timeout=5.0)\n                else:\n                    shutdown_func()\n                self._log(\n                    logging.DEBUG,\n                    \"Shutting down service\",\n                    extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n                )\n            elif isinstance(instance, ObservabilityProtocol) and not isinstance(\n                instance, type\n            ):\n                instance.close()\n                self._log(\n                    logging.DEBUG,\n                    \"Closing observability service\",\n                    extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n                )\n        except (RuntimeError, TypeError, TimeoutError) as exc:\n            self._log(\n                logging.ERROR,\n                f\"Shutdown failed: {exc}\",\n                extra={\"service_name\": _key_name(key[0]), \"svc_alias\": key[1]},\n            )\n    if obs_ref and hasattr(obs_ref, \"close\"):\n        with suppress(Exception):\n            obs_ref.close()\n    self._log(logging.INFO, \"DIContainer shutdown\", extra={})\n</code></pre>"},{"location":"reference/core/di.html#bijux_cli.core.di.DIContainer.unregister","title":"unregister","text":"<pre><code>unregister(\n    key: type[Any] | str, name: str | None = None\n) -&gt; bool\n</code></pre> <p>Unregisters a service factory and removes any cached instance.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>type[Any] | str</code>)           \u2013            <p>The service key to unregister.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the registration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if a service was found and unregistered, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/core/di.py</code> <pre><code>def unregister(self, key: type[Any] | str, name: str | None = None) -&gt; bool:\n    \"\"\"Unregisters a service factory and removes any cached instance.\n\n    Args:\n        key (type[Any] | str): The service key to unregister.\n        name (str | None): An optional name for the registration.\n\n    Returns:\n        bool: True if a service was found and unregistered, otherwise False.\n    \"\"\"\n    with self._lock:\n        store_key = (key, name)\n        removed = self._store.pop(store_key, None) is not None\n        if store_key in self._services and isinstance(\n            self._services[store_key], ObservabilityProtocol\n        ):\n            self._obs = None\n        self._services.pop(store_key, None)\n        if removed:\n            self._log(\n                logging.INFO,\n                \"Unregistered service\",\n                extra={\"service_name\": _key_name(key), \"svc_alias\": name},\n            )\n        return removed\n</code></pre>"},{"location":"reference/core/engine.html","title":"Engine Module API Reference","text":"<p>This section documents the internals of the <code>engine</code> module in Bijux CLI. </p>"},{"location":"reference/core/engine.html#bijux_cli.core.engine","title":"bijux_cli.core.engine","text":"<p>Provides the core runtime engine for the Bijux CLI.</p> <p>This module defines the <code>Engine</code> class, which is responsible for orchestrating the application's runtime environment after initial setup. Its key responsibilities include:</p> <pre><code>* Initializing and registering all default services with the Dependency\n    Injection (DI) container.\n* Discovering, loading, and registering all external plugins.\n* Providing a central method for dispatching commands to plugins.\n* Managing the graceful shutdown of services.\n</code></pre> <p>The engine acts as the bridge between the CLI command layer and the underlying services and plugins.</p>"},{"location":"reference/core/engine.html#bijux_cli.core.engine.Engine","title":"Engine","text":"<pre><code>Engine(\n    di: Any = None,\n    *,\n    debug: bool = False,\n    fmt: OutputFormat = JSON,\n    quiet: bool = False,\n)\n</code></pre> <p>Orchestrates the CLI's runtime services and plugin lifecycle.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>DIContainer</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_debug</code>               (<code>bool</code>)           \u2013            <p>The debug mode flag.</p> </li> <li> <code>_format</code>               (<code>OutputFormat</code>)           \u2013            <p>The default output format.</p> </li> <li> <code>_quiet</code>               (<code>bool</code>)           \u2013            <p>The quiet mode flag.</p> </li> <li> <code>_registry</code>               (<code>RegistryProtocol</code>)           \u2013            <p>The plugin registry service.</p> </li> </ul> <p>Initializes the engine and its core services.</p> <p>This sets up the DI container, registers default services, and loads all discoverable plugins.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>An existing dependency injection container. If None, the global singleton instance is used. Defaults to None.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug mode for services.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The default output format for services.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses output from services.</p> </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>def __init__(\n    self,\n    di: Any = None,\n    *,\n    debug: bool = False,\n    fmt: OutputFormat = OutputFormat.JSON,\n    quiet: bool = False,\n) -&gt; None:\n    \"\"\"Initializes the engine and its core services.\n\n    This sets up the DI container, registers default services, and loads\n    all discoverable plugins.\n\n    Args:\n        di (Any, optional): An existing dependency injection container. If\n            None, the global singleton instance is used. Defaults to None.\n        debug (bool): If True, enables debug mode for services.\n        fmt (OutputFormat): The default output format for services.\n        quiet (bool): If True, suppresses output from services.\n    \"\"\"\n    from bijux_cli.core.di import DIContainer\n\n    self._di = di or DIContainer.current()\n    self._debug = debug\n    self._format = fmt\n    self._quiet = quiet\n    self._di.register(Observability, lambda: Observability(debug=debug))\n    register_default_services(self._di, debug=debug, output_format=fmt, quiet=quiet)\n    self._di.register(Engine, self)\n    self._registry: RegistryProtocol = self._di.resolve(RegistryProtocol)\n    self._register_plugins()\n</code></pre>"},{"location":"reference/core/engine.html#bijux_cli.core.engine.Engine.di","title":"di  <code>property</code>","text":"<pre><code>di: DIContainer\n</code></pre> <p>Read-only access to the DI container.</p>"},{"location":"reference/core/engine.html#bijux_cli.core.engine.Engine.run_command","title":"run_command  <code>async</code>","text":"<pre><code>run_command(name: str, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Executes a plugin's command with a configured timeout.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command or plugin to run.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the plugin's <code>execute</code> method.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the plugin's <code>execute</code> method.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The result of the command's execution.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the plugin is not found, its <code>execute</code> method is invalid, or if it fails during execution.</p> </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def run_command(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Executes a plugin's command with a configured timeout.\n\n    Args:\n        name (str): The name of the command or plugin to run.\n        *args (Any): Positional arguments to pass to the plugin's `execute`\n            method.\n        **kwargs (Any): Keyword arguments to pass to the plugin's `execute`\n            method.\n\n    Returns:\n        Any: The result of the command's execution.\n\n    Raises:\n        CommandError: If the plugin is not found, its `execute` method\n            is invalid, or if it fails during execution.\n    \"\"\"\n    plugin = self._registry.get(name)\n    execute = getattr(plugin, \"execute\", None)\n    if not callable(execute):\n        raise CommandError(\n            f\"Plugin '{name}' has no callable 'execute' method.\", http_status=404\n        )\n    if not inspect.iscoroutinefunction(execute):\n        raise CommandError(\n            f\"Plugin '{name}' 'execute' is not async/coroutine.\", http_status=400\n        )\n    try:\n        return await asyncio.wait_for(execute(*args, **kwargs), self._timeout())\n    except Exception as exc:  # pragma: no cover\n        raise CommandError(f\"Failed to run plugin '{name}': {exc}\") from exc\n</code></pre>"},{"location":"reference/core/engine.html#bijux_cli.core.engine.Engine.run_repl","title":"run_repl  <code>async</code>","text":"<pre><code>run_repl() -&gt; None\n</code></pre> <p>Runs the interactive shell (REPL).</p> <p>Note: This is a placeholder for future REPL integration.</p> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def run_repl(self) -&gt; None:\n    \"\"\"Runs the interactive shell (REPL).\n\n    Note: This is a placeholder for future REPL integration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/core/engine.html#bijux_cli.core.engine.Engine.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Gracefully shuts down the engine and all resolved services.</p> <p>This method orchestrates the termination sequence for the application's runtime. It first attempts to flush any buffered command history to disk and then proceeds to shut down the main dependency injection container, which in turn cleans up all resolved services.</p> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/core/engine.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Gracefully shuts down the engine and all resolved services.\n\n    This method orchestrates the termination sequence for the application's\n    runtime. It first attempts to flush any buffered command history to\n    disk and then proceeds to shut down the main dependency injection\n    container, which in turn cleans up all resolved services.\n\n    Returns:\n        None:\n    \"\"\"\n    try:\n        self._di.resolve(History).flush()\n    except KeyError:\n        pass\n    finally:\n        await self._di.shutdown()\n</code></pre>"},{"location":"reference/core/enums.html","title":"Enums Module API Reference","text":"<p>This section documents the internals of the <code>enums</code> module in Bijux CLI. </p>"},{"location":"reference/core/enums.html#bijux_cli.core.enums","title":"bijux_cli.core.enums","text":"<p>Defines the output format enumeration for the Bijux CLI.</p> <p>This module provides the <code>OutputFormat</code> enum, which represents the supported structured output formats (JSON and YAML). Using an enum ensures type safety and provides a single source of truth for format names. It also includes a mechanism for case-insensitive matching.</p>"},{"location":"reference/core/enums.html#bijux_cli.core.enums.OutputFormat","title":"OutputFormat","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Specifies the supported structured output formats for CLI responses.</p> <p>This enum supports case-insensitive matching, so <code>OutputFormat(\"JSON\")</code> and <code>OutputFormat(\"yaml\")</code> are both valid.</p>"},{"location":"reference/core/exceptions.html","title":"Exceptions Module API Reference","text":"<p>This section documents the internals of the <code>exceptions</code> module in Bijux CLI. </p>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions","title":"bijux_cli.core.exceptions","text":"<p>Defines the custom exception hierarchy for the Bijux CLI.</p> <p>This module provides a set of custom exception classes that inherit from the base <code>BijuxError</code>. This hierarchy allows for more specific error handling and helps standardize error reporting throughout the application. Each exception can carry contextual information, such as the command that was running when the error occurred.</p>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.BijuxError","title":"BijuxError","text":"<pre><code>BijuxError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all custom errors in the Bijux CLI.</p> <p>Attributes:</p> <ul> <li> <code>command</code>               (<code>str | None</code>)           \u2013            <p>The name of the command being executed when the error occurred.</p> </li> <li> <code>http_status</code>               (<code>int</code>)           \u2013            <p>An HTTP-like status code used to derive the final CLI exit code.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code.</p> </li> </ul> <p>Initialize the base BijuxError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the base BijuxError exception.\"\"\"\n    self.command = command\n    self.http_status = http_status if http_status is not None else 500\n    super().__init__(message)\n</code></pre>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.CliTimeoutError","title":"CliTimeoutError","text":"<pre><code>CliTimeoutError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>BijuxError</code></p> <p>Raised for timeout errors (deprecated).</p> Note <p>This exception is deprecated. Use <code>CommandError</code> or Python's built-in <code>TimeoutError</code> for new code.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 504.</p> </li> </ul> <p>Initialize the CliTimeoutError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the CliTimeoutError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 504,\n    )\n</code></pre>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.CommandError","title":"CommandError","text":"<pre><code>CommandError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>BijuxError</code></p> <p>Raised for command execution failures.</p> <p>This exception is used for command-specific errors, such as invalid arguments or missing resources, that represent a client-side error.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the CommandError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the CommandError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.ConfigError","title":"ConfigError","text":"<pre><code>ConfigError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>BijuxError</code></p> <p>Raised for configuration loading or parsing failures.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the ConfigError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ConfigError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.ServiceError","title":"ServiceError","text":"<pre><code>ServiceError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>BijuxError</code></p> <p>Raised for service-related failures.</p> <p>This exception is used for errors originating from core services like Observability, Telemetry, or the Registry.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 500.</p> </li> </ul> <p>Initialize the ServiceError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ServiceError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 500,\n    )\n</code></pre>"},{"location":"reference/core/exceptions.html#bijux_cli.core.exceptions.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n)\n</code></pre> <p>               Bases: <code>BijuxError</code></p> <p>Raised for validation failures (deprecated).</p> Note <p>This exception is deprecated. Use <code>CommandError</code> for new code.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The human-readable error message.</p> </li> <li> <code>command</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the command.</p> </li> <li> <code>http_status</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The associated status code. Defaults to 400.</p> </li> </ul> <p>Initialize the ValidationError exception.</p> Source code in <code>src/bijux_cli/core/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    command: str | None = None,\n    http_status: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ValidationError exception.\"\"\"\n    super().__init__(\n        message,\n        command=command,\n        http_status=http_status if http_status is not None else 400,\n    )\n</code></pre>"},{"location":"reference/core/paths.html","title":"Paths Module API Reference","text":"<p>This section documents the internals of the <code>paths</code> module in Bijux CLI. </p>"},{"location":"reference/core/paths.html#bijux_cli.core.paths","title":"bijux_cli.core.paths","text":"<p>Defines core paths for the Bijux CLI's persistent files.</p> <p>This module centralizes the default filesystem locations for all user-specific data, such as configuration, command history, and plugins. This provides a single source of truth for file paths and simplifies management of persistent state. All paths are relative to the user's home directory within a <code>.bijux</code> folder.</p>"},{"location":"reference/infra/index.html","title":"Reference / Infra Index","text":"<ul> <li>Emitter Module</li> <li>Observability Module</li> <li>Process Module</li> <li>Retry Module</li> <li>Serializer Module</li> <li>Telemetry Module</li> </ul>"},{"location":"reference/infra/emitter.html","title":"Emitter Module API Reference","text":"<p>This section documents the internals of the <code>emitter</code> module in Bijux CLI. </p>"},{"location":"reference/infra/emitter.html#bijux_cli.infra.emitter","title":"bijux_cli.infra.emitter","text":"<p>Provides the concrete implementation of the structured output emitter service.</p> <p>This module defines the <code>Emitter</code> class, which implements the <code>EmitterProtocol</code>. It is responsible for serializing data payloads into structured formats like JSON or YAML and writing them to standard output or a specified file. The service also integrates with telemetry to log emission events.</p>"},{"location":"reference/infra/emitter.html#bijux_cli.infra.emitter.Emitter","title":"Emitter","text":"<pre><code>Emitter(\n    telemetry: TelemetryProtocol,\n    output_format: OutputFormat = JSON,\n    debug: bool = False,\n    quiet: bool = False,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>EmitterProtocol</code></p> <p>A service for serializing and emitting structured output.</p> <p>This class implements the <code>EmitterProtocol</code>. It handles the serialization of data payloads and writes the result to standard output or a file, while also tracking events with a telemetry service.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>_default_format</code>               (<code>OutputFormat</code>)           \u2013            <p>The default format for serialization.</p> </li> <li> <code>_debug</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if debug mode is enabled.</p> </li> <li> <code>_quiet</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if normal output should be suppressed.</p> </li> <li> <code>_logger</code>           \u2013            <p>A configured <code>structlog</code> logger instance.</p> </li> </ul> <p>Initializes the Emitter service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>output_format</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The default output format for emissions.</p> </li> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug logging.</p> </li> <li> <code>quiet</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, suppresses all non-error output.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments (unused).</p> </li> </ul> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    telemetry: TelemetryProtocol,\n    output_format: OutputFormat = OutputFormat.JSON,\n    debug: bool = False,\n    quiet: bool = False,\n    **kwargs: Any,\n):\n    \"\"\"Initializes the Emitter service.\n\n    Args:\n        telemetry (TelemetryProtocol): The telemetry service for event tracking.\n        output_format (OutputFormat): The default output format for emissions.\n        debug (bool): If True, enables debug logging.\n        quiet (bool): If True, suppresses all non-error output.\n        **kwargs: Additional keyword arguments (unused).\n    \"\"\"\n    self._telemetry = telemetry\n    self._default_format = output_format\n    self._debug = debug\n    self._quiet = quiet\n    self._logger = structlog.get_logger(__name__)\n</code></pre>"},{"location":"reference/infra/emitter.html#bijux_cli.infra.emitter.Emitter.emit","title":"emit","text":"<pre><code>emit(\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None\n</code></pre> <p>Serializes and emits a structured data payload.</p> <p>The payload is serialized to the specified format and written to stdout or a file path if provided. The operation is suppressed if the emitter is in quiet mode and the log level is not critical.</p> <p>Parameters:</p> <ul> <li> <code>payload</code>               (<code>Any</code>)           \u2013            <p>The data payload to serialize and emit.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format. If None, the service's default format is used.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'info'</code> )           \u2013            <p>The log level for any accompanying message (e.g., \"info\", \"debug\", \"error\").</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>'Emitting output'</code> )           \u2013            <p>A descriptive message for logging purposes.</p> </li> <li> <code>output</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional file path to write the output to. If None, output is written to <code>sys.stdout</code>.</p> </li> <li> <code>**context</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional key-value pairs for structured logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the payload cannot be serialized.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>def emit(\n    self,\n    payload: Any,\n    *,\n    fmt: OutputFormat | None = None,\n    pretty: bool = False,\n    level: str = \"info\",\n    message: str = \"Emitting output\",\n    output: str | None = None,\n    **context: Any,\n) -&gt; None:\n    \"\"\"Serializes and emits a structured data payload.\n\n    The payload is serialized to the specified format and written to stdout\n    or a file path if provided. The operation is suppressed if the emitter\n    is in quiet mode and the log level is not critical.\n\n    Args:\n        payload (Any): The data payload to serialize and emit.\n        fmt (OutputFormat | None): The output format. If None, the service's\n            default format is used.\n        pretty (bool): If True, formats the output for human readability.\n        level (str): The log level for any accompanying message (e.g.,\n            \"info\", \"debug\", \"error\").\n        message (str): A descriptive message for logging purposes.\n        output (str | None): An optional file path to write the output to.\n            If None, output is written to `sys.stdout`.\n        **context (Any): Additional key-value pairs for structured logging.\n\n    Returns:\n        None:\n\n    Raises:\n        CommandError: If the payload cannot be serialized.\n    \"\"\"\n    if self._quiet and level not in [\"error\", \"critical\"]:\n        return\n\n    output_format = fmt or self._default_format\n    serializer = serializer_for(output_format, self._telemetry)\n    try:\n        output_str = serializer.dumps(payload, fmt=output_format, pretty=pretty)\n    except Exception as error:\n        self._logger.error(\"Serialization failed\", error=str(error), **context)\n        raise CommandError(\n            f\"Serialization failed: {error}\", http_status=500\n        ) from error\n\n    stripped = output_str.rstrip(\"\\n\")\n\n    if output:\n        with open(output, \"w\", encoding=\"utf-8\") as f:\n            f.write(stripped)\n    else:\n        print(stripped, file=sys.stdout, flush=True)\n\n    if self._debug:\n        print(\"Diagnostics: emitted payload\", file=sys.stderr)\n        log = getattr(self._logger, level)\n        log(message, output=stripped, **context)\n\n    try:\n        self._telemetry.event(\n            \"output_emitted\",\n            {\"format\": output_format.value, \"size_chars\": len(stripped)},\n        )\n    except Exception as tel_err:\n        if self._debug:\n            self._logger.error(\"Telemetry failed\", error=str(tel_err), **context)\n</code></pre>"},{"location":"reference/infra/emitter.html#bijux_cli.infra.emitter.Emitter.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Flushes any buffered output to standard output.</p> Source code in <code>src/bijux_cli/infra/emitter.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Flushes any buffered output to standard output.\"\"\"\n    sys.stdout.flush()\n</code></pre>"},{"location":"reference/infra/observability.html","title":"Observability Module API Reference","text":"<p>This section documents the internals of the <code>observability</code> module in Bijux CLI. </p>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability","title":"bijux_cli.infra.observability","text":"<p>Provides the concrete implementation of the observability and logging service.</p> <p>This module defines the <code>Observability</code> class, which implements the <code>ObservabilityProtocol</code>. It serves as the primary interface for structured logging throughout the application, using <code>structlog</code> as its underlying engine. It can also be configured to forward log entries to a telemetry backend, unifying logging and event tracking.</p>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability","title":"Observability","text":"<pre><code>Observability(*, debug: bool = False)\n</code></pre> <p>               Bases: <code>ObservabilityProtocol</code></p> <p>A structured logging service integrating <code>structlog</code> and telemetry.</p> <p>This class wraps a <code>structlog</code> logger to produce structured log entries. If configured with a telemetry backend, it also forwards these events for analytics and monitoring.</p> <p>Attributes:</p> <ul> <li> <code>_logger</code>               (<code>FilteringBoundLogger</code>)           \u2013            <p>The underlying <code>structlog</code> logger instance.</p> </li> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event forwarding. Defaults to a <code>NullTelemetry</code> instance that does nothing.</p> </li> </ul> <p>Initializes the observability service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, configures the service for debug-level logging.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>@inject\ndef __init__(self, *, debug: bool = False) -&gt; None:\n    \"\"\"Initializes the observability service.\n\n    Args:\n        debug (bool): If True, configures the service for debug-level\n            logging.\n    \"\"\"\n    self._logger: FilteringBoundLogger = structlog.get_logger(\"bijux_cli\")\n    self._telemetry: TelemetryProtocol = NullTelemetry()\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.bind","title":"bind","text":"<pre><code>bind(**kwargs: Any) -&gt; Self\n</code></pre> <p>Binds context key-value pairs to all subsequent log entries.</p> <p>Parameters:</p> <ul> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Context values to include in each log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def bind(self, **kwargs: Any) -&gt; Self:\n    \"\"\"Binds context key-value pairs to all subsequent log entries.\n\n    Args:\n        **kwargs (Any): Context values to include in each log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    self._logger = self._logger.bind(**kwargs)\n    return self\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Logs the shutdown of the observability service.</p> Note <p>In this implementation, this method only logs a debug message and does not perform resource cleanup like flushing. Flushing is handled by the telemetry service's own lifecycle methods.</p> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Logs the shutdown of the observability service.\n\n    Note:\n        In this implementation, this method only logs a debug message and\n        does not perform resource cleanup like flushing. Flushing is\n        handled by the telemetry service's own lifecycle methods.\n    \"\"\"\n    self._logger.debug(\"Observability shutdown\")\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.get_logger","title":"get_logger","text":"<pre><code>get_logger() -&gt; FilteringBoundLogger\n</code></pre> <p>Retrieves the underlying <code>structlog</code> logger instance.</p> <p>Returns:</p> <ul> <li> <code>FilteringBoundLogger</code> (              <code>FilteringBoundLogger</code> )          \u2013            <p>The <code>structlog</code> logger, which can be used directly if needed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def get_logger(self) -&gt; FilteringBoundLogger:\n    \"\"\"Retrieves the underlying `structlog` logger instance.\n\n    Returns:\n        FilteringBoundLogger: The `structlog` logger, which can be used\n            directly if needed.\n    \"\"\"\n    return self._logger\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.log","title":"log","text":"<pre><code>log(\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self\n</code></pre> <p>Logs a structured message and emits a corresponding telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>level</code>               (<code>str</code>)           \u2013            <p>The severity level of the log (e.g., 'debug', 'info', 'warning', 'error', 'critical').</p> </li> <li> <code>msg</code>               (<code>str</code>)           \u2013            <p>The log message.</p> </li> <li> <code>extra</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional context to include in the log entry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If <code>level</code> is not a valid log level name.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def log(\n    self,\n    level: str,\n    msg: str,\n    *,\n    extra: dict[str, Any] | None = None,\n) -&gt; Self:\n    \"\"\"Logs a structured message and emits a corresponding telemetry event.\n\n    Args:\n        level (str): The severity level of the log (e.g., 'debug', 'info',\n            'warning', 'error', 'critical').\n        msg (str): The log message.\n        extra (dict[str, Any] | None): Additional context to include in the\n            log entry.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n\n    Raises:\n        ServiceError: If `level` is not a valid log level name.\n    \"\"\"\n    log_func = getattr(self._logger, level.lower(), None)\n    if not callable(log_func):\n        raise ServiceError(f\"Invalid log level: {level}\")\n\n    log_context = extra or {}\n    if log_context:\n        log_func(msg, **log_context)\n    else:\n        log_func(msg)\n\n    if not isinstance(self._telemetry, NullTelemetry):\n        telemetry_payload = {\"level\": level, \"message\": msg}\n        telemetry_payload.update(log_context)\n        self._telemetry.event(\"LOG_EMITTED\", telemetry_payload)\n\n    return self\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.set_telemetry","title":"set_telemetry","text":"<pre><code>set_telemetry(telemetry: TelemetryProtocol) -&gt; Self\n</code></pre> <p>Attaches a telemetry backend for forwarding log events.</p> <p>This allows the service to be \"upgraded\" from a simple logger to a full observability tool after its initial creation.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service to receive events.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>The service instance, allowing for method chaining.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>def set_telemetry(self, telemetry: TelemetryProtocol) -&gt; Self:\n    \"\"\"Attaches a telemetry backend for forwarding log events.\n\n    This allows the service to be \"upgraded\" from a simple logger to a full\n    observability tool after its initial creation.\n\n    Args:\n        telemetry (TelemetryProtocol): The telemetry service to receive events.\n\n    Returns:\n        Self: The service instance, allowing for method chaining.\n    \"\"\"\n    self._telemetry = telemetry\n    return self\n</code></pre>"},{"location":"reference/infra/observability.html#bijux_cli.infra.observability.Observability.setup","title":"setup  <code>classmethod</code>","text":"<pre><code>setup(*, debug: bool = False) -&gt; Self\n</code></pre> <p>Instantiates and configures an <code>Observability</code> service.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, enables debug-level logging.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>A new, configured <code>Observability</code> instance.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/observability.py</code> <pre><code>@classmethod\ndef setup(cls, *, debug: bool = False) -&gt; Self:\n    \"\"\"Instantiates and configures an `Observability` service.\n\n    Args:\n        debug (bool): If True, enables debug-level logging.\n\n    Returns:\n        Self: A new, configured `Observability` instance.\n    \"\"\"\n    return cls(debug=debug)\n</code></pre>"},{"location":"reference/infra/process.html","title":"Process Module API Reference","text":"<p>This section documents the internals of the <code>process</code> module in Bijux CLI. </p>"},{"location":"reference/infra/process.html#bijux_cli.infra.process","title":"bijux_cli.infra.process","text":"<p>Provides a process pool service for executing external commands.</p> <p>This module defines the <code>ProcessPool</code> class, a concrete implementation of the <code>ProcessPoolProtocol</code>. It is designed to run shell commands in isolated subprocesses using a managed pool of workers. Key features include command validation to prevent shell injection and an in-memory LRU cache to return results for repeated commands without re-execution.</p>"},{"location":"reference/infra/process.html#bijux_cli.infra.process.ProcessPool","title":"ProcessPool","text":"<pre><code>ProcessPool(\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    max_workers: int = 4,\n)\n</code></pre> <p>               Bases: <code>ProcessPoolProtocol</code></p> <p>Executes validated commands in a worker pool with an LRU cache.</p> <p>This class manages a <code>ProcessPoolExecutor</code> to run commands in separate processes. It maintains a cache of recent command results to avoid unnecessary re-execution.</p> <p>Attributes:</p> <ul> <li> <code>_MAX_CACHE</code>               (<code>int</code>)           \u2013            <p>The maximum number of command results to store in the LRU cache.</p> </li> <li> <code>_exec</code>               (<code>ProcessPoolExecutor</code>)           \u2013            <p>The underlying executor for running tasks.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service.</p> </li> <li> <code>_cache</code>               (<code>OrderedDict</code>)           \u2013            <p>An LRU cache storing tuples of command arguments to their results <code>(returncode, stdout, stderr)</code>.</p> </li> </ul> <p>Initializes the <code>ProcessPool</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>max_workers</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The maximum number of worker processes. This can be overridden by the <code>BIJUXCLI_MAX_WORKERS</code> environment variable.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    max_workers: int = 4,\n) -&gt; None:\n    \"\"\"Initializes the `ProcessPool` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        max_workers (int): The maximum number of worker processes. This can\n            be overridden by the `BIJUXCLI_MAX_WORKERS` environment variable.\n    \"\"\"\n    max_workers = int(os.getenv(\"BIJUXCLI_MAX_WORKERS\", str(max_workers)))\n    self._exec = ProcessPoolExecutor(max_workers=max_workers)\n    self._log = observability\n    self._tel = telemetry\n    self._cache: OrderedDict[tuple[str, ...], tuple[int, bytes, bytes]] = (\n        OrderedDict()\n    )\n</code></pre>"},{"location":"reference/infra/process.html#bijux_cli.infra.process.ProcessPool.get_status","title":"get_status","text":"<pre><code>get_status() -&gt; dict[str, Any]\n</code></pre> <p>Returns the current status of the process pool.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A dictionary containing status information, such as the number of commands processed (and cached).</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def get_status(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the current status of the process pool.\n\n    Returns:\n        dict[str, Any]: A dictionary containing status information, such as\n            the number of commands processed (and cached).\n    \"\"\"\n    return {\"commands_processed\": len(self._cache)}\n</code></pre>"},{"location":"reference/infra/process.html#bijux_cli.infra.process.ProcessPool.run","title":"run","text":"<pre><code>run(\n    cmd: list[str], *, executor: str\n) -&gt; tuple[int, bytes, bytes]\n</code></pre> <p>Executes a command in the process pool, using a cache.</p> <p>The command is first looked up in the LRU cache. If not found, it is validated and then executed in a subprocess. The result is then stored in the cache.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and its arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity requesting the execution, used for telemetry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the command's return code, standard output, and standard error.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If command validation fails or if an unexpected error occurs during subprocess execution.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Executes a command in the process pool, using a cache.\n\n    The command is first looked up in the LRU cache. If not found, it is\n    validated and then executed in a subprocess. The result is then stored\n    in the cache.\n\n    Args:\n        cmd (list[str]): The command and its arguments to execute.\n        executor (str): The name of the entity requesting the execution,\n            used for telemetry.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the command's return\n            code, standard output, and standard error.\n\n    Raises:\n        BijuxError: If command validation fails or if an unexpected error\n            occurs during subprocess execution.\n    \"\"\"\n    from bijux_cli.services.utils import validate_command\n\n    key = tuple(cmd)\n    if key in self._cache:\n        self._log.log(\"debug\", \"Process-pool cache hit\", extra={\"cmd\": cmd})\n        self._tel.event(\"procpool_cache_hit\", {\"cmd\": cmd, \"executor\": executor})\n        self._cache.move_to_end(key)\n        return self._cache[key]\n\n    try:\n        safe_cmd = validate_command(cmd)\n        self._log.log(\"info\", \"Process-pool executing\", extra={\"cmd\": safe_cmd})\n        self._tel.event(\"procpool_execute\", {\"cmd\": safe_cmd, \"executor\": executor})\n\n        result = subprocess.run(  # noqa: S603 # nosec B603\n            safe_cmd,\n            capture_output=True,\n            check=False,\n            shell=False,\n        )\n\n        self._cache[key] = (result.returncode, result.stdout, result.stderr)\n        self._cache.move_to_end(key)\n        if len(self._cache) &gt; self._MAX_CACHE:\n            self._cache.popitem(last=False)\n\n        self._tel.event(\n            \"procpool_executed\",\n            {\n                \"cmd\": safe_cmd,\n                \"executor\": executor,\n                \"returncode\": result.returncode,\n            },\n        )\n        return result.returncode, result.stdout, result.stderr\n\n    except BijuxError:\n        self._tel.event(\n            \"procpool_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": \"validation\"},\n        )\n        raise\n    except Exception as exc:\n        self._tel.event(\n            \"procpool_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(exc)},\n        )\n        raise BijuxError(f\"Process-pool execution failed: {exc}\") from exc\n</code></pre>"},{"location":"reference/infra/process.html#bijux_cli.infra.process.ProcessPool.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>Gracefully shuts down the worker process pool.</p> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Gracefully shuts down the worker process pool.\"\"\"\n    self._exec.shutdown(wait=True)\n    self._tel.event(\"procpool_shutdown\", {})\n    self._log.log(\"debug\", \"Process-pool shutdown\")\n</code></pre>"},{"location":"reference/infra/process.html#bijux_cli.infra.process.get_process_pool","title":"get_process_pool","text":"<pre><code>get_process_pool(\n    logger: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n) -&gt; ProcessPoolProtocol\n</code></pre> <p>A factory function for creating a <code>ProcessPool</code> instance.</p> <p>This helper respects the <code>BIJUXCLI_MAX_WORKERS</code> environment variable to configure the number of worker processes.</p> <p>Parameters:</p> <ul> <li> <code>logger</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service instance.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ProcessPoolProtocol</code> (              <code>ProcessPoolProtocol</code> )          \u2013            <p>A configured instance of the process pool service.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/process.py</code> <pre><code>def get_process_pool(\n    logger: ObservabilityProtocol, telemetry: TelemetryProtocol\n) -&gt; ProcessPoolProtocol:\n    \"\"\"A factory function for creating a `ProcessPool` instance.\n\n    This helper respects the `BIJUXCLI_MAX_WORKERS` environment variable to\n    configure the number of worker processes.\n\n    Args:\n        logger (ObservabilityProtocol): The logging service instance.\n        telemetry (TelemetryProtocol): The telemetry service instance.\n\n    Returns:\n        ProcessPoolProtocol: A configured instance of the process pool service.\n    \"\"\"\n    workers = int(os.getenv(\"BIJUXCLI_MAX_WORKERS\", \"4\"))\n    return ProcessPool(logger, telemetry, max_workers=workers)\n</code></pre>"},{"location":"reference/infra/retry.html","title":"Retry Module API Reference","text":"<p>This section documents the internals of the <code>retry</code> module in Bijux CLI. </p>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry","title":"bijux_cli.infra.retry","text":"<p>Provides concrete asynchronous retry policy implementations.</p> <p>This module defines classes that implement the <code>RetryPolicyProtocol</code> to handle transient errors in asynchronous operations. It offers two main strategies:</p> <pre><code>* `TimeoutRetryPolicy`: A simple policy that applies a single timeout to an\n    operation.\n* `ExponentialBackoffRetryPolicy`: A more advanced policy that retries an\n    operation multiple times with an exponentially increasing delay and\n    random jitter between attempts.\n</code></pre> <p>These components are designed to be used by services to build resilience against temporary failures, such as network issues.</p>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy","title":"ExponentialBackoffRetryPolicy","text":"<pre><code>ExponentialBackoffRetryPolicy(telemetry: TelemetryProtocol)\n</code></pre> <p>               Bases: <code>RetryPolicyProtocol</code></p> <p>A retry policy with exponential backoff, jitter, and per-attempt timeouts.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting telemetry events.</p> </li> </ul> <p>Initializes the <code>ExponentialBackoffRetryPolicy</code>.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `ExponentialBackoffRetryPolicy`.\n\n    Args:\n        telemetry (TelemetryProtocol): The service for emitting events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the retry policy state. This is a no-op for this policy.</p> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the retry policy state. This is a no-op for this policy.\"\"\"\n    self._telemetry.event(\"retry_reset\", {})\n</code></pre>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.ExponentialBackoffRetryPolicy.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n    retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    jitter: float = 0.3,\n    retry_on: tuple[type[BaseException], ...] = (\n        Exception,\n    ),\n) -&gt; T\n</code></pre> <p>Executes a supplier with a timeout and exponential-backoff retries.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>The async operation to run.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout for each attempt in seconds. Must be &gt; 0.</p> </li> <li> <code>retries</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The maximum number of retry attempts.</p> </li> <li> <code>delay</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The initial delay in seconds before the first retry.</p> </li> <li> <code>backoff</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The multiplier for the delay after each failure.</p> </li> <li> <code>jitter</code>               (<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The random fractional jitter to apply to each delay.</p> </li> <li> <code>retry_on</code>               (<code>tuple[type[BaseException], ...]</code>, default:                   <code>(Exception,)</code> )           \u2013            <p>A tuple of exception types that will trigger a retry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The result of the <code>supplier</code> if one of the attempts succeeds.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>seconds</code> is less than or equal to 0.</p> </li> <li> <code>BaseException</code>             \u2013            <p>The last exception raised by <code>supplier</code> if all attempts fail.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>async def run(\n    self,\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n    retries: int = 3,\n    delay: float = 1.0,\n    backoff: float = 2.0,\n    jitter: float = 0.3,\n    retry_on: tuple[type[BaseException], ...] = (Exception,),\n) -&gt; T:\n    \"\"\"Executes a supplier with a timeout and exponential-backoff retries.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): The async operation to run.\n        seconds (float): The timeout for each attempt in seconds. Must be &gt; 0.\n        retries (int): The maximum number of retry attempts.\n        delay (float): The initial delay in seconds before the first retry.\n        backoff (float): The multiplier for the delay after each failure.\n        jitter (float): The random fractional jitter to apply to each delay.\n        retry_on (tuple[type[BaseException], ...]): A tuple of exception\n            types that will trigger a retry.\n\n    Returns:\n        T: The result of the `supplier` if one of the attempts succeeds.\n\n    Raises:\n        ValueError: If `seconds` is less than or equal to 0.\n        BaseException: The last exception raised by `supplier` if all\n            attempts fail.\n    \"\"\"\n    if seconds &lt;= 0:\n        raise ValueError(\"seconds must be &gt; 0\")\n\n    ctx = _try_asyncio_timeout(seconds)\n\n    if ctx is not None:\n        async with ctx:\n            return await _backoff_loop(\n                supplier,\n                retries=retries,\n                delay=delay,\n                backoff=backoff,\n                jitter=jitter,\n                retry_on=retry_on,\n                telemetry=self._telemetry,\n            )\n    else:\n\n        async def timed_supplier() -&gt; T:\n            \"\"\"Wraps the supplier in an `asyncio.wait_for` timeout.\n\n            Returns:\n                T: The result of the `supplier` if it completes in time.\n            \"\"\"\n            return await asyncio.wait_for(supplier(), timeout=seconds)\n\n        return await _backoff_loop(\n            timed_supplier,\n            retries=retries,\n            delay=delay,\n            backoff=backoff,\n            jitter=jitter,\n            retry_on=retry_on,\n            telemetry=self._telemetry,\n        )\n</code></pre>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.TimeoutRetryPolicy","title":"TimeoutRetryPolicy","text":"<pre><code>TimeoutRetryPolicy(telemetry: TelemetryProtocol)\n</code></pre> <p>               Bases: <code>RetryPolicyProtocol</code></p> <p>A retry policy that applies a single, one-time timeout to an operation.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting telemetry events.</p> </li> </ul> <p>Initializes the <code>TimeoutRetryPolicy</code>.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for emitting events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `TimeoutRetryPolicy`.\n\n    Args:\n        telemetry (TelemetryProtocol): The service for emitting events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.TimeoutRetryPolicy.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Resets the retry policy state. This is a no-op for this policy.</p> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Resets the retry policy state. This is a no-op for this policy.\"\"\"\n    self._telemetry.event(\"retry_reset\", {})\n</code></pre>"},{"location":"reference/infra/retry.html#bijux_cli.infra.retry.TimeoutRetryPolicy.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n) -&gt; T\n</code></pre> <p>Executes an awaitable <code>supplier</code> with a single timeout.</p> <p>This method uses the modern <code>asyncio.timeout</code> context manager if available, otherwise it falls back to <code>asyncio.wait_for</code>.</p> <p>Parameters:</p> <ul> <li> <code>supplier</code>               (<code>Callable[[], Awaitable[T]]</code>)           \u2013            <p>The async operation to run.</p> </li> <li> <code>seconds</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The timeout duration in seconds. Must be positive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>The result of the <code>supplier</code> if it completes in time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>seconds</code> is less than or equal to 0.</p> </li> <li> <code>BijuxError</code>             \u2013            <p>If the operation times out.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/retry.py</code> <pre><code>async def run(\n    self,\n    supplier: Callable[[], Awaitable[T]],\n    seconds: float = 1.0,\n) -&gt; T:\n    \"\"\"Executes an awaitable `supplier` with a single timeout.\n\n    This method uses the modern `asyncio.timeout` context manager if\n    available, otherwise it falls back to `asyncio.wait_for`.\n\n    Args:\n        supplier (Callable[[], Awaitable[T]]): The async operation to run.\n        seconds (float): The timeout duration in seconds. Must be positive.\n\n    Returns:\n        T: The result of the `supplier` if it completes in time.\n\n    Raises:\n        ValueError: If `seconds` is less than or equal to 0.\n        BijuxError: If the operation times out.\n    \"\"\"\n    if seconds &lt;= 0:\n        raise ValueError(\"seconds must be &gt; 0\")\n\n    ctx = _try_asyncio_timeout(seconds)\n\n    try:\n        if ctx is not None:\n            async with ctx:\n                result = await supplier()\n        else:\n            result = await asyncio.wait_for(supplier(), timeout=seconds)\n\n        self._telemetry.event(\"retry_timeout_success\", {\"seconds\": seconds})\n        return result\n\n    except TimeoutError as exc:\n        self._telemetry.event(\n            \"retry_timeout_failed\", {\"seconds\": seconds, \"error\": str(exc)}\n        )\n        raise BijuxError(\n            f\"Operation timed out after {seconds}s\", http_status=504\n        ) from exc\n</code></pre>"},{"location":"reference/infra/serializer.html","title":"Serializer Module API Reference","text":"<p>This section documents the internals of the <code>serializer</code> module in Bijux CLI. </p>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer","title":"bijux_cli.infra.serializer","text":"<p>Provides concrete serialization services for JSON and YAML formats.</p> <p>This module defines concrete implementations of the <code>SerializerProtocol</code>. It offers different serializers optimized for performance and specific formats, gracefully handling optional dependencies.</p> Key components include <ul> <li><code>OrjsonSerializer</code>: A high-performance serializer that uses <code>orjson</code> for     JSON serialization if installed, falling back to the standard <code>json</code>     module. It uses <code>PyYAML</code> for YAML.</li> <li><code>PyYAMLSerializer</code>: A serializer that exclusively handles the YAML format.</li> <li><code>Redacted</code>: A special string subclass for wrapping sensitive data to prevent     it from being exposed in serialized output.</li> <li><code>serializer_for</code>: A factory function that returns the most appropriate     serializer instance for a given format.</li> </ul>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.OrjsonSerializer","title":"OrjsonSerializer","text":"<pre><code>OrjsonSerializer(telemetry: TelemetryProtocol | None)\n</code></pre> <p>               Bases: <code>_Base</code></p> <p>A serializer that uses <code>orjson</code> for JSON and <code>PyYAML</code> for YAML.</p> <p>This implementation prioritizes performance by using <code>orjson</code> for JSON operations if it is installed, gracefully falling back to the standard library's <code>json</code> module if it is not.</p> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def __init__(self, telemetry: TelemetryProtocol | None) -&gt; None:\n    \"\"\"Initializes the base serializer.\n\n    Args:\n        telemetry (TelemetryProtocol | None): The telemetry service for\n            tracking serialization events.\n    \"\"\"\n    self._telemetry = telemetry\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.OrjsonSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    obj: Any,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; str\n</code></pre> <p>Serializes an object to a string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The desired output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or serialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a string.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The desired output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        str: The serialized string.\n\n    Raises:\n        BijuxError: If the format is unsupported or serialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            raw = self._json_dump(obj, pretty)\n            res = raw if isinstance(raw, str) else raw.decode()\n        elif fmt is OutputFormat.YAML:\n            res = self._yaml_dump(obj, pretty)\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_dumps\", format=fmt.value, pretty=pretty)\n        return res\n    except Exception as exc:\n        self._event(\"serialize_dumps_failed\", format=fmt.value, error=str(exc))\n        raise self._axerr(fmt, \"serialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.OrjsonSerializer.dumps_bytes","title":"dumps_bytes","text":"<pre><code>dumps_bytes(\n    obj: Any,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; bytes\n</code></pre> <p>Serializes an object to bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The desired output format.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output for human readability.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized bytes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or serialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to bytes.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The desired output format.\n        pretty (bool): If True, formats the output for human readability.\n\n    Returns:\n        bytes: The serialized bytes.\n\n    Raises:\n        BijuxError: If the format is unsupported or serialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            raw = self._json_dump(obj, pretty)\n            res = raw if isinstance(raw, bytes) else raw.encode()\n        elif fmt is OutputFormat.YAML:\n            res = self.dumps(obj, fmt=fmt, pretty=pretty).encode()\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_dumps_bytes\", format=fmt.value, pretty=pretty)\n        return res\n    except Exception as exc:\n        self._event(\n            \"serialize_dumps_bytes_failed\",\n            format=fmt.value,\n            error=str(exc),\n        )\n        raise self._axerr(fmt, \"serialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.OrjsonSerializer.loads","title":"loads","text":"<pre><code>loads(\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = JSON,\n    pretty: bool = False,\n) -&gt; Any\n</code></pre> <p>Deserializes data into a Python object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The format of the input data.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing (often unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is unsupported or deserialization fails.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    pretty: bool = False,\n) -&gt; Any:\n    \"\"\"Deserializes data into a Python object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input data.\n        pretty (bool): A hint that may affect parsing (often unused).\n\n    Returns:\n        Any: The deserialized object.\n\n    Raises:\n        BijuxError: If the format is unsupported or deserialization fails.\n    \"\"\"\n    try:\n        if fmt is OutputFormat.JSON:\n            if _HAS_ORJSON:\n                assert _ORJSON is not None  # noqa: S101 # nosec B101\n                res = _ORJSON.loads(data)\n            else:\n                res = json.loads(data)\n        elif fmt is OutputFormat.YAML:\n            if not _HAS_YAML:\n                raise BijuxError(\"PyYAML is required for YAML operations\")\n            assert _YAML is not None  # noqa: S101 # nosec B101\n            txt = data if isinstance(data, str) else data.decode()\n            res = _YAML.safe_load(txt) or {}\n        else:\n            raise BijuxError(f\"Unsupported format: {fmt}\")\n        self._event(\"serialize_loads\", format=fmt.value)\n        return res\n    except Exception as exc:\n        self._event(\"serialize_loads_failed\", format=fmt.value, error=str(exc))\n        raise self._axerr(fmt, \"deserialize\", exc) from exc\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.PyYAMLSerializer","title":"PyYAMLSerializer","text":"<pre><code>PyYAMLSerializer(telemetry: TelemetryProtocol | None)\n</code></pre> <p>               Bases: <code>_Base</code></p> <p>A serializer that exclusively uses the <code>PyYAML</code> library for YAML.</p> <p>Attributes:</p> <ul> <li> <code>_patched</code>               (<code>bool</code>)           \u2013            <p>A class-level flag to ensure that custom YAML representers are only registered once.</p> </li> </ul> <p>Initializes the <code>PyYAMLSerializer</code>.</p> <p>This also registers a custom YAML representer for the <code>Redacted</code> type on first instantiation.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>TelemetryProtocol | None</code>)           \u2013            <p>The telemetry service.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the <code>PyYAML</code> library is not installed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>@inject\ndef __init__(self, telemetry: TelemetryProtocol | None) -&gt; None:\n    \"\"\"Initializes the `PyYAMLSerializer`.\n\n    This also registers a custom YAML representer for the `Redacted` type\n    on first instantiation.\n\n    Args:\n        telemetry (TelemetryProtocol | None): The telemetry service.\n\n    Raises:\n        BijuxError: If the `PyYAML` library is not installed.\n    \"\"\"\n    if not _HAS_YAML:\n        raise BijuxError(\"PyYAML is not installed\")\n    super().__init__(telemetry)\n    if not PyYAMLSerializer._patched:\n        assert _YAML is not None  # noqa: S101 # nosec B101\n        _YAML.add_representer(\n            Redacted,\n            lambda dumper, data: dumper.represent_scalar(\n                \"tag:yaml.org,2002:str\", str(data)\n            ),\n            Dumper=_YAML.SafeDumper,\n        )\n        PyYAMLSerializer._patched = True\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.PyYAMLSerializer.dumps","title":"dumps","text":"<pre><code>dumps(\n    obj: Any,\n    *,\n    fmt: OutputFormat = YAML,\n    pretty: bool = False,\n) -&gt; str\n</code></pre> <p>Serializes an object to a YAML string.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The output format. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output in block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized YAML string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is not <code>OutputFormat.YAML</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; str:\n    \"\"\"Serializes an object to a YAML string.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The output format. Must be `OutputFormat.YAML`.\n        pretty (bool): If True, formats the output in block style.\n\n    Returns:\n        str: The serialized YAML string.\n\n    Raises:\n        BijuxError: If the format is not `OutputFormat.YAML`.\n    \"\"\"\n    if fmt is not OutputFormat.YAML:\n        raise BijuxError(\"PyYAMLSerializer only supports YAML\")\n    return yaml_dump(obj, pretty)\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.PyYAMLSerializer.dumps_bytes","title":"dumps_bytes","text":"<pre><code>dumps_bytes(\n    obj: Any,\n    *,\n    fmt: OutputFormat = YAML,\n    pretty: bool = False,\n) -&gt; bytes\n</code></pre> <p>Serializes an object to YAML bytes.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The output format. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, formats the output in block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code> (              <code>bytes</code> )          \u2013            <p>The serialized YAML bytes.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def dumps_bytes(\n    self,\n    obj: Any,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; bytes:\n    \"\"\"Serializes an object to YAML bytes.\n\n    Args:\n        obj (Any): The object to serialize.\n        fmt (OutputFormat): The output format. Must be `OutputFormat.YAML`.\n        pretty (bool): If True, formats the output in block style.\n\n    Returns:\n        bytes: The serialized YAML bytes.\n    \"\"\"\n    return self.dumps(obj, fmt=fmt, pretty=pretty).encode()\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.PyYAMLSerializer.loads","title":"loads","text":"<pre><code>loads(\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = YAML,\n    pretty: bool = False,\n) -&gt; Any\n</code></pre> <p>Deserializes YAML data into a Python object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The string or bytes to deserialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>YAML</code> )           \u2013            <p>The format of the input. Must be <code>OutputFormat.YAML</code>.</p> </li> <li> <code>pretty</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>A hint that may affect parsing (unused).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The deserialized object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the format is not <code>OutputFormat.YAML</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def loads(\n    self,\n    data: str | bytes,\n    *,\n    fmt: OutputFormat = OutputFormat.YAML,\n    pretty: bool = False,\n) -&gt; Any:\n    \"\"\"Deserializes YAML data into a Python object.\n\n    Args:\n        data (str | bytes): The string or bytes to deserialize.\n        fmt (OutputFormat): The format of the input. Must be `OutputFormat.YAML`.\n        pretty (bool): A hint that may affect parsing (unused).\n\n    Returns:\n        Any: The deserialized object.\n\n    Raises:\n        BijuxError: If the format is not `OutputFormat.YAML`.\n    \"\"\"\n    if fmt is not OutputFormat.YAML:\n        raise BijuxError(\"PyYAMLSerializer only supports YAML\")\n    txt = data if isinstance(data, str) else data.decode()\n    assert _YAML is not None  # noqa: S101 # nosec B101\n    return _YAML.safe_load(txt) or {}\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.Redacted","title":"Redacted","text":"<p>               Bases: <code>str</code></p> <p>A string subclass that redacts its value when printed or serialized.</p> <p>This is used to wrap sensitive data, such as secrets or API keys, to prevent them from being accidentally exposed in logs or console output.</p>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.Redacted.to_json","title":"to_json  <code>staticmethod</code>","text":"<pre><code>to_json() -&gt; str\n</code></pre> <p>Provides a JSON-serializable representation for libraries like <code>orjson</code>.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A static string \"***\" to represent the redacted value.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>@staticmethod\ndef to_json() -&gt; str:\n    \"\"\"Provides a JSON-serializable representation for libraries like `orjson`.\n\n    Returns:\n        str: A static string \"***\" to represent the redacted value.\n    \"\"\"\n    return \"***\"\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.serializer_for","title":"serializer_for","text":"<pre><code>serializer_for(\n    fmt: OutputFormat | str, telemetry: TelemetryProtocol\n) -&gt; SerializerProtocol[Any]\n</code></pre> <p>A factory function that returns a serializer for the given format.</p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>OutputFormat | str</code>)           \u2013            <p>The desired output format.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service to inject into the serializer.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SerializerProtocol[Any]</code>           \u2013            <p>SerializerProtocol[Any]: A configured serializer instance appropriate for the specified format.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def serializer_for(\n    fmt: OutputFormat | str,\n    telemetry: TelemetryProtocol,\n) -&gt; SerializerProtocol[Any]:\n    \"\"\"A factory function that returns a serializer for the given format.\n\n    Args:\n        fmt (OutputFormat | str): The desired output format.\n        telemetry (TelemetryProtocol): The telemetry service to inject into\n            the serializer.\n\n    Returns:\n        SerializerProtocol[Any]: A configured serializer instance appropriate\n            for the specified format.\n    \"\"\"\n    format_enum = fmt if isinstance(fmt, OutputFormat) else OutputFormat(fmt.upper())\n\n    if format_enum is OutputFormat.JSON:\n        return OrjsonSerializer(telemetry)\n    else:\n        return PyYAMLSerializer(telemetry)\n</code></pre>"},{"location":"reference/infra/serializer.html#bijux_cli.infra.serializer.yaml_dump","title":"yaml_dump","text":"<pre><code>yaml_dump(obj: Any, pretty: bool) -&gt; str\n</code></pre> <p>Dumps an object to a YAML string using PyYAML.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>Any</code>)           \u2013            <p>The object to serialize.</p> </li> <li> <code>pretty</code>               (<code>bool</code>)           \u2013            <p>If True, formats the output in an indented block style.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized YAML string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the <code>PyYAML</code> library is not installed.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/serializer.py</code> <pre><code>def yaml_dump(obj: Any, pretty: bool) -&gt; str:\n    \"\"\"Dumps an object to a YAML string using PyYAML.\n\n    Args:\n        obj (Any): The object to serialize.\n        pretty (bool): If True, formats the output in an indented block style.\n\n    Returns:\n        str: The serialized YAML string.\n\n    Raises:\n        BijuxError: If the `PyYAML` library is not installed.\n    \"\"\"\n    if _yaml_mod is None:\n        raise BijuxError(\"PyYAML is required for YAML operations\")\n    dumped = _yaml_mod.safe_dump(\n        obj,\n        sort_keys=False,\n        default_flow_style=not pretty,\n        indent=2 if pretty else None,\n    )\n    return dumped or \"\"\n</code></pre>"},{"location":"reference/infra/telemetry.html","title":"Telemetry Module API Reference","text":"<p>This section documents the internals of the <code>telemetry</code> module in Bijux CLI. </p>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry","title":"bijux_cli.infra.telemetry","text":"<p>Provides concrete telemetry service implementations for event tracking.</p> <p>This module defines concrete classes that implement the <code>TelemetryProtocol</code>. It offers different strategies for handling telemetry events, allowing the application's analytics behavior to be configured easily.</p> Key components include <ul> <li><code>TelemetryEvent</code>: An enumeration of all standardized event names, providing     a single source of truth for telemetry event types.</li> <li><code>NullTelemetry</code>: A no-op implementation that silently discards all events,     useful for disabling telemetry entirely.</li> <li><code>LoggingTelemetry</code>: An implementation that forwards all telemetry events to     the application's structured logging service.</li> </ul>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.LoggingTelemetry","title":"LoggingTelemetry","text":"<pre><code>LoggingTelemetry(observability: ObservabilityProtocol)\n</code></pre> <p>               Bases: <code>TelemetryProtocol</code></p> <p>A telemetry service that logs events via the <code>Observability</code> service.</p> <p>This implementation of <code>TelemetryProtocol</code> forwards all telemetry events to the structured logger as debug-level messages.</p> <p>Attributes:</p> <ul> <li> <code>_obs</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service instance.</p> </li> <li> <code>_buffer</code>               (<code>list</code>)           \u2013            <p>A buffer to store events (currently only cleared on flush).</p> </li> </ul> <p>Initializes the <code>LoggingTelemetry</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging events.</p> </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>@inject\ndef __init__(self, observability: ObservabilityProtocol):\n    \"\"\"Initializes the `LoggingTelemetry` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging events.\n    \"\"\"\n    self._obs = observability\n    self._buffer: list[tuple[str, dict[str, Any]]] = []\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.LoggingTelemetry.enable","title":"enable","text":"<pre><code>enable() -&gt; None\n</code></pre> <p>Performs a no-op enable operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Performs a no-op enable operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.LoggingTelemetry.event","title":"event","text":"<pre><code>event(\n    name: str | TelemetryEvent, payload: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Logs a telemetry event at the 'debug' level.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | TelemetryEvent</code>)           \u2013            <p>The event name or enum member.</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The event data dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def event(self, name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Logs a telemetry event at the 'debug' level.\n\n    Args:\n        name (str | TelemetryEvent): The event name or enum member.\n        payload (dict[str, Any]): The event data dictionary.\n\n    Returns:\n        None:\n    \"\"\"\n    event_name = name.value if isinstance(name, TelemetryEvent) else name\n    self._obs.log(\"debug\", f\"Telemetry event: {event_name}\", extra=payload)\n    self._buffer.append((event_name, payload))\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.LoggingTelemetry.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Clears the internal buffer of telemetry events.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Clears the internal buffer of telemetry events.\"\"\"\n    self._buffer.clear()\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.NullTelemetry","title":"NullTelemetry","text":"<p>               Bases: <code>TelemetryProtocol</code></p> <p>A no-op telemetry service that discards all events.</p> <p>This implementation of <code>TelemetryProtocol</code> can be used to effectively disable analytics and event tracking.</p>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.NullTelemetry.enable","title":"enable","text":"<pre><code>enable() -&gt; None\n</code></pre> <p>Performs a no-op enable operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"Performs a no-op enable operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.NullTelemetry.event","title":"event","text":"<pre><code>event(\n    name: str | TelemetryEvent, payload: dict[str, Any]\n) -&gt; None\n</code></pre> <p>Discards the telemetry event.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | TelemetryEvent</code>)           \u2013            <p>The event name (ignored).</p> </li> <li> <code>payload</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The event data (ignored).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def event(self, name: str | TelemetryEvent, payload: dict[str, Any]) -&gt; None:\n    \"\"\"Discards the telemetry event.\n\n    Args:\n        name (str | TelemetryEvent): The event name (ignored).\n        payload (dict[str, Any]): The event data (ignored).\n\n    Returns:\n        None:\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.NullTelemetry.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Performs a no-op flush operation.</p> Source code in <code>src/bijux_cli/infra/telemetry.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Performs a no-op flush operation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/infra/telemetry.html#bijux_cli.infra.telemetry.TelemetryEvent","title":"TelemetryEvent","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines standardized telemetry event names for tracking CLI activities.</p>"},{"location":"reference/services/index.html","title":"Reference / Services Index","text":"<ul> <li>Audit Module</li> <li>Config Module</li> <li>Docs Module</li> <li>Doctor Module</li> <li>History Module</li> <li>Memory Module</li> <li>Utils Module</li> </ul>"},{"location":"reference/services/audit.html","title":"Audit Module API Reference","text":"<p>This section documents the internals of the <code>audit</code> module in Bijux CLI. </p>"},{"location":"reference/services/audit.html#bijux_cli.services.audit","title":"bijux_cli.services.audit","text":"<p>Provides concrete audit service implementations.</p> <p>This module defines concrete classes that implement the <code>AuditProtocol</code>. It offers different strategies for handling command auditing and execution, allowing the application to switch between a simulation mode (<code>DryRunAudit</code>) and a real execution mode (<code>RealAudit</code>).</p> <p>A factory function, <code>get_audit_service</code>, is provided to select the appropriate implementation based on a <code>dry_run</code> flag.</p>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.DryRunAudit","title":"DryRunAudit","text":"<pre><code>DryRunAudit(\n    log: ObservabilityProtocol, tel: TelemetryProtocol\n)\n</code></pre> <p>               Bases: <code>_BaseAudit</code></p> <p>An audit service that records events and simulates command execution.</p> <p>Initializes the <code>DryRunAudit</code> service.</p> <p>Parameters:</p> <ul> <li> <code>log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for structured logging.</p> </li> <li> <code>tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def __init__(self, log: ObservabilityProtocol, tel: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `DryRunAudit` service.\n\n    Args:\n        log (ObservabilityProtocol): The service for structured logging.\n        tel (TelemetryProtocol): The service for event tracking.\n    \"\"\"\n    super().__init__(log, tel)\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.DryRunAudit.cli_audit","title":"cli_audit","text":"<pre><code>cli_audit() -&gt; None\n</code></pre> <p>Logs a dry-run CLI audit event.</p> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Logs a dry-run CLI audit event.\"\"\"\n    self._log.log(\"info\", \"CLI audit (dry-run)\", extra={})\n    self._tel.event(\"audit_cli_dry_run\", {})\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.DryRunAudit.log","title":"log","text":"<pre><code>log(cmd: list[str], *, executor: str) -&gt; None\n</code></pre> <p>Logs and records a command without executing it.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs and records a command without executing it.\n\n    Args:\n        cmd (list[str]): The command and arguments to log.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        None:\n    \"\"\"\n    entry = {\"cmd\": cmd, \"executor\": executor}\n    self._commands.append(entry)\n    self._log.log(\"info\", \"Dry-run\", extra=entry)\n    self._tel.event(\"audit_dry_run\", entry)\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.DryRunAudit.run","title":"run","text":"<pre><code>run(\n    cmd: list[str], *, executor: str\n) -&gt; tuple[int, bytes, bytes]\n</code></pre> <p>Simulates the execution of a command.</p> <p>This method logs the command and returns a successful result without actually running a subprocess.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command to simulate.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple of dummy values: <code>(0, b\"\", b\"\")</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Simulates the execution of a command.\n\n    This method logs the command and returns a successful result without\n    actually running a subprocess.\n\n    Args:\n        cmd (list[str]): The command to simulate.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple of dummy values: `(0, b\"\", b\"\")`.\n    \"\"\"\n    self.log(cmd, executor=executor)\n    return 0, b\"\", b\"\"\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.RealAudit","title":"RealAudit","text":"<pre><code>RealAudit(\n    log: ObservabilityProtocol, tel: TelemetryProtocol\n)\n</code></pre> <p>               Bases: <code>_BaseAudit</code></p> <p>An audit service that validates, logs, and executes real commands.</p> <p>Initializes the <code>RealAudit</code> service.</p> <p>Parameters:</p> <ul> <li> <code>log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for structured logging.</p> </li> <li> <code>tel</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def __init__(self, log: ObservabilityProtocol, tel: TelemetryProtocol) -&gt; None:\n    \"\"\"Initializes the `RealAudit` service.\n\n    Args:\n        log (ObservabilityProtocol): The service for structured logging.\n        tel (TelemetryProtocol): The service for event tracking.\n    \"\"\"\n    super().__init__(log, tel)\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.RealAudit.cli_audit","title":"cli_audit","text":"<pre><code>cli_audit() -&gt; None\n</code></pre> <p>Logs a real CLI audit event.</p> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def cli_audit(self) -&gt; None:\n    \"\"\"Logs a real CLI audit event.\"\"\"\n    self._log.log(\n        \"info\", \"CLI audit (real)\", extra={\"commands\": len(self._commands)}\n    )\n    self._tel.event(\"audit_cli_real\", {\"commands\": len(self._commands)})\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.RealAudit.log","title":"log","text":"<pre><code>log(cmd: list[str], *, executor: str) -&gt; None\n</code></pre> <p>Logs a command with the intent to execute it.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to log.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def log(self, cmd: list[str], *, executor: str) -&gt; None:\n    \"\"\"Logs a command with the intent to execute it.\n\n    Args:\n        cmd (list[str]): The command and arguments to log.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        None:\n    \"\"\"\n    entry = {\"cmd\": cmd, \"executor\": executor}\n    self._commands.append(entry)\n    self._log.log(\"debug\", f\"Executing {executor}\", extra=entry)\n    self._tel.event(\"audit_execute\", entry)\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.RealAudit.run","title":"run","text":"<pre><code>run(\n    cmd: list[str], *, executor: str\n) -&gt; tuple[int, bytes, bytes]\n</code></pre> <p>Validates, logs, and executes a command in a subprocess.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to execute.</p> </li> <li> <code>executor</code>               (<code>str</code>)           \u2013            <p>The name of the entity executing the command.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, bytes, bytes]</code>           \u2013            <p>tuple[int, bytes, bytes]: A tuple containing the command's return code, standard output, and standard error.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If command validation fails or an unexpected error occurs during execution.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def run(self, cmd: list[str], *, executor: str) -&gt; tuple[int, bytes, bytes]:\n    \"\"\"Validates, logs, and executes a command in a subprocess.\n\n    Args:\n        cmd (list[str]): The command and arguments to execute.\n        executor (str): The name of the entity executing the command.\n\n    Returns:\n        tuple[int, bytes, bytes]: A tuple containing the command's return\n            code, standard output, and standard error.\n\n    Raises:\n        BijuxError: If command validation fails or an unexpected error\n            occurs during execution.\n    \"\"\"\n    try:\n        safe_cmd = validate_command(cmd)\n        self.log(safe_cmd, executor=executor)\n        proc = subprocess.run(  # noqa: S603 # nosec B603\n            safe_cmd,\n            capture_output=True,\n            check=False,\n            shell=False,\n        )\n        self._tel.event(\n            \"audit_executed\",\n            {\n                \"cmd\": safe_cmd,\n                \"executor\": executor,\n                \"returncode\": proc.returncode,\n            },\n        )\n        return proc.returncode, proc.stdout, proc.stderr\n    except BijuxError as err:\n        self._tel.event(\n            \"audit_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(err)},\n        )\n        raise\n    except Exception as err:\n        self._tel.event(\n            \"audit_execution_failed\",\n            {\"cmd\": cmd, \"executor\": executor, \"error\": str(err)},\n        )\n        raise BijuxError(f\"Failed to execute {executor!r}: {err}\") from err\n</code></pre>"},{"location":"reference/services/audit.html#bijux_cli.services.audit.get_audit_service","title":"get_audit_service","text":"<pre><code>get_audit_service(\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    dry_run: bool = False,\n) -&gt; AuditProtocol\n</code></pre> <p>A factory function for creating an audit service instance.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>dry_run</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns a <code>DryRunAudit</code> instance; otherwise, returns a <code>RealAudit</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AuditProtocol</code> (              <code>AuditProtocol</code> )          \u2013            <p>An instance of the appropriate audit service.</p> </li> </ul> Source code in <code>src/bijux_cli/services/audit.py</code> <pre><code>def get_audit_service(\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    dry_run: bool = False,\n) -&gt; AuditProtocol:\n    \"\"\"A factory function for creating an audit service instance.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        dry_run (bool): If True, returns a `DryRunAudit` instance; otherwise,\n            returns a `RealAudit` instance.\n\n    Returns:\n        AuditProtocol: An instance of the appropriate audit service.\n    \"\"\"\n    return (\n        DryRunAudit(observability, telemetry)\n        if dry_run\n        else RealAudit(observability, telemetry)\n    )\n</code></pre>"},{"location":"reference/services/config.html","title":"Config Module API Reference","text":"<p>This section documents the internals of the <code>config</code> module in Bijux CLI. </p>"},{"location":"reference/services/config.html#bijux_cli.services.config","title":"bijux_cli.services.config","text":"<p>Provides a robust, file-based configuration management service.</p> <p>This module defines the <code>Config</code> class, a concrete implementation of the <code>ConfigProtocol</code>. It is responsible for loading, accessing, and persisting key-value configuration settings from <code>.env</code> files.</p> Key features include <ul> <li>Atomic Writes: Changes are written to a temporary file before being     atomically moved into place to prevent data corruption.</li> <li>Cross-Process Safety: On POSIX systems, <code>fcntl.flock</code> is used with     retries to handle concurrent access from multiple CLI processes.</li> <li>Key Normalization: Configuration keys are handled case-insensitively     and the <code>BIJUXCLI_</code> prefix is optional.</li> <li>Security Checks: Includes validation to prevent operating on device     files or traversing symbolic link loops.</li> </ul>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config","title":"Config","text":"<pre><code>Config(dependency_injector: Any)\n</code></pre> <p>               Bases: <code>ConfigProtocol</code></p> <p>A robust configuration handler for <code>.env</code> files.</p> <p>This service manages loading, saving, and persisting configuration values, featuring atomic writes and key normalization. Keys are stored internally in lowercase and without the <code>BIJUXCLI_</code> prefix.</p> <p>Attributes:</p> <ul> <li> <code>_di</code>               (<code>Any</code>)           \u2013            <p>The dependency injection container.</p> </li> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_data</code>               (<code>dict[str, str]</code>)           \u2013            <p>The in-memory dictionary of configuration data.</p> </li> <li> <code>_path</code>               (<code>Path | None</code>)           \u2013            <p>The path to the configuration file being managed.</p> </li> </ul> <p>Initializes the Config service and attempts to autoload configuration.</p> <p>Parameters:</p> <ul> <li> <code>dependency_injector</code>               (<code>Any</code>)           \u2013            <p>The DI container for resolving dependencies.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>@inject\ndef __init__(self, dependency_injector: Any) -&gt; None:\n    \"\"\"Initializes the Config service and attempts to autoload configuration.\n\n    Args:\n        dependency_injector (Any): The DI container for resolving dependencies.\n    \"\"\"\n    self._di = dependency_injector\n    self._log: ObservabilityProtocol = dependency_injector.resolve(\n        ObservabilityProtocol\n    )\n    self._data: dict[str, str] = {}\n    self._path: Path | None = None\n    try:\n        self.load()\n    except FileNotFoundError:\n        pass\n    except CommandError as e:\n        self._log.log(\n            \"error\", f\"Auto-load of config failed during init: {e}\", extra={}\n        )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.all","title":"all","text":"<pre><code>all() -&gt; dict[str, str]\n</code></pre> <p>Returns all configuration key-value pairs.</p> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary of all configuration data.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def all(self) -&gt; dict[str, str]:\n    \"\"\"Returns all configuration key-value pairs.\n\n    Returns:\n        dict[str, str]: A dictionary of all configuration data.\n    \"\"\"\n    return dict(self._data)\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Deletes all configuration entries and removes the config file.</p> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the config file cannot be deleted due to a lock or other filesystem error.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Deletes all configuration entries and removes the config file.\n\n    Raises:\n        CommandError: If the config file cannot be deleted due to a lock\n            or other filesystem error.\n    \"\"\"\n    self._data = {}\n    if self._path and self._path.exists():\n        try:\n            retry = 40\n            while True:\n                try:\n                    with open(self._path, \"a+\") as real:\n                        fcntl.flock(real.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)\n                        self._path.unlink()\n                        fcntl.flock(real.fileno(), fcntl.LOCK_UN)\n                    break\n                except BlockingIOError as err:\n                    retry -= 1\n                    if retry == 0:\n                        raise CommandError(\n                            f\"Failed to clear config file {self._path}: File locked\",\n                            http_status=400,\n                        ) from err\n                    time.sleep(0.05)\n        except Exception as exc:\n            self._log.log(\n                \"error\",\n                f\"Failed to clear config file {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to clear config file {self._path}: {exc}\", http_status=500\n            ) from exc\n    self._log.log(\n        \"info\",\n        \"Cleared config data\",\n        extra={\"path\": str(self._path) if self._path else \"None\"},\n    )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a configuration key and persists the change.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to delete (case-insensitive, <code>BIJUXCLI_</code> prefix optional).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the key does not exist or the change cannot be persisted.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a configuration key and persists the change.\n\n    Args:\n        key (str): The key to delete (case-insensitive, `BIJUXCLI_` prefix optional).\n\n    Raises:\n        CommandError: If the key does not exist or the change cannot be persisted.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    if normalized_key not in self._data:\n        self._log.log(\n            \"error\", f\"Config key not found: {key}\", extra={\"key\": normalized_key}\n        )\n        raise CommandError(f\"Config key not found: {key}\", http_status=400)\n    del self._data[normalized_key]\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Deleted config key and persisted to {self._path}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config after deleting {normalized_key}: {exc}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            raise CommandError(\n                f\"Failed to persist config after deleting {normalized_key}: {exc}\",\n                http_status=500,\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.export","title":"export","text":"<pre><code>export(\n    path: str | Path, out_format: str | None = None\n) -&gt; None\n</code></pre> <p>Exports the configuration to a file or standard output.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The destination file path, or \"-\" for stdout.</p> </li> <li> <code>out_format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format ('env', 'json', 'yaml'). If None, the format is auto-detected from the file extension.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the format is unsupported or the export fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def export(self, path: str | Path, out_format: str | None = None) -&gt; None:\n    \"\"\"Exports the configuration to a file or standard output.\n\n    Args:\n        path (str | Path): The destination file path, or \"-\" for stdout.\n        out_format (str | None): The output format ('env', 'json', 'yaml').\n            If None, the format is auto-detected from the file extension.\n\n    Raises:\n        CommandError: If the format is unsupported or the export fails.\n    \"\"\"\n    export_path = Path(path) if path != \"-\" else path\n    output_fmt = (\n        out_format.lower()\n        if out_format\n        else (\n            \"env\"\n            if path == \"-\" or str(path).endswith(\".env\")\n            else \"yaml\"\n            if str(path).endswith((\".yaml\", \".yml\"))\n            else \"json\"\n        )\n    )\n    try:\n        if output_fmt == \"env\":\n            lines = [f\"BIJUXCLI_{k.upper()}={v}\" for k, v in self._data.items()]\n            text = \"\\n\".join(lines) + (\"\\n\" if lines else \"\")\n        elif output_fmt == \"json\":\n            text = (\n                json.dumps({k.upper(): v for k, v in self._data.items()}, indent=2)\n                + \"\\n\"\n            )\n        elif output_fmt == \"yaml\":\n            if yaml is None:\n                raise CommandError(\n                    \"PyYAML not installed for YAML support\", http_status=400\n                )\n            text = yaml.safe_dump(\n                {k.upper(): v for k, v in self._data.items()}, sort_keys=False\n            )\n        else:\n            raise CommandError(f\"Unsupported format: {output_fmt}\", http_status=400)\n        if path == \"-\":\n            print(text, end=\"\")\n            self._log.log(\n                \"info\",\n                \"Exported config to stdout\",\n                extra={\"format\": output_fmt},\n            )\n            return\n        export_path = Path(path)\n        export_path.resolve(strict=False)\n        if not export_path.parent.exists():\n            raise CommandError(\n                f\"No such file or directory: {export_path.parent}\", http_status=400\n            )\n        if export_path.exists() and not os.access(export_path, os.W_OK):\n            raise PermissionError(f\"Permission denied: '{export_path}'\")\n        if not os.access(export_path.parent, os.W_OK):\n            raise PermissionError(f\"Permission denied: '{export_path.parent}'\")\n        with NamedTemporaryFile(\n            \"w\", delete=False, dir=export_path.parent, encoding=\"utf-8\", newline=\"\"\n        ) as temp_file:\n            fd = temp_file.fileno()\n            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n            temp_file.write(text)\n            temp_file.flush()\n            os.fsync(fd)\n            fcntl.flock(fd, fcntl.LOCK_UN)\n            Path(temp_file.name).replace(export_path)\n        self._log.log(\n            \"info\",\n            f\"Exported config to {export_path}\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n    except BlockingIOError as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to export config to {export_path}: File locked\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n        raise CommandError(\n            f\"Failed to export config to {export_path}: File locked\",\n            http_status=400,\n        ) from exc\n    except (OSError, PermissionError, ValueError) as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to export config to {export_path}: {exc}\",\n            extra={\"path\": str(export_path), \"format\": output_fmt},\n        )\n        raise CommandError(\n            f\"Failed to export config to {export_path}: {exc}\", http_status=400\n        ) from exc\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.get","title":"get","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Retrieves a configuration value by key.</p> <p>The key is normalized (lowercase, <code>BIJUXCLI_</code> prefix removed), and the environment is checked first before consulting the in-memory store.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to retrieve.</p> </li> <li> <code>default</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The value to return if the key is not found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key, or the default value.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the key is not found and no default is provided.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieves a configuration value by key.\n\n    The key is normalized (lowercase, `BIJUXCLI_` prefix removed), and the\n    environment is checked first before consulting the in-memory store.\n\n    Args:\n        key (str): The key to retrieve.\n        default (Any): The value to return if the key is not found.\n\n    Returns:\n        Any: The value associated with the key, or the default value.\n\n    Raises:\n        CommandError: If the key is not found and no default is provided.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    env_key = f\"BIJUXCLI_{normalized_key.upper()}\"\n    if env_key in os.environ:\n        return os.environ[env_key]\n    value = self._data.get(normalized_key, default)\n    if isinstance(value, str):\n        val_lower = value.lower()\n        if val_lower in {\"true\", \"false\"}:\n            return val_lower == \"true\"\n    if value is default and default is None:\n        self._log.log(\n            \"error\", f\"Config key not found: {key}\", extra={\"key\": normalized_key}\n        )\n        raise CommandError(f\"Config key not found: {key}\", http_status=400)\n    self._log.log(\n        \"debug\",\n        f\"Retrieved config key: {normalized_key}\",\n        extra={\"key\": normalized_key, \"value\": str(value)},\n    )\n    return value\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.list_keys","title":"list_keys","text":"<pre><code>list_keys() -&gt; list[str]\n</code></pre> <p>Returns a list of all configuration keys.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all keys in the configuration.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def list_keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all configuration keys.\n\n    Returns:\n        list[str]: A list of all keys in the configuration.\n    \"\"\"\n    return list(self._data.keys())\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.load","title":"load","text":"<pre><code>load(path: str | Path | None = None) -&gt; None\n</code></pre> <p>Loads configuration from a <code>.env</code> file.</p> <p>This method reads a specified <code>.env</code> file, parsing <code>KEY=VALUE</code> pairs. It handles comments, validates syntax, and normalizes keys. If no path is given, it uses the default path from <code>.env</code> or environment.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the <code>.env</code> file. If None, uses the default path from the environment or project structure.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If a specified config file does not exist.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If a line is malformed or contains non-ASCII characters.</p> </li> <li> <code>CommandError</code>             \u2013            <p>If the file is binary or another parsing error occurs.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def load(self, path: str | Path | None = None) -&gt; None:\n    \"\"\"Loads configuration from a `.env` file.\n\n    This method reads a specified `.env` file, parsing `KEY=VALUE` pairs.\n    It handles comments, validates syntax, and normalizes keys. If no path\n    is given, it uses the default path from `.env` or environment.\n\n    Args:\n        path (str | Path | None): Path to the `.env` file. If None, uses\n            the default path from the environment or project structure.\n\n    Raises:\n        FileNotFoundError: If a specified config file does not exist.\n        ValueError: If a line is malformed or contains non-ASCII characters.\n        CommandError: If the file is binary or another parsing error occurs.\n    \"\"\"\n    import_path = Path(path) if path is not None else None\n    current_path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n    self._validate_config_path(current_path)\n    if import_path:\n        self._validate_config_path(import_path)\n    read_path = import_path or current_path\n    _detect_symlink_loop(read_path)\n    if not read_path.exists():\n        if import_path is not None:\n            raise FileNotFoundError(f\"Config file not found: {read_path}\")\n        self._data = {}\n        return\n    new_data = {}\n    try:\n        content = read_path.read_text(encoding=\"utf-8\")\n        for i, line in enumerate(content.splitlines()):\n            stripped = line.strip()\n            if not stripped or stripped.startswith(\"#\"):\n                continue\n            if \"=\" not in line:\n                raise ValueError(f\"Malformed line {i + 1}: {line}\")\n            key_part, val_part = line.split(\"=\", 1)\n            key = key_part.strip()\n            value = _unescape(val_part)\n            if len(value) &gt;= 2 and value[0] == '\"' and value[-1] == '\"':\n                value = value[1:-1]\n            if not all(ord(c) &lt; 128 for c in key + value):\n                raise ValueError(f\"Non-ASCII characters in line {i + 1}: {line}\")\n            normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n            new_data[normalized_key] = value\n    except UnicodeDecodeError as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to parse config file {read_path}: Binary or non-text content\",\n            extra={\"path\": str(read_path)},\n        )\n        raise CommandError(\n            f\"Failed to parse config file {read_path}: Binary or non-text content\",\n            http_status=400,\n        ) from exc\n    except Exception as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to parse config file {read_path}: {exc}\",\n            extra={\"path\": str(read_path)},\n        )\n        raise CommandError(\n            f\"Failed to parse config file {read_path}: {exc}\", http_status=400\n        ) from exc\n    self._data = new_data\n    if import_path is not None and import_path != current_path:\n        self._path = current_path\n        self.set_many(new_data)\n    else:\n        self._path = read_path\n    self._log.log(\n        \"info\",\n        f\"Loaded config from {read_path} (active: {self._path})\",\n        extra={\"src\": str(read_path), \"active\": str(self._path)},\n    )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.reload","title":"reload","text":"<pre><code>reload() -&gt; None\n</code></pre> <p>Reloads configuration from the last-loaded file path.</p> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If no file path has been previously loaded.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def reload(self) -&gt; None:\n    \"\"\"Reloads configuration from the last-loaded file path.\n\n    Raises:\n        CommandError: If no file path has been previously loaded.\n    \"\"\"\n    if self._path is None:\n        self._log.log(\"error\", \"Config.reload() called before load()\", extra={})\n        raise CommandError(\"Config.reload() called before load()\", http_status=400)\n    if not self._path.exists():\n        self._log.log(\n            \"error\", f\"Config file missing for reload: {self._path}\", extra={}\n        )\n        raise CommandError(\n            f\"Config file missing for reload: {self._path}\", http_status=400\n        )\n    self.load(self._path)\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.save","title":"save","text":"<pre><code>save() -&gt; None\n</code></pre> <p>Persists the current in-memory configuration to its source file.</p> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Persists the current in-memory configuration to its source file.\"\"\"\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    try:\n        self.set_many(self._data)\n    except Exception as exc:\n        self._log.log(\n            \"error\",\n            f\"Failed to save config to {self._path}: {exc}\",\n            extra={\"path\": str(self._path)},\n        )\n        raise CommandError(\n            f\"Failed to save config to {self._path}: {exc}\", http_status=500\n        ) from exc\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a single configuration key-value pair and persists it.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to set (case-insensitive, <code>BIJUXCLI_</code> prefix optional).</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to associate with the key.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>CommandError</code>             \u2013            <p>If the configuration cannot be persisted.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a single configuration key-value pair and persists it.\n\n    Args:\n        key (str): The key to set (case-insensitive, `BIJUXCLI_` prefix optional).\n        value (Any): The value to associate with the key.\n\n    Returns:\n        None:\n\n    Raises:\n        CommandError: If the configuration cannot be persisted.\n    \"\"\"\n    normalized_key = key.strip().removeprefix(\"BIJUXCLI_\").lower()\n    self._data[normalized_key] = str(value)\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Persisted config to {self._path}\",\n                extra={\"path\": str(self._path), \"key\": normalized_key},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config to {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to persist config to {self._path}: {exc}\", http_status=500\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.set_many","title":"set_many","text":"<pre><code>set_many(items: dict[str, Any]) -&gt; None\n</code></pre> <p>Sets multiple key-value pairs and persists them to the config file.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary of key-value pairs to set.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def set_many(self, items: dict[str, Any]) -&gt; None:\n    \"\"\"Sets multiple key-value pairs and persists them to the config file.\n\n    Args:\n        items (dict[str, Any]): A dictionary of key-value pairs to set.\n    \"\"\"\n    self._data = {k: str(v) for k, v in items.items()}\n    if not self._path:\n        self._path = Path(os.getenv(\"BIJUXCLI_CONFIG\", str(CONFIG_FILE)))\n        self._validate_config_path(self._path)\n    _detect_symlink_loop(self._path)\n    self._path.parent.mkdir(parents=True, exist_ok=True)\n    tmp_path = self._path.with_suffix(\".tmp\")\n    retry = 40\n    while retry &gt; 0:\n        try:\n            with open(tmp_path, \"w\", encoding=\"utf-8\", newline=\"\") as temp_file:\n                fd = temp_file.fileno()\n                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)\n                for k, v in self._data.items():\n                    safe_v = _escape(str(v))\n                    temp_file.write(f\"BIJUXCLI_{k.upper()}={safe_v}\\n\")\n                temp_file.flush()\n                os.fsync(fd)\n                fcntl.flock(fd, fcntl.LOCK_UN)\n            tmp_path.replace(self._path)\n            self._log.log(\n                \"info\",\n                f\"Persisted config to {self._path}\",\n                extra={\"path\": str(self._path)},\n            )\n            return\n        except BlockingIOError:\n            retry -= 1\n            time.sleep(0.05)\n        except Exception as exc:\n            if tmp_path.exists():\n                tmp_path.unlink()\n            self._log.log(\n                \"error\",\n                f\"Failed to persist config to {self._path}: {exc}\",\n                extra={\"path\": str(self._path)},\n            )\n            raise CommandError(\n                f\"Failed to persist config to {self._path}: {exc}\", http_status=500\n            ) from exc\n    if tmp_path.exists():\n        tmp_path.unlink()\n    raise CommandError(\n        f\"Failed to persist config to {self._path}: File locked after retries\",\n        http_status=400,\n    )\n</code></pre>"},{"location":"reference/services/config.html#bijux_cli.services.config.Config.unset","title":"unset","text":"<pre><code>unset(key: str) -&gt; None\n</code></pre> <p>Removes a configuration key (alias for <code>delete</code>).</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key to remove.</p> </li> </ul> Source code in <code>src/bijux_cli/services/config.py</code> <pre><code>def unset(self, key: str) -&gt; None:\n    \"\"\"Removes a configuration key (alias for `delete`).\n\n    Args:\n        key (str): The key to remove.\n    \"\"\"\n    self.delete(key)\n</code></pre>"},{"location":"reference/services/docs.html","title":"Docs Module API Reference","text":"<p>This section documents the internals of the <code>docs</code> module in Bijux CLI. </p>"},{"location":"reference/services/docs.html#bijux_cli.services.docs","title":"bijux_cli.services.docs","text":"<p>Provides the concrete implementation of the API specification writing service.</p> <p>This module defines the <code>Docs</code> class, which implements the <code>DocsProtocol</code>. It is responsible for serializing API specification data into formats like JSON or YAML and writing the resulting documents to the filesystem. It integrates with observability and telemetry services to log its activities.</p>"},{"location":"reference/services/docs.html#bijux_cli.services.docs.Docs","title":"Docs","text":"<pre><code>Docs(\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    root: str | Path | None = None,\n)\n</code></pre> <p>               Bases: <code>DocsProtocol</code></p> <p>A service for writing API specification documents to disk.</p> <p>This class implements the <code>DocsProtocol</code> to handle the serialization and writing of specifications (e.g., OpenAPI, JSON Schema) to files. It maintains a cache of serializer instances for performance.</p> <p>Attributes:</p> <ul> <li> <code>_serializers</code>               (<code>WeakKeyDictionary</code>)           \u2013            <p>A cache of serializer instances, keyed by the telemetry service instance.</p> </li> <li> <code>_observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>_telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The telemetry service for event tracking.</p> </li> <li> <code>_root</code>               (<code>Path</code>)           \u2013            <p>The root directory where documents will be written.</p> </li> </ul> <p>Initializes the <code>Docs</code> service.</p> <p>Parameters:</p> <ul> <li> <code>observability</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The service for logging.</p> </li> <li> <code>telemetry</code>               (<code>TelemetryProtocol</code>)           \u2013            <p>The service for event tracking.</p> </li> <li> <code>root</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The root directory for writing documents. It defaults to the <code>BIJUXCLI_DOCS_DIR</code> environment variable, or \"docs\" if not set.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    observability: ObservabilityProtocol,\n    telemetry: TelemetryProtocol,\n    root: str | Path | None = None,\n) -&gt; None:\n    \"\"\"Initializes the `Docs` service.\n\n    Args:\n        observability (ObservabilityProtocol): The service for logging.\n        telemetry (TelemetryProtocol): The service for event tracking.\n        root (str | Path | None): The root directory for writing documents.\n            It defaults to the `BIJUXCLI_DOCS_DIR` environment variable,\n            or \"docs\" if not set.\n    \"\"\"\n    self._observability = observability\n    self._telemetry = telemetry\n    env_root = os.getenv(\"BIJUXCLI_DOCS_DIR\")\n    root_dir = env_root if env_root else (root or \"docs\")\n    self._root = Path(root_dir)\n    self._root.mkdir(exist_ok=True, parents=True)\n    if telemetry not in self._serializers:\n        self._serializers[telemetry] = {}\n</code></pre>"},{"location":"reference/services/docs.html#bijux_cli.services.docs.Docs.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Closes the service. This is a no-op for this implementation.</p> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Closes the service. This is a no-op for this implementation.\"\"\"\n    return\n</code></pre>"},{"location":"reference/services/docs.html#bijux_cli.services.docs.Docs.render","title":"render","text":"<pre><code>render(spec: dict[str, Any], *, fmt: OutputFormat) -&gt; str\n</code></pre> <p>Renders a specification dictionary to a string in the given format.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to serialize.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The desired output format (e.g., JSON, YAML).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The serialized specification as a string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If the underlying serializer returns a non-string result.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def render(self, spec: dict[str, Any], *, fmt: OutputFormat) -&gt; str:\n    \"\"\"Renders a specification dictionary to a string in the given format.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to serialize.\n        fmt (OutputFormat): The desired output format (e.g., JSON, YAML).\n\n    Returns:\n        str: The serialized specification as a string.\n\n    Raises:\n        TypeError: If the underlying serializer returns a non-string result.\n    \"\"\"\n    if self._telemetry not in self._serializers:\n        self._serializers[self._telemetry] = {}\n    if fmt not in self._serializers[self._telemetry]:\n        self._serializers[self._telemetry][fmt] = serializer_for(\n            fmt, self._telemetry\n        )\n    result = self._serializers[self._telemetry][fmt].dumps(\n        spec, fmt=fmt, pretty=False\n    )\n    if not isinstance(result, str):\n        raise TypeError(\n            f\"Expected str from serializer.dumps, got {type(result).__name__}\"\n        )\n    return result\n</code></pre>"},{"location":"reference/services/docs.html#bijux_cli.services.docs.Docs.write","title":"write","text":"<pre><code>write(\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = JSON,\n    name: str = \"spec\",\n) -&gt; str\n</code></pre> <p>Writes a specification to a file and returns the path as a string.</p> <p>This is a convenience wrapper around <code>write_sync</code>.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>, default:                   <code>JSON</code> )           \u2013            <p>The output format. Defaults to <code>OutputFormat.JSON</code>.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>'spec'</code> )           \u2013            <p>The base name for the output file. Defaults to 'spec'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The absolute path to the written file.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def write(\n    self,\n    spec: dict[str, Any],\n    *,\n    fmt: OutputFormat = OutputFormat.JSON,\n    name: str = \"spec\",\n) -&gt; str:\n    \"\"\"Writes a specification to a file and returns the path as a string.\n\n    This is a convenience wrapper around `write_sync`.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The output format. Defaults to `OutputFormat.JSON`.\n        name (str): The base name for the output file. Defaults to 'spec'.\n\n    Returns:\n        str: The absolute path to the written file.\n    \"\"\"\n    path = self.write_sync(spec, fmt, name)\n    return str(path)\n</code></pre>"},{"location":"reference/services/docs.html#bijux_cli.services.docs.Docs.write_sync","title":"write_sync","text":"<pre><code>write_sync(\n    spec: dict[str, Any],\n    fmt: OutputFormat,\n    name: str | Path,\n) -&gt; Path\n</code></pre> <p>Writes the specification to a file synchronously.</p> <p>This method handles path resolution, serializes the <code>spec</code> dictionary, and writes the content to the final destination file.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The specification dictionary to write.</p> </li> <li> <code>fmt</code>               (<code>OutputFormat</code>)           \u2013            <p>The desired output format.</p> </li> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The path or base name for the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code> (              <code>Path</code> )          \u2013            <p>The <code>Path</code> object pointing to the written file.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If writing to the file fails due to an <code>OSError</code>.</p> </li> </ul> Source code in <code>src/bijux_cli/services/docs.py</code> <pre><code>def write_sync(\n    self, spec: dict[str, Any], fmt: OutputFormat, name: str | Path\n) -&gt; Path:\n    \"\"\"Writes the specification to a file synchronously.\n\n    This method handles path resolution, serializes the `spec` dictionary,\n    and writes the content to the final destination file.\n\n    Args:\n        spec (dict[str, Any]): The specification dictionary to write.\n        fmt (OutputFormat): The desired output format.\n        name (str | Path): The path or base name for the output file.\n\n    Returns:\n        Path: The `Path` object pointing to the written file.\n\n    Raises:\n        ServiceError: If writing to the file fails due to an `OSError`.\n    \"\"\"\n    final_path = None\n    try:\n        final_path = Path(name).expanduser().resolve()\n        if final_path.is_dir():\n            final_path = final_path / f\"spec.{fmt.value}\"\n        final_path.parent.mkdir(parents=True, exist_ok=True)\n        content = self.render(spec, fmt=fmt)\n        final_path.write_text(content, encoding=\"utf-8\")\n        self._observability.log(\"info\", f\"Wrote docs to {final_path}\")\n        self._telemetry.event(\n            \"docs_written\", {\"path\": str(final_path), \"format\": fmt.value}\n        )\n        return final_path\n    except OSError as exc:\n        self._telemetry.event(\n            \"docs_write_failed\",\n            {\n                \"path\": (\n                    str(final_path) if final_path is not None else \"&lt;unresolved&gt;\"\n                ),\n                \"error\": str(exc),\n            },\n        )\n        raise ServiceError(f\"Unable to write spec: {exc}\", http_status=403) from exc\n</code></pre>"},{"location":"reference/services/doctor.html","title":"Doctor Module API Reference","text":"<p>This section documents the internals of the <code>doctor</code> module in Bijux CLI. </p>"},{"location":"reference/services/doctor.html#bijux_cli.services.doctor","title":"bijux_cli.services.doctor","text":"<p>Provides the concrete implementation of the CLI health check service.</p> <p>This module defines the <code>Doctor</code> class, which implements the <code>DoctorProtocol</code>. It is responsible for performing diagnostic health checks on the application and its environment.</p>"},{"location":"reference/services/doctor.html#bijux_cli.services.doctor.Doctor","title":"Doctor","text":"<p>               Bases: <code>DoctorProtocol</code></p> <p>An implementation of the health check service.</p> <p>This class provides a simple health check method that can be extended in the future to verify dependencies, such as database connections or external API reachability.</p>"},{"location":"reference/services/doctor.html#bijux_cli.services.doctor.Doctor.check_health","title":"check_health","text":"<pre><code>check_health() -&gt; str\n</code></pre> <p>Performs a basic health check on the application.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string indicating the health status. Currently always returns \"healthy\".</p> </li> </ul> Source code in <code>src/bijux_cli/services/doctor.py</code> <pre><code>def check_health(self) -&gt; str:\n    \"\"\"Performs a basic health check on the application.\n\n    Returns:\n        str: A string indicating the health status. Currently always\n            returns \"healthy\".\n    \"\"\"\n    return \"healthy\"\n</code></pre>"},{"location":"reference/services/history.html","title":"History Module API Reference","text":"<p>This section documents the internals of the <code>history</code> module in Bijux CLI. </p>"},{"location":"reference/services/history.html#bijux_cli.services.history","title":"bijux_cli.services.history","text":"<p>Provides a persistent, cross-process safe command history service.</p> <p>This module defines the <code>History</code> class, a concrete implementation of the <code>HistoryProtocol</code>. It provides a tolerant and robust store for CLI invocation events with several key design features:</p> <pre><code>* **Persistence:** All history is saved to a single JSON array in a\n    per-user file.\n* **Tolerance:** The service is resilient to empty, corrupt, or partially\n    formed history files. If a file is unreadable, it is treated as empty\n    and will be overwritten on the next successful write.\n* **Cross-Process Safety:** On POSIX systems, it uses `fcntl.flock` on a\n    sidecar lock file to safely coordinate writes from multiple concurrent\n    CLI processes. On other systems, it falls back to a thread lock.\n* **Atomic Writes:** All changes are written to a temporary file which is\n    then atomically moved into place, preventing data corruption from\n    interrupted writes.\n* **Memory Management:** The in-memory list of events is capped, and the\n    on-disk file is trimmed to a smaller size to prevent unbounded growth.\n* **Simplicity:** The service intentionally avoids complex features like\n    schema migrations. Unreadable state is discarded rather than repaired.\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History","title":"History","text":"<pre><code>History(\n    telemetry: LoggingTelemetry,\n    observability: Observability,\n    history_path: Path | None = None,\n)\n</code></pre> <p>               Bases: <code>HistoryProtocol</code></p> <p>Manages a persistent history of CLI command invocations.</p> <p>This service maintains an in-memory list of command events and synchronizes it with a persisted JSON file. It is designed to be tolerant of file corruption and safe for concurrent use by multiple CLI processes.</p> <p>Mutating operations (<code>add</code>, <code>clear</code>, <code>import_</code>) acquire a cross-process lock before modifying the file to prevent lost updates and race conditions. The sequence is always: lock, reload from disk, apply change in memory, write atomically, and release lock.</p> <p>Attributes:</p> <ul> <li> <code>_tel</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for emitting events.</p> </li> <li> <code>_obs</code>               (<code>Observability</code>)           \u2013            <p>The logging service for operational errors.</p> </li> <li> <code>_explicit_path</code>               (<code>Path | None</code>)           \u2013            <p>A specific path to the history file, if provided during initialization.</p> </li> <li> <code>_events</code>               (<code>list</code>)           \u2013            <p>The in-memory cache of history event dictionaries.</p> </li> <li> <code>_load_error</code>               (<code>str | None</code>)           \u2013            <p>A message describing the last error that occurred while trying to load the history file, if any.</p> </li> </ul> <p>Initializes the History service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service.</p> </li> <li> <code>observability</code>               (<code>Observability</code>)           \u2013            <p>The logging service.</p> </li> <li> <code>history_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional, explicit path to the history file. If None, a default path will be used.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>@inject\ndef __init__(\n    self,\n    telemetry: LoggingTelemetry,\n    observability: Observability,\n    history_path: Path | None = None,\n) -&gt; None:\n    \"\"\"Initializes the History service.\n\n    Args:\n        telemetry (LoggingTelemetry): The telemetry service.\n        observability (Observability): The logging service.\n        history_path (Path | None): An optional, explicit path to the\n            history file. If None, a default path will be used.\n    \"\"\"\n    self._tel = telemetry\n    self._obs = observability\n    self._explicit_path = Path(history_path) if history_path else None\n    self._events: list[dict[str, Any]] = []\n    self._load_error: str | None = None\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.add","title":"add","text":"<pre><code>add(\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None\n</code></pre> <p>Appends a new command invocation to the history.</p> <p>This operation is cross-process safe. It acquires a lock, reloads the latest history from disk, appends the new entry, and writes the updated history back atomically. Errors are logged but suppressed to allow the originating command to complete its execution.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>The command name (ASCII characters are enforced).</p> </li> <li> <code>params</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of parameters and flags.</p> </li> <li> <code>success</code>               (<code>bool | None</code>, default:                   <code>True</code> )           \u2013            <p>Whether the command succeeded.</p> </li> <li> <code>return_code</code>               (<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>The exit code of the command.</p> </li> <li> <code>duration_ms</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The command's duration in milliseconds.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def add(\n    self,\n    command: str,\n    *,\n    params: Sequence[str] | None = None,\n    success: bool | None = True,\n    return_code: int | None = 0,\n    duration_ms: float | None = None,\n) -&gt; None:\n    \"\"\"Appends a new command invocation to the history.\n\n    This operation is cross-process safe. It acquires a lock, reloads the\n    latest history from disk, appends the new entry, and writes the\n    updated history back atomically. Errors are logged but suppressed to\n    allow the originating command to complete its execution.\n\n    Args:\n        command (str): The command name (ASCII characters are enforced).\n        params (Sequence[str] | None): A list of parameters and flags.\n        success (bool | None): Whether the command succeeded.\n        return_code (int | None): The exit code of the command.\n        duration_ms (float | None): The command's duration in milliseconds.\n    \"\"\"\n    fp = self._get_history_path()\n    entry = {\n        \"command\": _ascii_clean(command),\n        \"params\": list(params or []),\n        \"timestamp\": _now(),\n        \"success\": bool(success),\n        \"return_code\": return_code if return_code is not None else 0,\n        \"duration_ms\": float(duration_ms) if duration_ms is not None else None,\n    }\n    with _interprocess_lock(fp):\n        self._reload()\n        if self._load_error:\n            msg = f\"[error] Could not load command history: {self._load_error}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._events = []\n        self._events.append(entry)\n        try:\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n        except PermissionError as exc:\n            msg = f\"[error] Could not record command history: {exc}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._load_error = msg\n            return\n        except OSError as exc:\n            if exc.errno in _ENOSPC_ERRORS:\n                msg = f\"[error] Could not record command history: {exc}\"\n                self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n                print(msg, file=sys.stderr)\n                self._load_error = msg\n                return\n            msg = f\"[error] Could not record command history: {exc}\"\n            self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n            print(msg, file=sys.stderr)\n            self._load_error = msg\n            return\n    with suppress(Exception):\n        self._tel.event(\"history_event_added\", {\"command\": entry[\"command\"]})\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Erases all persisted history.</p> <p>This operation is cross-process safe and atomic.</p> <p>Raises:</p> <ul> <li> <code>PermissionError</code>             \u2013            <p>If the history file or directory is not writable.</p> </li> <li> <code>OSError</code>             \u2013            <p>For other filesystem-related failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Erases all persisted history.\n\n    This operation is cross-process safe and atomic.\n\n    Raises:\n        PermissionError: If the history file or directory is not writable.\n        OSError: For other filesystem-related failures.\n    \"\"\"\n    fp = self._get_history_path()\n    try:\n        with _interprocess_lock(fp):\n            self._events = []\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n            self._tel.event(\"history_cleared\", {})\n    except Exception as exc:\n        msg = f\"History clear failed: {exc}\"\n        self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n        self._load_error = msg\n        raise\n    finally:\n        self._reload()\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.export","title":"export","text":"<pre><code>export(path: Path) -&gt; None\n</code></pre> <p>Exports the current history to a file as a JSON array.</p> <p>This operation is a read-only snapshot and does not lock the source file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The destination file path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>On I/O failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def export(self, path: Path) -&gt; None:\n    \"\"\"Exports the current history to a file as a JSON array.\n\n    This operation is a read-only snapshot and does not lock the source file.\n\n    Args:\n        path (Path): The destination file path.\n\n    Raises:\n        RuntimeError: On I/O failures.\n    \"\"\"\n    self._reload()\n    try:\n        path = path.expanduser()\n        path.parent.mkdir(parents=True, exist_ok=True)\n        text = json.dumps(self._events, ensure_ascii=False, indent=2) + \"\\n\"\n        path.write_text(text, encoding=\"utf-8\")\n    except Exception as exc:\n        raise RuntimeError(f\"Failed exporting history: {exc}\") from exc\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.flush","title":"flush","text":"<pre><code>flush() -&gt; None\n</code></pre> <p>Persists all in-memory history data to disk.</p> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def flush(self) -&gt; None:\n    \"\"\"Persists all in-memory history data to disk.\"\"\"\n    self._dump()\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.import_","title":"import_","text":"<pre><code>import_(path: Path) -&gt; None\n</code></pre> <p>Imports history entries from a file, merging with current history.</p> <p>This operation is cross-process safe and atomic.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The source file path containing a JSON array of entries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>On I/O or parsing failures.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def import_(self, path: Path) -&gt; None:\n    \"\"\"Imports history entries from a file, merging with current history.\n\n    This operation is cross-process safe and atomic.\n\n    Args:\n        path (Path): The source file path containing a JSON array of entries.\n\n    Raises:\n        RuntimeError: On I/O or parsing failures.\n    \"\"\"\n    fp = self._get_history_path()\n    try:\n        with _interprocess_lock(fp):\n            self._reload()\n            if self._load_error:\n                raise RuntimeError(self._load_error)\n            path = path.expanduser()\n            if not path.exists():\n                raise RuntimeError(f\"Import file not found: {path}\")\n            raw = path.read_text(encoding=\"utf-8\")\n            data = json.loads(raw)\n            if not isinstance(data, list):\n                raise RuntimeError(\n                    f\"Invalid import format (not JSON array): {path}\"\n                )\n            imported: list[dict[str, Any]] = []\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n                e = dict(item)\n                e[\"command\"] = _ascii_clean(str(e.get(\"command\", \"\")))\n                if \"timestamp\" not in e:\n                    e[\"timestamp\"] = _now()\n                imported.append(e)\n            self._events.extend(imported)\n            if len(self._events) &gt; _MAX_IN_MEMORY:\n                self._events = self._events[-_MAX_IN_MEMORY:]\n            _atomic_write_json(fp, self._events)\n            self._load_error = None\n            with suppress(Exception):\n                self._tel.event(\"history_imported\", {\"count\": len(imported)})\n\n    except Exception as exc:\n        msg = f\"History import failed: {exc}\"\n        self._obs.log(\n            \"error\", msg, extra={\"import_path\": str(path), \"history_path\": str(fp)}\n        )\n        raise RuntimeError(msg) from exc\n</code></pre>"},{"location":"reference/services/history.html#bijux_cli.services.history.History.list","title":"list","text":"<pre><code>list(\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Returns a view of the command history, with optional transformations.</p> <p>This is a read-only operation and does not acquire a cross-process lock, meaning it may not reflect writes from concurrent processes.</p> <p>Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>20</code> )           \u2013            <p>The maximum number of entries to return. A value of 0 returns an empty list.</p> </li> <li> <code>group_by</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, returns a grouped summary.</p> </li> <li> <code>filter_cmd</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, returns only entries whose command contains this case-sensitive substring.</p> </li> <li> <code>sort</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If 'timestamp', sorts entries by timestamp.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of history entries or grouped summaries.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the history file is corrupt.</p> </li> </ul> Source code in <code>src/bijux_cli/services/history.py</code> <pre><code>def list(\n    self,\n    *,\n    limit: int | None = 20,\n    group_by: str | None = None,\n    filter_cmd: str | None = None,\n    sort: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Returns a view of the command history, with optional transformations.\n\n    This is a read-only operation and does not acquire a cross-process lock,\n    meaning it may not reflect writes from concurrent processes.\n\n    Args:\n        limit (int | None): The maximum number of entries to return. A value\n            of 0 returns an empty list.\n        group_by (str | None): If provided, returns a grouped summary.\n        filter_cmd (str | None): If provided, returns only entries whose\n            command contains this case-sensitive substring.\n        sort (str | None): If 'timestamp', sorts entries by timestamp.\n\n    Returns:\n        list[dict[str, Any]]: A list of history entries or grouped summaries.\n\n    Raises:\n        RuntimeError: If the history file is corrupt.\n    \"\"\"\n    self._reload()\n    fp = self._get_history_path()\n    try:\n        writable = os.access(fp.parent, os.W_OK)\n    except Exception:\n        writable = True\n    if not writable:\n        msg = f\"Permission denied for history directory: {fp.parent}\"\n        self._obs.log(\"error\", msg, extra={\"path\": str(fp)})\n        print(msg, file=sys.stderr)\n    if self._load_error:\n        raise RuntimeError(self._load_error)\n    if limit == 0:\n        return []\n    entries: list[dict[str, Any]] = list(self._events)\n    if filter_cmd:\n        needle = str(filter_cmd)\n        entries = [e for e in entries if needle in (e.get(\"command\") or \"\")]\n    if sort == \"timestamp\":\n        entries.sort(key=lambda e: e.get(\"timestamp\", 0))\n    if group_by:\n        grouped: dict[Any, MutableSequence[dict[str, Any]]] = {}\n        for e in entries:\n            grouped.setdefault(e.get(group_by, \"unknown\"), []).append(e)\n        summary = [\n            {\n                \"group\": k,\n                \"count\": len(v),\n                \"last_run\": max((x.get(\"timestamp\", 0) for x in v), default=0),\n            }\n            for k, v in grouped.items()\n        ]\n        return summary[:limit] if (limit and limit &gt; 0) else summary\n    if limit and limit &gt; 0:\n        entries = entries[-limit:]\n    return entries\n</code></pre>"},{"location":"reference/services/memory.html","title":"Memory Module API Reference","text":"<p>This section documents the internals of the <code>memory</code> module in Bijux CLI. </p>"},{"location":"reference/services/memory.html#bijux_cli.services.memory","title":"bijux_cli.services.memory","text":"<p>Provides a thread-safe, file-persisted key-value store.</p> <p>This module defines the <code>Memory</code> class, a concrete implementation of the <code>MemoryProtocol</code>. It uses a dictionary for in-memory storage, protected by a <code>threading.Lock</code> for thread safety. Unlike a purely transient store, this implementation persists the entire key-value store to a JSON file on every write operation, allowing state to survive across different CLI invocations.</p>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory","title":"Memory","text":"<pre><code>Memory()\n</code></pre> <p>               Bases: <code>MemoryProtocol</code></p> <p>Implements <code>MemoryProtocol</code> with a thread-safe, file-backed dictionary.</p> <p>This service provides a simple key-value store that is both thread-safe and persistent to a JSON file (<code>~/.bijux/.memory.json</code>).</p> <p>Attributes:</p> <ul> <li> <code>_store</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The in-memory dictionary holding the data.</p> </li> <li> <code>_lock</code>               (<code>Lock</code>)           \u2013            <p>A lock to ensure thread-safe access to the store.</p> </li> </ul> <p>Initializes the service, loading existing data from the persistence file.</p> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>@inject\ndef __init__(self) -&gt; None:\n    \"\"\"Initializes the service, loading existing data from the persistence file.\"\"\"\n    MEMORY_FILE.parent.mkdir(parents=True, exist_ok=True)\n    try:\n        with MEMORY_FILE.open(\"r\") as f:\n            self._store: dict[str, Any] = json.load(f)\n    except (FileNotFoundError, json.JSONDecodeError):\n        self._store = {}\n    self._lock = Lock()\n</code></pre>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Removes all key-value pairs and persists the change to disk.</p> <p>This operation is thread-safe.</p> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Removes all key-value pairs and persists the change to disk.\n\n    This operation is thread-safe.\n    \"\"\"\n    with self._lock:\n        self._store.clear()\n        self._persist()\n</code></pre>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory.delete","title":"delete","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Deletes a key-value pair and persists the change to disk.</p> <p>This operation is thread-safe.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to delete.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Deletes a key-value pair and persists the change to disk.\n\n    This operation is thread-safe.\n\n    Args:\n        key (str): The key of the value to delete.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    with self._lock:\n        if key not in self._store:\n            raise KeyError(f\"Memory key not found: {key}\")\n        del self._store[key]\n        self._persist()\n</code></pre>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Retrieves a value by its key in a thread-safe manner.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key of the value to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The value associated with the key.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If the key does not exist in the store.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n    \"\"\"Retrieves a value by its key in a thread-safe manner.\n\n    Args:\n        key (str): The key of the value to retrieve.\n\n    Returns:\n        Any: The value associated with the key.\n\n    Raises:\n        KeyError: If the key does not exist in the store.\n    \"\"\"\n    with self._lock:\n        if key not in self._store:\n            raise KeyError(f\"Memory key not found: {key}\")\n        return self._store[key]\n</code></pre>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory.keys","title":"keys","text":"<pre><code>keys() -&gt; list[str]\n</code></pre> <p>Returns a list of all keys currently in the store.</p> <p>This operation is thread-safe.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of all string keys.</p> </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def keys(self) -&gt; list[str]:\n    \"\"\"Returns a list of all keys currently in the store.\n\n    This operation is thread-safe.\n\n    Returns:\n        list[str]: A list of all string keys.\n    \"\"\"\n    with self._lock:\n        return list(self._store.keys())\n</code></pre>"},{"location":"reference/services/memory.html#bijux_cli.services.memory.Memory.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a key-value pair and persists the change to disk.</p> <p>If the key already exists, its value is overwritten. This operation is thread-safe.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>The key for the value being set.</p> </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            <p>The value to store.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/memory.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a key-value pair and persists the change to disk.\n\n    If the key already exists, its value is overwritten. This operation\n    is thread-safe.\n\n    Args:\n        key (str): The key for the value being set.\n        value (Any): The value to store.\n\n    Returns:\n        None:\n    \"\"\"\n    with self._lock:\n        self._store[key] = value\n        self._persist()\n</code></pre>"},{"location":"reference/services/utils.html","title":"Utils Module API Reference","text":"<p>This section documents the internals of the <code>utils</code> module in Bijux CLI. </p>"},{"location":"reference/services/utils.html#bijux_cli.services.utils","title":"bijux_cli.services.utils","text":"<p>Provides shared utility functions for the CLI's service layer.</p> <p>This module contains common helper functions used by various service implementations. It centralizes logic for tasks like input validation and security checks to ensure consistency and robustness across the service layer.</p>"},{"location":"reference/services/utils.html#bijux_cli.services.utils.validate_command","title":"validate_command","text":"<pre><code>validate_command(cmd: list[str]) -&gt; list[str]\n</code></pre> <p>Validates a command and its arguments against a whitelist.</p> <p>This security function is designed to prevent shell injection vulnerabilities. It performs several checks: 1.  Verifies the command name against an allowlist defined by the     <code>BIJUXCLI_ALLOWED_COMMANDS</code> environment variable. 2.  Resolves the command's absolute path to ensure it's on the system PATH. 3.  Checks arguments for forbidden shell metacharacters.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>list[str]</code>)           \u2013            <p>The command and arguments to validate, as a list of strings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A validated and safe command list, with the command name replaced by its absolute path, suitable for use with <code>subprocess.run</code> where <code>shell=False</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BijuxError</code>             \u2013            <p>If the command is empty, not on the allowlist, not found on the system PATH, or if any argument contains unsafe characters.</p> </li> </ul> Source code in <code>src/bijux_cli/services/utils.py</code> <pre><code>def validate_command(cmd: list[str]) -&gt; list[str]:\n    \"\"\"Validates a command and its arguments against a whitelist.\n\n    This security function is designed to prevent shell injection vulnerabilities.\n    It performs several checks:\n    1.  Verifies the command name against an allowlist defined by the\n        `BIJUXCLI_ALLOWED_COMMANDS` environment variable.\n    2.  Resolves the command's absolute path to ensure it's on the system PATH.\n    3.  Checks arguments for forbidden shell metacharacters.\n\n    Args:\n        cmd (list[str]): The command and arguments to validate, as a list of\n            strings.\n\n    Returns:\n        list[str]: A validated and safe command list, with the command name\n            replaced by its absolute path, suitable for use with `subprocess.run`\n            where `shell=False`.\n\n    Raises:\n        BijuxError: If the command is empty, not on the allowlist, not found\n            on the system PATH, or if any argument contains unsafe characters.\n    \"\"\"\n    if not cmd:\n        raise BijuxError(\"Empty command not allowed\", http_status=403)\n    env_val = os.getenv(\"BIJUXCLI_ALLOWED_COMMANDS\")\n    allowed_commands = (env_val or \"echo,ls,cat,grep\").split(\",\")\n\n    cmd_name = os.path.basename(cmd[0])\n    if cmd_name not in allowed_commands:\n        raise BijuxError(\n            f\"Command {cmd_name!r} not in allowed list: {allowed_commands}\",\n            http_status=403,\n        )\n    resolved_cmd_path = shutil.which(cmd[0])\n    if not resolved_cmd_path:\n        raise BijuxError(\n            f\"Command not found or not executable: {cmd[0]!r}\", http_status=403\n        )\n    if os.path.basename(resolved_cmd_path) != cmd_name:\n        raise BijuxError(f\"Disallowed command path: {cmd[0]!r}\", http_status=403)\n    cmd[0] = resolved_cmd_path\n    forbidden = set(\";|&amp;&gt;&lt;`!\")\n    for arg in cmd[1:]:\n        if any(ch in arg for ch in forbidden):\n            raise BijuxError(f\"Unsafe argument: {arg!r}\", http_status=403)\n    return cmd\n</code></pre>"},{"location":"reference/services/plugins/index.html","title":"Reference / Services / Plugins Index","text":"<ul> <li>Entrypoints Module</li> <li>Groups Module</li> <li>Hooks Module</li> <li>Registry Module</li> </ul>"},{"location":"reference/services/plugins/entrypoints.html","title":"Entrypoints Module API Reference","text":"<p>This section documents the internals of the <code>entrypoints</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/entrypoints.html#bijux_cli.services.plugins.entrypoints","title":"bijux_cli.services.plugins.entrypoints","text":"<p>Discovers and loads plugins distributed as Python packages.</p> <p>This module provides the <code>load_entrypoints</code> function, which is responsible for finding and loading plugins that have been installed into the Python environment and registered under the <code>bijux_cli.plugins</code> entry point group. This enables a distributable plugin ecosystem where plugins can be managed via tools like <code>pip</code>.</p>"},{"location":"reference/services/plugins/entrypoints.html#bijux_cli.services.plugins.entrypoints.load_entrypoints","title":"load_entrypoints  <code>async</code>","text":"<pre><code>load_entrypoints(\n    di: DIContainer | None = None,\n    registry: RegistryProtocol | None = None,\n) -&gt; None\n</code></pre> <p>Discovers, loads, and registers all entry point-based plugins.</p> <p>This function iterates through all entry points in the 'bijux_cli.plugins' group. For each one, it attempts to load, instantiate, and register the plugin. It also performs an API version compatibility check and runs the plugin's <code>startup</code> hook if present.</p> Note <p>All exceptions during the loading or startup of a single plugin are caught, logged, and reported via telemetry. A failed plugin will be deregistered and will not prevent other plugins from loading.</p> <p>Parameters:</p> <ul> <li> <code>di</code>               (<code>DIContainer | None</code>, default:                   <code>None</code> )           \u2013            <p>The dependency injection container. If None, the current global container is used.</p> </li> <li> <code>registry</code>               (<code>RegistryProtocol | None</code>, default:                   <code>None</code> )           \u2013            <p>The plugin registry. If None, it is resolved from the DI container.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> Source code in <code>src/bijux_cli/services/plugins/entrypoints.py</code> <pre><code>async def load_entrypoints(\n    di: DIContainer | None = None,\n    registry: RegistryProtocol | None = None,\n) -&gt; None:\n    \"\"\"Discovers, loads, and registers all entry point-based plugins.\n\n    This function iterates through all entry points in the 'bijux_cli.plugins'\n    group. For each one, it attempts to load, instantiate, and register the\n    plugin. It also performs an API version compatibility check and runs the\n    plugin's `startup` hook if present.\n\n    Note:\n        All exceptions during the loading or startup of a single plugin are\n        caught, logged, and reported via telemetry. A failed plugin will be\n        deregistered and will not prevent other plugins from loading.\n\n    Args:\n        di (DIContainer | None): The dependency injection container. If None,\n            the current global container is used.\n        registry (RegistryProtocol | None): The plugin registry. If None, it is\n            resolved from the DI container.\n\n    Returns:\n        None:\n    \"\"\"\n    import bijux_cli\n\n    di = di or DIContainer.current()\n    registry = registry or di.resolve(RegistryProtocol)\n\n    obs = di.resolve(ObservabilityProtocol, None)\n    tel = di.resolve(TelemetryProtocol, None)\n\n    for ep in _iter_plugin_eps():\n        try:\n            plugin_class = ep.load()\n            plugin = plugin_class()\n\n            if not _compatible(plugin):\n                raise RuntimeError(\n                    f\"Plugin '{ep.name}' requires API {getattr(plugin, 'requires_api_version', 'N/A')}, \"\n                    f\"host is {bijux_cli.api_version}\"\n                )\n\n            for tgt in (plugin_class, plugin):\n                raw = getattr(tgt, \"version\", None)\n                if raw is not None and not isinstance(raw, str):\n                    tgt.version = str(raw)\n\n            registry.register(ep.name, plugin, version=plugin.version)\n\n            startup = getattr(plugin, \"startup\", None)\n            if asyncio.iscoroutinefunction(startup):\n                await startup(di)\n            elif callable(startup):\n                startup(di)\n\n            if obs:\n                obs.log(\"info\", f\"Loaded plugin '{ep.name}'\")\n            if tel:\n                tel.event(\"entrypoint_plugin_loaded\", {\"name\": ep.name})\n\n        except Exception as exc:\n            with contextlib.suppress(Exception):\n                registry.deregister(ep.name)\n\n            if obs:\n                obs.log(\n                    \"error\",\n                    f\"Failed to load plugin '{ep.name}'\",\n                    extra={\"trace\": traceback.format_exc(limit=5)},\n                )\n            if tel:\n                tel.event(\n                    \"entrypoint_plugin_failed\", {\"name\": ep.name, \"error\": str(exc)}\n                )\n\n            _LOG.debug(\"Skipped plugin %s: %s\", ep.name, exc, exc_info=True)\n</code></pre>"},{"location":"reference/services/plugins/groups.html","title":"Groups Module API Reference","text":"<p>This section documents the internals of the <code>groups</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/groups.html#bijux_cli.services.plugins.groups","title":"bijux_cli.services.plugins.groups","text":"<p>Provides helpers for defining plugin command groups and autocompletions.</p> <p>This module offers a convenient, decorator-based API for plugin developers to register command groups and their subcommands. It also includes a factory function for creating dynamic shell completers for command arguments, enhancing the interactive user experience of plugins.</p>"},{"location":"reference/services/plugins/groups.html#bijux_cli.services.plugins.groups.command_group","title":"command_group","text":"<pre><code>command_group(\n    name: str, *, version: str | None = None\n) -&gt; Callable[\n    [str],\n    Callable[[Callable[..., Any]], Callable[..., Any]],\n]\n</code></pre> <p>A decorator factory for registering plugin subcommands under a group.</p> <p>This function is designed to be used as a nested decorator to easily define command groups within a plugin.</p> Example <p>A plugin can define a \"user\" command group with a \"create\" subcommand like this::</p> <pre><code>group = command_group(\"user\", version=\"1.0\")\n\n@group(sub=\"create\")\ndef create_user(username: str):\n    ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the parent command group (e.g., \"user\").</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the group.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]</code>           \u2013            <p>Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]: A decorator that takes a subcommand name and returns the final decorator for the function.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/groups.py</code> <pre><code>def command_group(\n    name: str,\n    *,\n    version: str | None = None,\n) -&gt; Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]:\n    \"\"\"A decorator factory for registering plugin subcommands under a group.\n\n    This function is designed to be used as a nested decorator to easily\n    define command groups within a plugin.\n\n    Example:\n        A plugin can define a \"user\" command group with a \"create\" subcommand\n        like this::\n\n            group = command_group(\"user\", version=\"1.0\")\n\n            @group(sub=\"create\")\n            def create_user(username: str):\n                ...\n\n    Args:\n        name (str): The name of the parent command group (e.g., \"user\").\n        version (str | None): An optional version string for the group.\n\n    Returns:\n        Callable[[str], Callable[[Callable[..., Any]], Callable[..., Any]]]:\n            A decorator that takes a subcommand name and returns the final\n            decorator for the function.\n    \"\"\"\n\n    def with_sub(sub: str) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n        \"\"\"Captures the subcommand name for registration.\n\n        Args:\n            sub (str): The name of the subcommand (e.g., \"create\").\n\n        Returns:\n            A decorator for the subcommand function.\n\n        Raises:\n            ValueError: If the subcommand name contains spaces.\n        \"\"\"\n        if \" \" in sub:\n            raise ValueError(\"subcommand may not contain spaces\")\n        full = f\"{name} {sub}\"\n\n        def decorator(fn: Callable[..., Any]) -&gt; Callable[..., Any]:\n            \"\"\"Registers the decorated function as a command.\n\n            Args:\n                fn (Callable[..., Any]): The function to register as a subcommand.\n\n            Returns:\n                The original, undecorated function.\n\n            Raises:\n                RuntimeError: If the `RegistryProtocol` is not initialized.\n            \"\"\"\n            try:\n                di = DIContainer.current()\n                reg: RegistryProtocol = di.resolve(RegistryProtocol)\n            except KeyError as exc:\n                raise RuntimeError(\"RegistryProtocol is not initialized\") from exc\n\n            reg.register(full, fn, version=version)\n\n            try:\n                obs: ObservabilityProtocol = di.resolve(ObservabilityProtocol)\n                obs.log(\n                    \"info\",\n                    \"Registered command group\",\n                    extra={\"cmd\": full, \"version\": version},\n                )\n            except KeyError:\n                pass\n\n            try:\n                tel: TelemetryProtocol = di.resolve(TelemetryProtocol)\n                tel.event(\n                    \"command_group_registered\", {\"command\": full, \"version\": version}\n                )\n            except KeyError:\n                pass\n\n            return fn\n\n        return decorator\n\n    return with_sub\n</code></pre>"},{"location":"reference/services/plugins/groups.html#bijux_cli.services.plugins.groups.dynamic_choices","title":"dynamic_choices","text":"<pre><code>dynamic_choices(\n    callback: Callable[[], list[str]],\n    *,\n    case_sensitive: bool = True,\n) -&gt; Callable[[Context, ParameterInfo, str], list[str]]\n</code></pre> <p>Creates a <code>Typer</code> completer from a callback function.</p> <p>This factory function generates a completer that provides dynamic shell completion choices for a command argument or option.</p> Example <p>To provide dynamic completion for a <code>--user</code> option::</p> <pre><code>def get_all_users() -&gt; list[str]:\n    return [\"alice\", \"bob\", \"carol\"]\n\n@app.command()\ndef delete(\n    user: str = typer.Option(\n        ...,\n        autocompletion=dynamic_choices(get_all_users)\n    )\n):\n    ...\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[[], list[str]]</code>)           \u2013            <p>A no-argument function that returns a list of all possible choices.</p> </li> <li> <code>case_sensitive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, prefix matching is case-sensitive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[Context, ParameterInfo, str], list[str]]</code>           \u2013            <p>A <code>Typer</code> completer function.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/groups.py</code> <pre><code>def dynamic_choices(\n    callback: Callable[[], list[str]],\n    *,\n    case_sensitive: bool = True,\n) -&gt; Callable[[typer.Context, typer.models.ParameterInfo, str], list[str]]:\n    \"\"\"Creates a `Typer` completer from a callback function.\n\n    This factory function generates a completer that provides dynamic shell\n    completion choices for a command argument or option.\n\n    Example:\n        To provide dynamic completion for a `--user` option::\n\n            def get_all_users() -&gt; list[str]:\n                return [\"alice\", \"bob\", \"carol\"]\n\n            @app.command()\n            def delete(\n                user: str = typer.Option(\n                    ...,\n                    autocompletion=dynamic_choices(get_all_users)\n                )\n            ):\n                ...\n\n    Args:\n        callback (Callable[[], list[str]]): A no-argument function that returns\n            a list of all possible choices.\n        case_sensitive (bool): If True, prefix matching is case-sensitive.\n\n    Returns:\n        A `Typer` completer function.\n    \"\"\"\n\n    def completer(\n        ctx: typer.Context,\n        param: typer.models.ParameterInfo,\n        incomplete: str,\n    ) -&gt; list[str]:\n        \"\"\"Filters the choices provided by the callback based on user input.\n\n        Args:\n            ctx (typer.Context): The `Typer` command context.\n            param (typer.models.ParameterInfo): The parameter being completed.\n            incomplete (str): The current incomplete user input.\n\n        Returns:\n            list[str]: A filtered list of choices that start with the\n                `incomplete` string.\n        \"\"\"\n        items = callback()\n        if case_sensitive:\n            return [i for i in items if i.startswith(incomplete)]\n        low = incomplete.lower()\n        return [i for i in items if i.lower().startswith(low)]\n\n    return completer\n</code></pre>"},{"location":"reference/services/plugins/hooks.html","title":"Hooks Module API Reference","text":"<p>This section documents the internals of the <code>hooks</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks","title":"bijux_cli.services.plugins.hooks","text":"<p>Defines the hook specifications for the Bijux CLI plugin system.</p> <p>This module uses <code>pluggy</code>'s hook specification markers to define the formal set of hooks that plugins can implement. The <code>CoreSpec</code> class groups all standard lifecycle and execution hooks that the core application will invoke on registered plugins. This provides a clear and versioned interface for plugin developers.</p>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec","title":"CoreSpec","text":"<pre><code>CoreSpec(dependency_injector: DIContainer)\n</code></pre> <p>Defines the core hook specifications for CLI plugins.</p> <p>Plugins can implement methods matching these specifications to integrate with the CLI's lifecycle and command execution flow.</p> <p>Attributes:</p> <ul> <li> <code>_log</code>               (<code>ObservabilityProtocol</code>)           \u2013            <p>The logging service.</p> </li> </ul> <p>Initializes the <code>CoreSpec</code>.</p> <p>Parameters:</p> <ul> <li> <code>dependency_injector</code>               (<code>DIContainer</code>)           \u2013            <p>The DI container for resolving services like the logger.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>def __init__(self, dependency_injector: DIContainer) -&gt; None:\n    \"\"\"Initializes the `CoreSpec`.\n\n    Args:\n        dependency_injector (DIContainer): The DI container for resolving\n            services like the logger.\n    \"\"\"\n    self._log = dependency_injector.resolve(ObservabilityProtocol)\n</code></pre>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec.health","title":"health","text":"<pre><code>health() -&gt; bool | str\n</code></pre> <p>A hook to check the health of a plugin.</p> <p>This hook is called by the <code>bijux plugins check</code> command. A plugin can return a boolean or a string to indicate its status.</p> <p>Returns:</p> <ul> <li> <code>bool | str</code>           \u2013            <p>bool | str: <code>True</code> for healthy, <code>False</code> for unhealthy, or a string with a descriptive status message.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\ndef health(self) -&gt; bool | str:\n    \"\"\"A hook to check the health of a plugin.\n\n    This hook is called by the `bijux plugins check` command. A plugin can\n    return a boolean or a string to indicate its status.\n\n    Returns:\n        bool | str: `True` for healthy, `False` for unhealthy, or a string\n            with a descriptive status message.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook health called\", extra={})\n    return True\n</code></pre>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec.post_execute","title":"post_execute  <code>async</code>","text":"<pre><code>post_execute(name: str, result: Any) -&gt; None\n</code></pre> <p>A hook that is called immediately after a command has executed.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command that was executed.</p> </li> <li> <code>result</code>               (<code>Any</code>)           \u2013            <p>The result object returned from the command.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def post_execute(self, name: str, result: Any) -&gt; None:\n    \"\"\"A hook that is called immediately after a command has executed.\n\n    Args:\n        name (str): The name of the command that was executed.\n        result (Any): The result object returned from the command.\n    \"\"\"\n    self._log.log(\n        \"debug\",\n        \"Hook post_execute called\",\n        extra={\"name\": name, \"result\": repr(result)},\n    )\n</code></pre>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec.pre_execute","title":"pre_execute  <code>async</code>","text":"<pre><code>pre_execute(\n    name: str, args: tuple[Any, ...], kwargs: dict[str, Any]\n) -&gt; None\n</code></pre> <p>A hook that is called immediately before a command is executed.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the command to be executed.</p> </li> <li> <code>args</code>               (<code>tuple[Any, ...]</code>)           \u2013            <p>The positional arguments passed to the command.</p> </li> <li> <code>kwargs</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The keyword arguments passed to the command.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def pre_execute(\n    self, name: str, args: tuple[Any, ...], kwargs: dict[str, Any]\n) -&gt; None:\n    \"\"\"A hook that is called immediately before a command is executed.\n\n    Args:\n        name (str): The name of the command to be executed.\n        args (tuple[Any, ...]): The positional arguments passed to the command.\n        kwargs (dict[str, Any]): The keyword arguments passed to the command.\n    \"\"\"\n    self._log.log(\n        \"debug\",\n        \"Hook pre_execute called\",\n        extra={\"name\": name, \"args\": args, \"kwargs\": kwargs},\n    )\n</code></pre>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown() -&gt; None\n</code></pre> <p>A hook that is called once when the CLI engine shuts down.</p> <p>Plugins can use this hook to perform cleanup tasks, such as releasing resources or flushing buffers.</p> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def shutdown(self) -&gt; None:\n    \"\"\"A hook that is called once when the CLI engine shuts down.\n\n    Plugins can use this hook to perform cleanup tasks, such as releasing\n    resources or flushing buffers.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook shutdown called\", extra={})\n</code></pre>"},{"location":"reference/services/plugins/hooks.html#bijux_cli.services.plugins.hooks.CoreSpec.startup","title":"startup  <code>async</code>","text":"<pre><code>startup() -&gt; None\n</code></pre> <p>A hook that is called once when the CLI engine starts up.</p> <p>Plugins can use this hook to perform initialization tasks, such as setting up resources or starting background tasks.</p> Source code in <code>src/bijux_cli/services/plugins/hooks.py</code> <pre><code>@hookspec\nasync def startup(self) -&gt; None:\n    \"\"\"A hook that is called once when the CLI engine starts up.\n\n    Plugins can use this hook to perform initialization tasks, such as\n    setting up resources or starting background tasks.\n    \"\"\"\n    self._log.log(\"debug\", \"Hook startup called\", extra={})\n</code></pre>"},{"location":"reference/services/plugins/registry.html","title":"Registry Module API Reference","text":"<p>This section documents the internals of the <code>registry</code> module in Bijux CLI. </p>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry","title":"bijux_cli.services.plugins.registry","text":"<p>Provides a concrete plugin registry service using the <code>pluggy</code> framework.</p> <p>This module defines the <code>Registry</code> class, which implements the <code>RegistryProtocol</code>. It serves as the central manager for the entire plugin lifecycle, including registration, aliasing, metadata storage, and the invocation of plugin hooks. It is built on top of the <code>pluggy</code> library to provide a robust and extensible plugin architecture.</p>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry","title":"Registry","text":"<pre><code>Registry(telemetry: LoggingTelemetry)\n</code></pre> <p>               Bases: <code>RegistryProtocol</code></p> <p>A <code>pluggy</code>-based registry for managing CLI plugins.</p> <p>This class provides aliasing, metadata storage, and telemetry integration on top of the core <code>pluggy</code> plugin management system.</p> <p>Attributes:</p> <ul> <li> <code>_telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for events.</p> </li> <li> <code>_pm</code>               (<code>PluginManager</code>)           \u2013            <p>The underlying <code>pluggy</code> plugin manager.</p> </li> <li> <code>_plugins</code>               (<code>dict</code>)           \u2013            <p>A mapping of canonical plugin names to plugin objects.</p> </li> <li> <code>_aliases</code>               (<code>dict</code>)           \u2013            <p>A mapping of alias names to canonical plugin names.</p> </li> <li> <code>_meta</code>               (<code>dict</code>)           \u2013            <p>A mapping of canonical plugin names to their metadata.</p> </li> <li> <code>mapping</code>               (<code>MappingProxyType</code>)           \u2013            <p>A read-only view of the <code>_plugins</code> mapping.</p> </li> </ul> <p>Initializes the <code>Registry</code> service.</p> <p>Parameters:</p> <ul> <li> <code>telemetry</code>               (<code>LoggingTelemetry</code>)           \u2013            <p>The telemetry service for tracking registry events.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>@inject\ndef __init__(self, telemetry: LoggingTelemetry):\n    \"\"\"Initializes the `Registry` service.\n\n    Args:\n        telemetry (LoggingTelemetry): The telemetry service for tracking\n            registry events.\n    \"\"\"\n    self._telemetry = telemetry\n    self._pm = pluggy.PluginManager(\"bijux\")\n    from bijux_cli.services.plugins.hooks import CoreSpec\n\n    self._pm.add_hookspecs(CoreSpec)\n    self._plugins: dict[str, object] = {}\n    self._aliases: dict[str, str] = {}\n    self._meta: dict[str, dict[str, str]] = {}\n    self.mapping = MappingProxyType(self._plugins)\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.call_hook","title":"call_hook  <code>async</code>","text":"<pre><code>call_hook(\n    hook: str, *args: Any, **kwargs: Any\n) -&gt; list[Any]\n</code></pre> <p>Invokes a hook on all registered plugins that implement it.</p> <p>This method handles results from multiple plugins, awaiting any results that are coroutines.</p> <p>Parameters:</p> <ul> <li> <code>hook</code>               (<code>str</code>)           \u2013            <p>The name of the hook to invoke.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the hook.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the hook.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Any]</code>           \u2013            <p>list[Any]: A list containing the results from all hook implementations that did not return <code>None</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the specified hook does not exist.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>async def call_hook(self, hook: str, *args: Any, **kwargs: Any) -&gt; list[Any]:\n    \"\"\"Invokes a hook on all registered plugins that implement it.\n\n    This method handles results from multiple plugins, awaiting any results\n    that are coroutines.\n\n    Args:\n        hook (str): The name of the hook to invoke.\n        *args (Any): Positional arguments to pass to the hook.\n        **kwargs (Any): Keyword arguments to pass to the hook.\n\n    Returns:\n        list[Any]: A list containing the results from all hook\n            implementations that did not return `None`.\n\n    Raises:\n        ServiceError: If the specified hook does not exist.\n    \"\"\"\n    try:\n        hook_fn = getattr(self._pm.hook, hook)\n        results = hook_fn(*args, **kwargs)\n    except AttributeError as error:\n        raise ServiceError(f\"Hook {hook!r} not found\", http_status=404) from error\n    collected = []\n    if isinstance(results, AsyncIterable):\n        async for result in results:\n            if asyncio.iscoroutine(result):\n                collected.append(await result)\n            elif result is not None:\n                collected.append(result)\n    else:\n        for result in results:\n            if asyncio.iscoroutine(result):\n                collected.append(await result)\n            elif result is not None:\n                collected.append(result)\n    try:\n        self._telemetry.event(\"registry_hook_called\", {\"hook\": hook})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"hook_called\", \"error\": str(error)},\n        )\n    return collected\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.deregister","title":"deregister","text":"<pre><code>deregister(name: str) -&gt; None\n</code></pre> <p>Deregisters a plugin from the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to deregister.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the underlying <code>pluggy</code> deregistration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def deregister(self, name: str) -&gt; None:\n    \"\"\"Deregisters a plugin from the registry.\n\n    Args:\n        name (str): The name or alias of the plugin to deregister.\n\n    Returns:\n        None:\n\n    Raises:\n        ServiceError: If the underlying `pluggy` deregistration fails.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    plugin = self._plugins.pop(canonical, None)\n    if not plugin:\n        return\n    try:\n        self._pm.unregister(plugin)\n    except ValueError as error:\n        raise ServiceError(\n            f\"Pluggy failed to deregister {canonical}: {error}\", http_status=500\n        ) from error\n    self._meta.pop(canonical, None)\n    self._aliases = {a: n for a, n in self._aliases.items() if n != canonical}\n    try:\n        self._telemetry.event(\"registry_plugin_deregistered\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"deregister\", \"error\": str(error)},\n        )\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.get","title":"get","text":"<pre><code>get(name: str) -&gt; object\n</code></pre> <p>Retrieves a plugin by its name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to retrieve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>object</code> (              <code>object</code> )          \u2013            <p>The registered plugin object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the plugin is not found.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def get(self, name: str) -&gt; object:\n    \"\"\"Retrieves a plugin by its name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin to retrieve.\n\n    Returns:\n        object: The registered plugin object.\n\n    Raises:\n        ServiceError: If the plugin is not found.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    try:\n        plugin = self._plugins[canonical]\n    except KeyError as key_error:\n        try:\n            self._telemetry.event(\n                \"registry_plugin_retrieve_failed\",\n                {\"name\": name, \"error\": str(key_error)},\n            )\n        except RuntimeError as telemetry_error:\n            self._telemetry.event(\n                \"registry_telemetry_failed\",\n                {\"operation\": \"retrieve_failed\", \"error\": str(telemetry_error)},\n            )\n        raise ServiceError(\n            f\"Plugin {name!r} not found\", http_status=404\n        ) from key_error\n    try:\n        self._telemetry.event(\"registry_plugin_retrieved\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"retrieve\", \"error\": str(error)},\n        )\n    return plugin\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.has","title":"has","text":"<pre><code>has(name: str) -&gt; bool\n</code></pre> <p>Checks if a plugin is registered under a given name or alias.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the plugin is registered, otherwise False.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def has(self, name: str) -&gt; bool:\n    \"\"\"Checks if a plugin is registered under a given name or alias.\n\n    Args:\n        name (str): The name or alias of the plugin to check.\n\n    Returns:\n        bool: True if the plugin is registered, otherwise False.\n    \"\"\"\n    exists = name in self._plugins or name in self._aliases\n    try:\n        self._telemetry.event(\"registry_contains\", {\"name\": name, \"result\": exists})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"contains\", \"error\": str(error)},\n        )\n    return exists\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.meta","title":"meta","text":"<pre><code>meta(name: str) -&gt; dict[str, str]\n</code></pre> <p>Retrieves metadata for a specific plugin.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name or alias of the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>dict[str, str]: A dictionary containing the plugin's metadata.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def meta(self, name: str) -&gt; dict[str, str]:\n    \"\"\"Retrieves metadata for a specific plugin.\n\n    Args:\n        name (str): The name or alias of the plugin.\n\n    Returns:\n        dict[str, str]: A dictionary containing the plugin's metadata.\n    \"\"\"\n    canonical = self._aliases.get(name, name)\n    info = dict(self._meta.get(canonical, {}))\n    try:\n        self._telemetry.event(\"registry_meta_retrieved\", {\"name\": canonical})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"meta_retrieved\", \"error\": str(error)},\n        )\n    return info\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.names","title":"names","text":"<pre><code>names() -&gt; list[str]\n</code></pre> <p>Returns a list of all registered plugin names.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: A list of the canonical names of all registered plugins.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def names(self) -&gt; list[str]:\n    \"\"\"Returns a list of all registered plugin names.\n\n    Returns:\n        list[str]: A list of the canonical names of all registered plugins.\n    \"\"\"\n    names = list(self._plugins.keys())\n    try:\n        self._telemetry.event(\"registry_list\", {\"names\": names})\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\", {\"operation\": \"list\", \"error\": str(error)}\n        )\n    return names\n</code></pre>"},{"location":"reference/services/plugins/registry.html#bijux_cli.services.plugins.registry.Registry.register","title":"register","text":"<pre><code>register(\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None\n</code></pre> <p>Registers a plugin with the registry.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The canonical name of the plugin.</p> </li> <li> <code>plugin</code>               (<code>object</code>)           \u2013            <p>The plugin object to register.</p> </li> <li> <code>alias</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional alias for the plugin.</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional version string for the plugin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code> (              <code>None</code> )          \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ServiceError</code>             \u2013            <p>If the name, alias, or plugin object is already registered, or if the underlying <code>pluggy</code> registration fails.</p> </li> </ul> Source code in <code>src/bijux_cli/services/plugins/registry.py</code> <pre><code>def register(\n    self,\n    name: str,\n    plugin: object,\n    *,\n    alias: str | None = None,\n    version: str | None = None,\n) -&gt; None:\n    \"\"\"Registers a plugin with the registry.\n\n    Args:\n        name (str): The canonical name of the plugin.\n        plugin (object): The plugin object to register.\n        alias (str | None): An optional alias for the plugin.\n        version (str | None): An optional version string for the plugin.\n\n    Returns:\n        None:\n\n    Raises:\n        ServiceError: If the name, alias, or plugin object is already\n            registered, or if the underlying `pluggy` registration fails.\n    \"\"\"\n    if name in self._plugins:\n        raise ServiceError(f\"Plugin {name!r} already registered\", http_status=400)\n    if plugin in self._plugins.values():\n        raise ServiceError(\n            \"Plugin object already registered under a different name\",\n            http_status=400,\n        )\n    if alias and (alias in self._plugins or alias in self._aliases):\n        raise ServiceError(f\"Alias {alias!r} already in use\", http_status=400)\n    try:\n        self._pm.register(plugin, name)\n    except ValueError as error:\n        raise ServiceError(\n            f\"Pluggy failed to register {name}: {error}\", http_status=500\n        ) from error\n    self._plugins[name] = plugin\n    self._meta[name] = {\"version\": version or \"unknown\"}\n    if alias:\n        self._aliases[alias] = name\n    try:\n        self._telemetry.event(\n            \"registry_plugin_registered\",\n            {\"name\": name, \"alias\": alias, \"version\": version},\n        )\n    except RuntimeError as error:\n        self._telemetry.event(\n            \"registry_telemetry_failed\",\n            {\"operation\": \"register\", \"error\": str(error)},\n        )\n</code></pre>"}]}